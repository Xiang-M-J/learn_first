
[首页 | CSView计算机招聘知识分享](https://www.csview.cn/)

## 数的表示

### 数字可除性

判断一个数是否能被7整除

每个数都可以表示为 `10a+b` 的形式，已知 7a + 7b 能被7整除，那么只需要判断 `10a+b-7a-7b` 即 3a-6b 即 `a-2b` 能否被7整除。

```python
def isDivisibleBy7(num) :
     
    # If number is negative, make it positive
    if num < 0 :
        return isDivisibleBy7( -num )
 
    # Base cases
    if( num == 0 or num == 7 ) :
        return True
     
    if( num < 10 ) :
        return False
         
    # Recur for ( num / 10 - 2 * num % 10 ) 
    return isDivisibleBy7( num // 10 - 2 * ( num - num // 10 * 10 ) )
```



### 质数相关

如何判断一个数是不是质数，一种快速算法如下

依据为：所有数都可以表示为 `6k+i` 的形式，如果一个数不能被 2 或者 3 整除，那么如果是质数的话，必须满足 `6k+1` 或者 `6k+5` 这两种形式（其它形式都可以被 2 或者 3 整除），所以将这个数除 6k+1 或者 6k + 5 可以验证其是否是质数。

```python
import math

def isPrime(n):

    # Check if n is 1 or 0
    if n <= 1:
        return False

    # Check if n is 2 or 3
    if n == 2 or n == 3:
        return True

    # Check whether n is divisible by 2 or 3
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check from 5 to square root of n Iterate i by (i+6)
    i = 5
    while i <= math.sqrt(n):
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
```


埃拉托色尼筛法：找到0-n之间所有的质数和合数：如果n是质数，那么`n*n+k*n` （k 为大于等于0的整数）都不是质数，

```python
def SieveOfEratosthenes(n):

    # Create a boolean array "prime[0..n]" and initialize all entries it as true.
    # A value in prime[i] will finally be false if i is Not a prime, else true.
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

        # If prime[p] is not
        # changed, then it is a prime
        if (prime[p] == True):

            # Update all multiples of p
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

    # Print all prime numbers
    for p in range(2, n+1):
        if prime[p]:
            print(p)
```


## 进制问题

### 小鼠和毒药问题

**原始**：假设有1000瓶药水，其中有一瓶是毒药，可以任意混合，请问需要多少只小鼠才能验出有毒的一瓶？（每只小鼠只喝一次药水）

1000瓶药水可以编号为0, 1, ..., 999，写成二进制为

0000000000
0000000001
...
1111100111

为了确定哪一瓶有毒，只需要每一位为1的药水混合起来（对于最低位，就是1，3，5，7等等），喂给一只小鼠，这样一共需要10只小鼠，哪一只小鼠死了，表示该位为1，否则不为1，这样便能确定毒药的位置，当然如果全部都不死，那么第一瓶就是毒药。

即小鼠数量等于 $ceil(\log_2N)$，$N$ 为药水数量。

**变体1**：假设可以测试两轮，4只小鼠可以检测多少瓶药水（只有一瓶有毒，每只小鼠一轮只喝一次）

分成两种情况

1、如果死的小鼠不能更换，那么每只小鼠有3种状态，第一轮死、第二轮死和不死。那么共能测试 $3^{4}$ 瓶药水，具体测试过程为：

先将药水编成3进制

0000
0001
0002
0010
0011
0012
...
2222

第一轮先将每一位有2的药水全部混合起来，喂给4只小鼠。如果有一只小鼠死了，代表这一位为2，那么把所有该位为2的药水拿出来做第二轮测试，由于第二轮测试中该位全部为2，相当于回到了原来的情况，不过位数少了一位，用剩下的3只测试就够了；如果第一轮测试没有小鼠死，那么去掉所有编码包含2的瓶子，这样只剩下了01编码的，回到了二进制，用剩下的4只小鼠测试即可


2、如果死的小鼠可以替换，那么相当于有8只小鼠，这样共可以测试 $2^8$ 瓶药水。另外一种思考方式为将药水按顺序每16个混合在一起做一轮测试，这样下一轮再测试16个。

**变体2**：如果有16瓶药水，有一瓶是毒药，请问需要多少只小鼠能找到14瓶不是毒药的药水

这个问题可以转换成找两瓶可能带毒药的，由于16瓶药水可以表示成 xxxx 的形式，所以只需要确定前面3位就能找到可能带毒药的；先相邻两位混合成共8瓶药水，用3只小鼠测试即可。




## 查找表

查找表是一个数组，一般事先计算好查找表，在后续使用时直接在查找表中索引即可，可以加速运算。

如计算DFT时，事先将旋转因子$W_N^{kn}$计算好，对于长度为 N 的DFT，查找表需要存储 N 个复数（$W_N^0$，$W_N^1$，...，$W_N^{N-1}$）


### 计算整数的二进制中1的个数

如 9 的二进制为 1001， 1的个数为2

简单的算法如下：

```python
def  countSetBits(n):
    count = 0
    while (n):
        count += n & 1
        n >>= 1
    return count
```

时间复杂度为 log(n)

使用查找表可以将时间复杂度降为1，查找表是一个256位的数组，存储0-255这256个数字中1的个数

```python
BitsSetTable256 = [0] * 256

# Function to initialise the lookup table 
def initialize():
	
	# To initially generate the 
	# table algorithmically 
	BitsSetTable256[0] = 0
	for i in range(256):
		# 如果最后一位为0，那么向右移动一位，1 的个数不变
		# 如果最后一位不为0，那么向右移动一位，1 的个数减1
		BitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2] 
```

有了查找表后，对于1个32位的整数 n，只需要将整数 n 的二进制分成四段（注意每一段需要移动到最后8位，并且屏蔽之前若干位），分别计算即可

```python
def countSetBits(n):
	return (BitsSetTable256[n & 0xff] +
			BitsSetTable256[(n >> 8) & 0xff] +
			BitsSetTable256[(n >> 16) & 0xff] +
			BitsSetTable256[n >> 24])
```


## 数组问题

数组中存储了数据（C/C++等）或者索引（Python，JS等），数组是连续地址，可以在常数时间完成随机访问


### 第k个最大和连续子序列

找到一个序列中的子序列，使其之和从大到小排在第k位

常规的做法是用 $O(n^2)$  的时间获得所有的子序列之和，然后再排序，时间复杂度为 $O(n^2logn^2)$

可以使用前缀和以及最小堆优化，先计算序列的前缀和保存在数组中，这样子序列之和直接用数组的两个值相减即可。

```python
import heapq
def kthLargestSum(arr, N, K):

    # array to store prefix sums
    sum = []
    sum.append(0)
    sum.append(arr[0])
    for i in range(2, N + 1):
        sum.append(sum[i - 1] + arr[i - 1])

    # priority_queue of min heap
    Q = []
    heapq.heapify(Q)

    # loop to calculate the contiguous subarray sum position-wise
    for i in range(1, N + 1):

        # loop to traverse all positions that form contiguous subarray
        for j in range(i, N + 1):
            x = sum[j] - sum[i - 1]   # x 为某一段序列之和

            # if queue has less than k elements, then simply push it
            if len(Q) < K:
                heapq.heappush(Q, x)
            else:
                if Q[0] < x:
                    heapq.heappop(Q)
                    heapq.heappush(Q, x)

    # the top element will be then kth largest element
    return Q[0]
```


### 最小子序列之和大于某个值

找到一个子序列，使其和大于某一个值，并且要求这个子序列长度最小。该序列所有值大于等于0。

```python
def smallestSubWithSum(x, arr):

    i, j = 0, 0
    sum = 0
    ans = float('inf')

    while j < len(arr):

        # Expand window until sum > x or end of array reached
        while j < len(arr) and sum <= x:
            sum += arr[j]
            j += 1

        # If we reached end of array and sum 
        # still <= x, no valid subarray exists
        if j == len(arr) and sum <= x:
            break

        # Minimize window from start while maintaining sum > x
        while i < j and sum - arr[i] > x:
            sum -= arr[i]
            i += 1

        ans = min(ans, j - i)

        # Remove current start element and shift window
        sum -= arr[i]
        i += 1

    # Return 0 if no valid subarray found, else return min length
    if ans == float('inf'):
        return 0
    return ans
```


### 统计数组中每一个元素右侧大于自己的数的数量

[Surpasser Count of Each Element in Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-surpasser-count-of-each-element-in-array/)

给定一个包含不同元素的数组，找到数组中在右侧大于自己的数（Surpasser）（$i< j$ 并且 $a[i]<a[j]$），并统计数量。

使用合并排序的思路进行求解

在合并排序中，需要将数组连续二等分，连续分到最后，只有一个值。由于数组中包含的是不同的元素，可以用一个字典保存各个元素的Surpasser的数量。在合并的时候，只需要考虑左侧数组，因为左侧数组在原数组的位置在右侧数组之前，如果左侧数组中的元素小于右侧数组中的某个值，那么之后的全都小于。

```python
def merge(arr, lo, mid, hi, m):
    n1 = mid - lo + 1
    n2 = hi - mid
    left = arr[lo:lo+n1]
    right = arr[mid+1:mid+1+n2]

    i = j = 0
    k = lo

    # Merging two halves
    while i < n1 and j < n2:
      
        # All elements in right[j..n2] are greater than left[i]
        # So add n2 - j, in surpasser count of left[i]
        if left[i] < right[j]:
            m[left[i]] += n2 - j
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1

    # Copy remaining elements of left[] if any
    while i < n1:
        arr[k] = left[i]
        i += 1
        k += 1

    # Copy remaining elements of right[] if any
    while j < n2:
        arr[k] = right[j]
        j += 1
        k += 1

def mergeSort(arr, lo, hi, m):
    if lo < hi:
        mid = lo + (hi - lo) // 2

        # Sort left and right half
        mergeSort(arr, lo, mid, m)
        mergeSort(arr, mid + 1, hi, m)

        # Merge them
        merge(arr, lo, mid, hi, m)

def findSurpasser(arr):
    n = len(arr)
    
    # Map to store surpasser counts
    m = {key: 0 for key in arr}

    # Duplicate array to perform merge Sort
    # so that original array is not modified
    dup = arr[:]
    
    mergeSort(dup, 0, n - 1, m)
    
    # Store surpasser counts in result array
    # in the same order as given array
    res = [m[arr[i]] for i in range(n)]
    
    return res
```


> 如果是统计右侧小于自己的数，可以改成从大到小排

> 如果数组中包含重复元素，那么还需要有一个指数数组，或者更简单的，将数组改成 (num,  i) 这种形式，如下所示

```python
for i, a in enumerate(arr):
	m[(a, i)] = 0
	dup.append((a, i))
```


### 统计数组中前k个经常出现的元素

[Top K Frequent Elements in an Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-k-numbers-occurrences-given-array/)
一般做法是先统计频次，再排序

一种更好的方法是先统计频次，再使用一个最大堆来存储前k个频次最大的元素

```python
def topKFrequent(arr, k):

    # Dictionary 'mp' implemented as frequency hash table
    mp = Counter(arr)

    pq = []
    
    for key, value in mp.items():
        heapq.heappush(pq, (value, key))
        if len(pq) > k:
            heapq.heappop(pq)

    # store the result
    res = []
    
    while pq:
        res.append(heapq.heappop(pq)[1])

    res.reverse()
    return res
```

### 找到数据流中的中位数

给定一个数据流，如何找到中位数，假设有偶数个数，那么需要对中间两个进行平均。

使用堆实现，主要思路是维持两个堆，一个堆存储较小值，另一个堆存储较大值

注意python中只给出了最小堆的实现，最大堆可以通过每次传入数据时加上负号实现。

```python
import heapq

# Function to find the median of a stream of data
def getMedian(arr):
    
    # Max heap to store the smaller half of numbers
    leftMaxHeap = []
    
    # Min heap to store the greater half of numbers
    rightMinHeap = []
    
    res = []
  
    for num in arr:
        # Insert new element into max heap (negating for max behavior)
        heapq.heappush(leftMaxHeap, -num)
        
        # Move the top of max heap to min heap to maintain order
        temp = -heapq.heappop(leftMaxHeap)
        heapq.heappush(rightMinHeap, temp)
      
        # Balance heaps if min heap has more elements
        if len(rightMinHeap) > len(leftMaxHeap):
            temp = heapq.heappop(rightMinHeap)
            heapq.heappush(leftMaxHeap, -temp)
        
        # Compute median based on heap sizes
        if len(leftMaxHeap) != len(rightMinHeap):
            median = -leftMaxHeap[0]
        else:
            median = (-leftMaxHeap[0] + rightMinHeap[0]) / 2.0
        
        res.append(median)
    
    return res
```


### 给定范围内最常出现的整数

两个等长的数组分别给出左端点和右端点，求出这些范围内最常出现的整数

使用difference 数组求解：定义一个diff数组，`diff[left] += 1`，对应的 `diff[right+1] -=1`，这样diff中大于0的表示这里有多少个起点，小于0表示这里有多少个终点，求前缀和时最大值的位置即代表最常出现的数。

```python
MAX = 1000

def maximumOccurredElement(L, R, n):
 
    # Initialising all element of array to 0.
    arr = [0 for i in range(MAX)]
 
    # Adding +1 at Li index and subtracting 1 at Ri index.
    for i in range(0, n, 1):
        arr[L[i]] += 1
        arr[R[i] + 1] -= 1
 
    # Finding prefix sum and index
    # having maximum prefix sum.
    msum = arr[0]
    for i in range(1, MAX, 1):
        arr[i] += arr[i - 1]
        if (msum < arr[i]):
            msum = arr[i]
            ind = i
    return ind
```

该方法还能用于求是否存在重叠边界

[Check if any two intervals intersect in a given set - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-any-two-intervals-overlap-among-a-given-set-of-intervals/)

先求所有边界的最大值 N，初始化一个数组 `arr`，大小为N，对于每个间隔 `[a, b]`，`arr[a]+=1`，`arr[b+1]-=1`，然后求前缀和，如果前缀和中是否存在大于1的，如果有就是重叠

> 这种方法对于范围较大的数据而言，还是比较耗时的

### 买卖股票

[Stock Buy and Sell - At-most k Transactions Allowed - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-k-times/)


一个数组存储了每天的股票价格，问在给定的交易次数下，所获取的最大利润。该问题有如下三个变体：

1、如果只允许一次交易：最大利润为最大值减去最小值

```python
def maxProfit(prices):
    minSoFar = prices[0]
    res = 0

    # Update the minimum value seen so far if we see smaller
    for i in range(1, len(prices)):
        minSoFar = min(minSoFar, prices[i])
        
        # Update result if we get more profit                
        res = max(res, prices[i] - minSoFar)
    
    return res
```


2、只允许至多两次交易：

一种做法是直接迭代两次，两个循环的思路和一个循环的基本一致

```python
class Solution:
    
    def maxProfit1(self, idx, arr):
        minP = arr[idx]
        profit = 0
        for i in range(idx + 1, len(arr)):
            if minP < arr[i]:
                profit = max(profit, arr[i] - minP)
            else:
                minP = arr[i]
        return profit
    
    def maxProfit(self, arr):
        minP = arr[0]
        profit = 0
        
        for i in range(1, len(arr)):
            if minP < arr[i]:
                profit = max(profit, arr[i] - minP + self.maxProfit1(i, arr))
            else:
                minP = arr[i]
        return profit
```

这样时间复杂度过高

另一种方法考虑到最多进行两次交易，因此可以分成两段，即从 0 到 i 进行一次交易，从 i 到 n-1进行一次交易

```python
def maxProfit(arr):
	profit = 0
	profits = [0] * len(arr)
	
	minP = arr[0]
	# 计算从 0 到 i 的利润最大值
	for i in range(1, len(arr)):
		if minP < arr[i]:
			profits[i] = max(profits[i-1], arr[i] - minP) 
			profit = max(profit, profits[i])
		else:
			minP = arr[i]
			profits[i] = profits[i - 1]
	
	maxP = arr[-1]
	# 计算从 n-1 到i的利润最大值
	for j in range(len(arr) - 2, -1, -1):
		if maxP > arr[j]:
			profit = max(profit, maxP - arr[j] + profits[j])  
		else:
			maxP = arr[j]
	
	return profit
```


3、至多k次交易

最一般的方法是使用回溯法（递归），在某一天，只能进行三项操作，分别为买，卖和什么都不做

```python
def _solve(arr, i, k, state):
    if i == len(arr) or k == 0:
        return 0
    profit = 0
    if state == "buy":
        profit = _solve(arr, i + 1, k, state)   # 什么都不做
        profit = max(profit, _solve(arr, i + 1, k, "sell") - arr[i])  
    elif state == "sell":
        profit = _solve(arr, i + 1, k, state)   # 什么都不做
        profit = max(profit, _solve(arr, i + 1, k - 1, "buy") + arr[i])
    return profit

def solve(arr, k):
    profit = _solve(arr, 0, k, "buy")
    print(profit)
```

这种方法时间复杂度过高，存在大量重复计算步骤。

可以通过一个矩阵保存所有情况下的利润，避免重复计算。

```python
def solveProfit(arr, i, k, state, memo):
    if i == len(arr) or k == 0:
        return 0
    profit = 0
    if memo[i][k][state] != -1:
        return memo[i][k][state]
    
    if state == 1:
        profit = solveProfit(arr, i+1, k, state, memo)
        profit = max(profit, solveProfit(arr, i+1, k, 0, memo) - arr[i])
    elif state == 0:
        profit = solveProfit(arr, i+1, k, state, memo)
        profit = max(profit, solveProfit(arr, i+1, k-1, 1, memo) + arr[i])
    
    memo[i][k][state] = max(memo[i][k][state], profit)
    return profit

class Solution:
    
    def maxProfit(self, arr, k):
        # code here
        
        n = len(arr)
        memo = [[[-1]*2 for _ in range(k + 1)]
            for _ in range(n)]
        profit = solveProfit(arr, 0, k, 1, memo)
        return profit
```


另外还有动态规划的方法，这样可以不使用递归

参考上面的递归过程，可以得出动态递归方程为（从后向前）：

```
Buy: dp[i][k][1] = max(dp[i+1][k][1], dp[i+1][k][0] - prices[i])

Sell: dp[i][k][0] = max(dp[i+1][k][0], dp[i+1][k-1][1] + prices[i])
```

这里的dp指的是在第`i`天，有`k`次交易机会，状态为 1（可以买）或 0（可以卖）会得到的收益


### 在一个可以循环移位的序列中找到最大和子序列

首先在一个序列中找到最大和子序列的算法如下（Kadane算法）

```python
def findMaxSum(arr):
    n = len(arr)
    cur_sum = 0
    max_sum = -1e5
    for i in range(n):
        cur_sum += arr[i]
        max_sum = max(max_sum, cur_sum)
        if cur_sum < 0:
            cur_sum = 0
    return max_sum
```

其思路是求前缀和，如果前缀和小于0，就将前缀和置为0（相当于重新开始一个子序列），重新开始求，前缀和的最大值就是最大和子序列。

对于本问题，由于序列可以循环移位，如果将所有移位的情形全部列举，时间复杂度过高。可以换一种思路，对于循环后的子序列的最大和子序列，其实相当于在原本的子序列中求最小和子序列，求完最小和之后用总和减去最小和即为最大和

```python
def circularSubarraySum(arr):
    ##Your code here
    n = len(arr)
    max_sum1 = findMaxSum(arr)
    
    s_sum = 0
    for i in range(n):
        s_sum += arr[i]
        arr[i] = -arr[i]
    
    min_sum = findMaxSum(arr)
    max_sum2 = s_sum + min_sum
    
    return max(max_sum1, max_sum2)
```


### 直方图的最大矩形面积

[Largest Rectangular Area in a Histogram - GeeksforGeeks](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/)

通过数组给定一个直方图，找到这个直方图的最大矩形面积

一个简单的想法，对于每个直方图，我们分别在左右看是否有更大的直方图

```python
def getMaxArea(arr):
    res = 0
    n = len(arr)
    
    for i in range(n):
        curr = arr[i]
        
        # Traverse left while we have a greater height bar
        j = i - 1
        while j >= 0 and arr[j] >= arr[i]:
            curr += arr[i]
            j -= 1
        
        # Traverse right while we have a greater height bar
        j = i + 1
        while j < n and arr[j] >= arr[i]:
            curr += arr[i]
            j += 1
        
        res = max(res, curr)
    
    return res
```

如果先能找到每个点左边比自己小的索引和右边比自己小的索引，就可以避免重复搜索了

```python
def solve(arr):
    n = len(arr)

    prev = [-1] * n
    next = [n] * n

    st = []
    # 找到后一个较小值
    for i in range(n):
        # 如果 i 比栈中最后一个元素要小
        while st and arr[i] < arr[st[-1]]:
            next[st.pop()] = i
        st.append(i)
    
    # 找到前一个较小值
    st = []
    for i in range(n):
        while st and arr[i] < arr[st[-1]]:
            st.pop()
        if st:
            prev[i] = st[-1]
        st.append(i)
    
    maxArea = 0
    for i in range(n):
        # nowArea = arr[i]
        twidth = next[i] - prev[i] - 1
        maxArea = max(arr[i] * twidth, maxArea)
    return maxArea

```




## 哈希问题

哈希最大的特点是可以实现常数时间搜索、插入和删除，主要用于实现不相等的元素，如键值对。

哈希表在存储时存在一个连续的存储空间中，在查找时根据 key 直接通过哈希算法计算出存储的地址。



### 子集问题

问一个集合 m 是否包含了另一个集合 n

1、最简单的是直接暴力搜索
2、先排序再搜索（使用自带的高效排序方法）
3、使用哈希

实现方式

```python
def isSubset(a, b):

    # Create a hash set and insert all elements of arr1
    hash_set = set(a)

    # Check each element of arr2 in the hash set
    for num in b:
        if num not in hash_set:
            return False
    # If all elements of arr2 are found in the hash set
    return True
```


### 两数之和

在一个序列找到两个数和为目标值

一种常规做法是先排序，再用两个指针进行索引

哈希算法可以在一次迭代中找到：先按顺序选择一个值，然后看目标值减去这个值后的结果是否在集合里即可

为了找出所有的pair使得两数之和为目标值，还需要一个字典来记录序列中每个值出现的次数

```python
def countPairs(arr, target):
    freq = {}
    cnt = 0

    for i in range(len(arr)):
        
        # 仅考虑之前点和当前点是否能组成成对关系
        if (target - arr[i]) in freq:
            cnt += freq[target - arr[i]] 
        
        # 统计当前点及其之前点的频数
        freq[arr[i]] = freq.get(arr[i], 0) + 1 
    return cnt
```

这里的频率更新需要放在计数之后，放在前面则会导致如果 `arr[i]`和 `target-arr[i]` 相等会导致同一个位置相加。


>该问题还可以延申至矩阵中，将矩阵中的所有值用hashmap保存下来，然后对每个值判断其补值是否在hashmap中

### 三数之和

在一个序列找到三个数之和为目标值

先在外部循环确定好一个值，然后在内部循环时按照二数之和求

```python
def countTriplets(arr, target):
    cnt = 0
    n = len(arr)
    
    for i in range(n-2):
    # 先确定好 arr[i]
    # 内部循环按照二数之和求解
        freq = {}
        for j in range(i+1, n):
            if target - arr[i] - arr[j] in freq:
                cnt += freq[target - arr[i] - arr[j]]
            freq[arr[j]] = freq.get(arr[j], 0) + 1

    return cnt
```


为了节省空间，还可以先排序，先在外侧循环确定第一个数，再使用两个指针确定第2个和第3个数

```python
def threeSum(arr, target):
	n = len(arr)
	arr.sort()
	sols = []
	for i in range(n):
		# arr[i-1] 之前已经找过了，避免重复
		if i > 0 and arr[i] == arr[i-1]:
			continue
		
		l = i + 1  # 第二个数
		r = n - 1 # 第三个数
		
		while l < r:
			s = arr[i] + arr[l] + arr[r]
			if s == target:
				sols.append([arr[i], arr[l], arr[r]])
				l += 1
				r -= 1
				
				# 避免重复
				while l < r and arr[l] == arr[l-1]:
					l += 1
				
				while r > l and arr[r] == arr[r+1]:
					r -= 1
			
			elif s < target:
				l += 1
			else:
				r -= 1
			
	return sols
```


### 四数之和

对于四数之和，可以采用上面的思路，先确定两个值，再在内部循环时按照二数之和求解

还有另外一种思路，只在外部循环中确定第3个数的值，在频数中保存前两个数之和，然后循环第四个数

```python
def countSum(arr, target):
	#code here
	freq = {}
	n = len(arr)
	cnt = 0
	# 确定第三个数的值
	for i in range(n-1):
		# 这是第四个数
		for j in range(i+1, n):
			temp = arr[i] + arr[j]   # 三四两个数之和
			if target - temp in freq:
				cnt += freq[target - temp]
		
		# 此处更新前两个数之和，再遍历下一个i之前，需要更新i之前的可能对之和
		for j in range(i):
			temp = arr[i] + arr[j]
			freq[temp] = freq.get(temp, 0) + 1
	return cnt
```

如果只需要判断四数之和是否存在，还有另外一种思路

[4 Sum - Check if a Quadruple with given Sum Exists in an Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-four-numbers-with-sum-equal-to-given-sum/)

先计算前两个数字之和，将其作为键保存在字典里，对应的值为两个数字的坐标索引。再计算后两个数字之和，看目标减去这两个数字之和的结果是否位于字典里。

```python
def check4Sum(arr, target):
    n = len(arr)

    # Store sums of all pairs in a hash map
    mp = {}
    for i in range(n - 1):
        for j in range(i + 1, n):
            mp[arr[i] + arr[j]] = (i, j)

    # Traverse through all pairs and search for 
    # target - (current pair sum)
    for i in range(n - 1):
        for j in range(i + 1, n):
            sum_val = arr[i] + arr[j]

            # If target - sum is present in the hash map
            if target - sum_val in mp:
                p = mp[target - sum_val]

                # Check that all elements are different array elements 
                if p[0] != i and p[0] != j and p[1] != i and p[1] != j:
                    return True

    return False
```


### 最长子序列之和被K整除

对于一个序列，找到其中的一个最长子序列，使其之和能被 K 整除

使用一个hash（实际上是字典）保存前缀和及其对应位置

```python
def longestSubarrayDivK(arr, k):
    n = len(arr)
    res = 0
    prefIdx = {}
    sum = 0

    # Iterate over all ending points
    for i in range(n):

        # prefix sum mod k 
        sum = (sum + arr[i]) % k

        # If sum == 0, then update result with the
        # length of subarray arr[0...i]
        if sum == 0:
            res = i + 1

        # Update max length for repeating sum
        elif sum in prefIdx:
            res = max(res, i - prefIdx[sum])

        # Store the first occurrence of sum
        else:
            prefIdx[sum] = i

    return res
```

存储所有前缀和出现的位置，这样如何再次出现这个前缀和，就证明这两个前缀和中间的序列之和能被 K 整除。


### 最长子序列之和为 K

与上一个题目类似，使用一个字典保存前缀和，然后判断当前和减去目标值的结果是否在前缀和字典中。

```python
def subarraySum(arr, target):
	n = len(arr)
	prefixs = {}
	s = 0
	for i in range(n):
		s += arr[i]
		
		if s == target:
			return [1, i+1]
		
		if s - target in prefixs:
			return [prefixs[s - target]+1, i+1]
		
		prefixs[s] = i+1
	return [-1]
```


### 找到所有的序列对(a,b)使得 a%b = k

首先进行如下分析

$$
\eqalign{
  & a\% b = k  \cr 
  & a = n*b + k  \cr 
  & a - k = n*b \cr} 
$$
因此只需要找到 a-k 的因子即可，因子分解的算法如下

```python
def findDivisors(n):
    v = []

    # Vector is used to store the divisors
    for i in range(1, mt.floor(n**(.5)) + 1):
        if (n % i == 0):
            
            # If n is a square number, push only one occurrence
            if (n / i == i):
                v.append(i)
            else:
                v.append(i)
                v.append(n // i)
    return v
```

注意不是所有的因子都可以，需要测试一下。

```python
def printPairs(arr, k):
	n = len(arr)
	ans = 0
	occ = {}

	# creating a hashmap to store occurrence of array elements
	for num in arr:
		occ[num] = True

	isPairFound = False

	# iterating through the array elements
	for num in arr:
		# if k is in the array and k is smaller than num
		if k in occ and k < num:
			ans += 1
			isPairFound = True

		# if num is greater than or equal to k
		if num >= k:
			divisors = findDivisors(num - k)
			for divisor in divisors:
				# if num modulo divisor is equal to k, num is not equal to divisor
				# and divisor exists in the hashmap
				if num % divisor == k and num != divisor and divisor in occ:
					ans += 1
					isPairFound = True

	return ans
```


### 找到包含所有不重复元素的子序列

对于一个序列，其中一些元素是重复的，找到包含所有不重复元素的子序列

一般的做法是，通过两个循环，外部循环遍历序列左端，内部序列遍历序列的右端，判断是否存在所有的不重复元素

利用滑动窗口解决这一问题

只使用一个循环来遍历序列左端，通过一个字典来记录窗口内所有元素的出现频次，通过一个遍历记录窗口内不重复元素的数量。

如果窗口大小等于不重复元素数量，那么右端所有的子序列都包含了所有不重复元素

```python
def countDistinctSubarray(self,arr, n): 
	#code here.
	uset = set(arr)
	k = len(uset)  # 不重复元素的数量
	window = 0  # 记录窗口内不重复元素的数量
	vid = {}  # 记录窗口内各个值出现频次
	right = 0
	cnt = 0
	for left in range(n):
		while right < n and window < k:
			vid[arr[right]] = vid.get(arr[right], 0) + 1
			
			# 窗口内出现了新元素
			if vid[arr[right]] == 1:
				window += 1
			right += 1

		if window == k:
			cnt += n - right + 1

		# 窗口左侧将要缩小，失去最左侧元素
		vid[arr[left]] -= 1
		
		# 窗口将要失去一个新元素
		if vid[arr[left]] == 0:
			window -= 1
	return cnt
```

### 多数元素大于K的最长子序列

[Longest Subarray having Majority Elements Greater Than K - GeeksforGeeks](https://www.geeksforgeeks.org/length-of-longest-subarray-in-which-elements-greater-than-k-are-more-than-elements-not-greater-than-k/?ref=rp)

给定一个序列，在这个序列中找到一个最长子序列，要求子序列中的多数元素大于k。

建立一个辅助序列，原序列中大于k的元素记为1，否则记为-1，并且计算这个辅助序列的前缀和，前缀和的范围为 `[-n,n]`。对于序列 `arr[0:i]` 的前缀和 s，我们需要找到在 `i` 之前最左侧的比 s 还小的前缀和，这里如果每次都去求一次最小的前缀和显然太麻烦了，因此可以创建一个数组 `prefidx` 记录每个前缀和首次出现的位置，并且每个前缀和出现的位置都取前面最小的，这样便可以直接通过 `prefidx[s-1]` 的位置找到前面最小的。

```python
def longestSubarray(arr, k):
	# Code Here
	n = len(arr)
	preidx = {}
	s = 0
	for i in range(n):
		if arr[i] > k:
			s += 1
		else:
			s -= 1
		if s not in preidx:
			preidx[s] = i
	
	if -n in preidx:
		return 0
	
	preidx[-n] = n

	# 记录每个小于等于前缀和 i 的前缀和出现的最早的位置
	for i in range(-n+1, n+1):
		if i not in preidx:
			preidx[i] = preidx[i-1]
		else:
			preidx[i] = min(preidx[i], preidx[i - 1])
	
	s = 0
	res = 0
	for i in range(n):
		if arr[i] > k:
			s += 1
		else:
			s -= 1
		if s > 0:
			res = i + 1
		else:
			res = max(res, i - preidx[s - 1])
	return res
```


### 找到包含K个不同元素的最小序列

[Smallest subarray with k distinct numbers - GeeksforGeeks](https://www.geeksforgeeks.org/smallest-subarray-k-distinct-numbers/)

给定一个序列，找到一个包含K个不同元素的最小序列，使用滑动窗口解决这一问题

```python
from collections import defaultdict

def minRange(arr, n, k): 

	# Initially left and right side is -1 
	# and -1, number of distinct elements 
	# are zero and range is n. 
	l, r = 0, n 
	i = 0
	j = -1 # Initialize right side 
	
	hm = defaultdict(lambda:0) 
	while i < n: 
	
		while j < n: 
		
			# increment right side. 
			j += 1

			# if number of distinct elements less than k. 
			if len(hm) < k and j < n:
				hm[arr[j]] += 1

			# if distinct elements are equal to k 
			# and length is less than previous length. 
			if len(hm) == k and ((r - l) >= (j - i)):
				l, r = i, j 
				break

		# if number of distinct elements less than k, then break. 
		if len(hm) < k:
			break

		# if distinct elements equals to k then 
		# try to increment left side. 
		while len(hm) == k: 

			if hm[arr[i]] == 1: 
				del(hm[arr[i]]) 
			else:
				hm[arr[i]] -= 1

			# increment left side. 
			i += 1

			# it is same as explained in above loop. 
			if len(hm) == k and (r - l) >= (j - i): 
			
				l, r = i, j 
		
		if hm[arr[i]] == 1: 
			del(hm[arr[i]]) 
		else:
			hm[arr[i]] -= 1
			
		i += 1

	if l == 0 and r == n:
		print("Invalid k") 
	else:
		print(l, r) 
```


### 分数简化显示

[Fraction to Recurring Decimal - GeeksforGeeks](https://www.geeksforgeeks.org/represent-the-fraction-of-two-numbers-in-the-string-format/)

考虑两个数 a 和 b，`rem=a%b` 是余数，我们用一个字典记录rem首次出现时的结果字符串长度，如果rem能再次出现，那么结果字符串就是首次出现之前的字符串加上括号加之后的字符串

```python
def calculateFraction(a, b):
  
    # If the numerator is zero, answer is "0"
    if a == 0:
        return "0"
        
    res = "-" if (a < 0) ^ (b < 0) else ""

    a = abs(a)
    b = abs(b)

    # Calculate and Append the part before decimal point
    res += str(a // b)

    rem = a % b

    # If completely divisible, return res
    if rem == 0:
        return res

    res += "."
    mp = {}

    while rem > 0:
        # If this remainder is already seen,
        # then there exists a repeating fraction.
        if rem in mp:
            res = res[:mp[rem]] + "(" + res[mp[rem]:] + ")"
            break
        
        # If the remainder is seen for the first time,
        # store its index
        mp[rem] = len(res)

        rem = rem * 10
        # Calculate quotient, append it to result and
        # calculate next remainder
        res += str(rem // b)
        rem = rem % b

    return res
```


### 最长双调序列

[Longest Bitonic Subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/)

在一个序列中找到最长的双调序列，双调序列指严格的先增加后减小

如果严格增加1或减小1，有更简单的解决方法

[Length of longest strict bitonic subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/length-longest-strict-bitonic-subsequence/)


### 找到相同的子树

[Find All Duplicate Subtrees - GeeksforGeeks](https://www.geeksforgeeks.org/find-duplicate-subtrees/)

给定一个树，找到树中相同的子树（包括结构和值）

采用中序遍历，将每个节点的遍历结果变成字符串保存在字典中，看是否有相同的字符串。

```python
def inorder(node, m, res):
	if not node:
		return ""
	_str = "("
	_str += inorder(node.left, m, res)
	_str += str(node.data)
	_str += inorder(node.right, m, res)
	_str += ")"
	
	if _str in m and m[_str] == 1:
		res.append(node)
	
	if _str in m:
		m[_str] += 1
	else:
		m[_str] = 1
	return _str

def printAllDups(root):
	m = {}
	res = []
	inorder(root, m, res)
	return res
```


### 找到角点均为1的矩阵

[Find if there is a rectangle in binary matrix with corners as 1 - GeeksforGeeks](https://www.geeksforgeeks.org/find-rectangle-binary-matrix-corners-1/)



## 搜索问题

搜索分为线性搜索，二分搜索和双指针技术

线性搜索主要用于未排序的列表、小数据、链表等。线性搜索往往需要在每一次循环中进行一次条件判断，可以在列表的末尾添加目标值，这样直接用while

```python
def sentinelSearch(arr, n, key):

    # Last element of the array
    last = arr[n - 1]

    # Element to be searched is placed at the last index
    arr[n - 1] = key
    i = 0

    while (arr[i] != key):
        i += 1

    # Put the last element back
    arr[n - 1] = last

    if ((i < n - 1) or (arr[n - 1] == key)):
        print(key, "is present at index", i)
    else:
        print("Element Not found")
```

二分搜索实现如下，需要数据排好序，或者有一定的规律

```python
def binarySearch(arr, low, high, x):

    while low <= high:

        mid = low + (high - low) // 2

        # Check if x is present at mid
        if arr[mid] == x:
            return mid

        # If x is greater, ignore left half
        elif arr[mid] < x:
            low = mid + 1

        # If x is smaller, ignore right half
        else:
            high = mid - 1

    # If we reach here, then the element
    # was not present
    return -1
```

>如果是一个无限的有序数组，可以采用自定义边界的方法，如
>第一轮搜索 [0, 1]
>第二轮搜索 [1, 2]
>第三轮搜索 [2, 4]
>第四轮搜索 [4, 8]

双指针技术用两个指针同时索引，一般一个位于开始，另一个位于末尾，并且对于数据有一定的排序要求。

二分搜索的实现：

C++

```cpp
#include <bits/stdc++.h>
using namespace std;

// Function for check an element whether it
// is present or not
void isPresent(vector<int> &arr, int val) {
  
    // using binary_search to check if val exists
    if (binary_search(arr.begin(), arr.end(), val))
        cout << val << " exists in vector";
    else
        cout << val << " does not exist";

    cout << endl;
}

int main() {
    vector<int> arr = {10, 15, 20, 25, 30, 35};

    int val1 = 15;
    int val2 = 23;

    isPresent(arr, val1);
    isPresent(arr, val2);

    return 0;
}
```

Python 的bisect包提供了二分搜索并插入

```python
import bisect

# initializing list
li = [1, 3, 4, 4, 4, 6, 7]

# using bisect() to find index to insert new element
# returns 5 ( right most possible index )
print ("Rightmost index to insert, so list remains sorted is : ",
	end="")
print (bisect.bisect(li, 4))

# using bisect_left() to find index to insert new element
# returns 2 ( left most possible index )
print ("Leftmost index to insert, so list remains sorted is : ", 
	end="")
print (bisect.bisect_left(li, 4))

# using bisect_right() to find index to insert new element
# returns 4 ( right most possible index )
print ("Rightmost index to insert, so list remains sorted is : ",
	end="")
print (bisect.bisect_right(li, 4, 0, 4))
```


### 三分搜索

```python
def ternarySearch(l, r, key, ar):
    while r >= l:
        
        # Find mid1 and mid2
        mid1 = l + (r-l) // 3
        mid2 = r - (r-l) // 3

        # Check if key is at any mid
        if key == ar[mid1]:
            return mid1
        if key == ar[mid2]:
            return mid2

        # Since key is not present at mid, 
        # Check in which region it is present
        # Then repeat the search operation in that region
        if key < ar[mid1]:
            # key lies between l and mid1
            r = mid1 - 1
        elif key > ar[mid2]:
            # key lies between mid2 and r
            l = mid2 + 1
        else:
            # key lies between mid1 and mid2
            l = mid1 + 1
            r = mid2 - 1

    # key not found
    return -1
```


### 在未排序的数组中找到第K个最小的数

1、先排序再找，时间复杂度为 nlog(n)，空间复杂度为 1
2、用最大堆保存K个数，时间复杂度为 nlog(K)，空间复杂度为 K
3、快速选择算法，虽然最差情况下时间复杂度为 $n^2$，但是实践使用时是快的。

快速选择算法基于快速排序算法，partition的部分一致，只是在后续搜索时有差别，当找到pivot的位置时，比较该位置左侧是否包含了k-1个数，如果包含了，那么pivot就是需要的数，如果左侧大于k-1个数，就在左侧找，否则在右侧找。

```python
def kthSmallest(arr, l, r, k):

    # if k is smaller than number of elements in array
    if (k > 0 and k <= r - l + 1):

        # Partition the array around last
        # element and get position of pivot
        # element in sorted array
        index = partition(arr, l, r)

        # if position is same as k
        if (index - l == k - 1):
            return arr[index]

        # If position is more, recur for left subarray 
        if (index - l > k - 1):
            return kthSmallest(arr, l, index - 1, k)

        # Else recur for right subarray 
        return kthSmallest(arr, index + 1, r, 
                            k - index + l - 1)
    print("Index out of bound")
```

### 在循环移位后的排序数组中搜索

对于一个排好序的数组，如果进行了部分循环移位，在这种数组进行搜索

1、使用两次二分搜索，第一次搜索最小值的位置，再根据最小值的位置进行二分搜索
2、在上面搜索最小值时，已经用了这样的原理，即mid左侧或者右侧的数组必定有一侧是排好序的，如对于左侧，只要 `arr[low]<arr[mid]` 那么就是排好序的，如果key落在`arr[low]` 和 `arr[high]` 这个范围之内，就在左侧找，反之就在右侧找。 


### 在三个排好序的数组中找到最相近的数

有三个已经排好序的数组，现在要找到三个数组中最相近的三个数

使用三个指针分别索引这三个数组，每次会索引到三个数，求出这三个数中的最大值和最小值，然后计算最大值和最小值之间的差值，每次循环时只更新最小值对应的数组索引。

```python
def findCloset(A, B, C, p, q, r):
    diff = 1e9
    res_i = 0
    res_j = 0
    res_k = 0
    # Traverse Array
    i = 0
    j = 0
    k = 0
    while(i < p and j < q and k < r):
        # Find minimum and maximum of current three elements
        minimum = min(A[i], min(B[j], C[k]))
        maximum = max(A[i], max(B[j], C[k]));
 
        # Update result if current diff is
        # less than the min diff so far
        if maximum-minimum < diff:
            res_i = i
            res_j = j
            res_k = k
            diff = maximum - minimum;

        if diff == 0:
            break
            
        # Increment index of array with smallest value
        if A[i] == minimum:
            i = i+1
        elif B[j] == minimum:
            j = j+1
        else:
            k = k+1
```


### 求两个相同大小的有序数组合并后的中位数

https://www.geeksforgeeks.org/median-of-two-sorted-arrays

一种方法是使用归并排序中的归并方法

另一种方法是使用二分搜索

这里的二分搜索需要利用到中位数的一个性质，对于一个长度为 2n 的数组，中位数之前需要有n-1个数，因此如果确定了一个数组的mid，另一种数组的mid可以设置为 n-mid，这里的mid并不指一个元素，而是两个元素之间的边界，mid两边的元素分为记为`l`和`r`，只要满足两个数组的 `l` 和 `r` 相互交叉即可。

```python
def getMedian(a, b):
    n = len(a)
    
    # We can take [0...n] number of elements from a[]
    low, high = 0, n
    
    while low <= high:
      
        # Take mid1 elements from a
        mid1 = low + (high - low) // 2
        
        # Take mid2 elements from b
        mid2 = n - mid1
        
        # Find elements to the left and right of partition in a
        l1 = float('-inf') if mid1 == 0 else a[mid1 - 1]
        r1 = float('inf') if mid1 == n else a[mid1]
        
        # Find elements to the left and right of partition in b
        l2 = float('-inf') if mid2 == 0 else b[mid2 - 1]
        r2 = float('inf') if mid2 == n else b[mid2]
        
        # If it is a valid partition
        if l1 <= r2 and l2 <= r1:
            return (max(l1, l2) + min(r1, r2)) / 2.0
        
        # If we need to take fewer elements from a
        if l1 > r2:
            high = mid1 - 1    
        else:
            low = mid1 + 1
    
    return 0
```


### 在一个几乎排好序的数组中搜索

已有一个几乎排好序的数组，`arr[i]` 只会和 `arr[i-1]` 或者 `arr[i+1]` 交换位置

可以使用二分查找，不过需要考虑 mid, mid - 1 和 mid + 1三个位置，在判断mid-1和mid+1时，还需要注意不能让其超出`l`和 `r`

```python
def binarySearch(arr, l, r, x):

    if (r >= l):

        mid = int(l + (r - l) / 2)

        # If the element is present at one
        # of the middle 3 positions
        if (arr[mid] == x):
            return mid
        if (mid > l and arr[mid - 1] == x):
            return (mid - 1)
        if (mid < r and arr[mid + 1] == x):
            return (mid + 1)

        # If element is smaller than mid, then
        # it can only be present in left subarray
        if (arr[mid] > x):
            return binarySearch(arr, l, mid - 2, x)

        # Else the element can only be present in right subarray
        return binarySearch(arr, mid + 2, r, x)

    # We reach here when element is not present in array
    return -1
```


## 排序问题


对于链表，归并排序往往比较好


### 排序方法


#### 选择排序

从未排序的数组中找到最小（或最大）的元素放在开始，时间复杂度为 $O(n^2)$，内存占用率很低

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):

        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                # Update min_idx if a smaller element is found
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```


#### 冒泡排序

两次遍历，内部遍历时，如果当前值大于下一个值就交换位置

```python
def bubbleSort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        swapped = False

        # Last i elements are already in place
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if (swapped == False):
            break
```


#### 插入排序

从数组的第二个元素开始，找到其在前面应该所处的位置。

```python
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        # Move elements of arr[0..i-1], that are
        # greater than key, to one position ahead
        # of their current position
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
```


#### 堆排序

[Heap Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks](https://www.geeksforgeeks.org/heap-sort/)

将数组看成是完全二叉树，对于一个长度为n的数组，根节点位于0，i 节点的左节点位于2i+1，右节点位于2i+2。

然后创建一个最大堆：保证父节点比子节点大，如果子节点比父节点大，就交换子节点和父节点。

将最大的元素与未排序的数组最后一位交换，然后继续创建最大堆

下面是实现

```python
def heapify(arr, n, i):
    largest = i     # 根节点
    l = 2 * i + 1   # 左子节点
    r = 2 * i + 2   # 右子节点

    if l < n and arr[l] > arr[largest]:
        largest = l
    
    if r < n and arr[r] > arr[largest]:
        largest = r
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)   # 继续排列下面的节点

def heapSort(arr):
    n = len(arr)
    # 从最下层开始
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
```



#### 快速排序

对于一个序列，先选定一个值作为pivot，将数组排列成pivot右侧的值都大于等于pivot，左侧的值都小于等于pivot。

具体排列方法如下：首先选定一个pivot，一般选定子数组的左端，该位置记为index，另外分别从子数组的左端（记为left）和右端（记为right）向中间进发，先从右端开始。

从右端开始遍历，如果`arr[right]` 比 pivot 大，继续遍历，如果`arr[right]`小于 pivot，令`arr[index]` 等于`arr[right]`，然后将 right 这个位置记为新的 index。

右端暂时遍历完后，从左端开始遍历，同样的如果`arr[left]` 大于 pivot，令 `arr[index]` 等于 `arr[left]`，然后将 left 这个位置记为新的 index。

如此循环下去，直到 left 大于 right，循环结束之后，令`arr[index]`等于 pivot。

```python
def partition(arr, l, r):

    i = l
    j = r

    pivit = arr[l]
    index = l
    while i < j:
        while j > i:
            if arr[j] < pivit:
                arr[index] = arr[j]
                index = j
                break
            j -= 1
        
        while j > i:
            if arr[i] > pivit:
                arr[index] = arr[i]
                index = i
                break
            i += 1
    arr[index] = pivit
    return index

def quickSort(arr, l, r):
    if l < r and l >= 0:

        idx = partition(arr, l, r)

        quickSort(arr, l, idx-1)
        quickSort(arr, idx+1, r)
    
arr = [ 1, 3, 2, 0, 8 ]
n = len(arr)
quickSort(arr, 0, n-1)
```

对于已经排好序的数组，会出现时间复杂度为 $O(n^2)$ 的情况，为了避免这种情况，可以随机选择pivot，并将其移到数组最左端

```python
index = random.randint(l, r)
pivit = arr[index]
arr[index], arr[l] = arr[l], arr[index]
index = l 
```

对于数组包含大量重复元素的情况，可以在进行递归前进行判断（需要partition函数返回pivot）

```python
idx, pivit = partition(arr, l, r)
li = idx - 1
ri = idx + 1

while li > l and arr[li] == pivit:
	li -= 1
while ri < r and arr[ri] == pivit:
	ri += 1

quickSort(arr, l, li)
quickSort(arr, ri, r)
```

partition 函数的另外一种写法

```python
def partition(arr, l, r):
    x = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= x:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            
    arr[i], arr[r] = arr[r], arr[i]
    return i
```


#### 基数排序

基数排序是一种非比较的排序方法，对每一位进行排序，先对低位排序，然后收集起来（即计数排序），再按照高位排序，直至最高位

```python
def countingSort(arr, exp1):

    n = len(arr)
    # The output array elements that will have sorted arr
    output = [0] * (n)

    # initialize count array as 0
    count = [0] * (10)

    # Store count of occurrences in count[]
    for i in range(0, n):
        index = arr[i] // exp1
        count[index % 10] += 1

    # Change count[i] so that count[i] now contains actual
    # position of this digit in output array
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    i = n - 1
    while i >= 0:
        index = arr[i] // exp1
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    # Copying the output array to arr[],
    # so that arr now contains sorted numbers
    i = 0
    for i in range(0, len(arr)):
        arr[i] = output[i]

# Method to do Radix Sort

def radixSort(arr):

    # Find the maximum number to know number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead
    # of passing digit number, exp is passed. exp is 10^i
    # where i is current digit number
    exp = 1
    while max1 / exp >= 1:
        countingSort(arr, exp)
        exp *= 10
```

>基数排序可以用于解决计数排序面对数字范围过大时的问题



#### 桶排序

比较适用于分布均匀的数组，将数组分在若干个桶内，对于每个桶内的数据进行排序，再将桶内的数据排在一起。


### 两种类型数组排序

用两个指针，分别指向开始和末尾，如果左侧为0，就增加左指针，右侧为1，就减小右指针。然后交换左右指针对应的位置。

```python
def segregate0and1(arr):
    lo, hi = 0, len(arr) - 1
    while lo < hi:
        while arr[lo] == 0 and lo < hi:
            lo += 1
        while arr[hi] == 1 and lo < hi:
            hi -= 1
        if lo < hi:
            arr[lo], arr[hi] = arr[hi], arr[lo]
            lo += 1
            hi -= 1
```

或者另一种方法，见下面分割奇偶数

```python
def segregateevenandodd(arr):
    l = 0
    r = len(arr) - 1

    while l < r:
        if arr[l] & 1 == 0:
            l += 1
        else:
            arr[l], arr[r] = arr[r], arr[l]
            r -= 1
    m = e + 1 if (arr[e] & 1) == 0 else e  # m 位置为偶数
```

### 将数组排序为波形

给定一个未排序的数组，将其排序为 `arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4]` 这种情况

一种简单的算法为先排序，再交换相邻位置的元素

另一种算法：只需要考虑偶数位的元素，使其大于相邻的奇数位元素即可。

```python
def sortInWave(arr, n):

    # Traverse all even elements
    for i in range(0, n , 2):

        # If current even element is smaller than previous
        if (i > 0 and arr[i] < arr[i-1]):
            arr[i], arr[i-1] = arr[i-1], arr[i]

        # If current even element is smaller than next
        if (i < n-1 and arr[i] < arr[i+1]):
            arr[i], arr[i+1] = arr[i+1], arr[i]
```


### 排序多个机器上的数组

[Sort numbers stored on different machines - GeeksforGeeks](https://www.geeksforgeeks.org/sort-numbers-stored-on-different-machines/)

给定N个数组，每个机器保存了一些已经排好序的数组，但是数组长度不固定，现在需要排序所有机器中的数组。

每个机器上的数据流可以看成一个链表，可以使用一个最小堆来实现。

首先用一个容量为 N 的最小堆来存储N个机器上的链表头，从最小堆中取出最小值，将最小堆的头更新为最小值对应的链表中的下一个值，如果该链表已经空了，最小堆中的最后一个链表头移动过去。重复上述步骤直到最小堆为空。

```python
def extract_min(min_heap: MinHeap):
    if is_empty(min_heap):
        return None
    temp = min_heap.array[0][0]
    if temp.next is not None:
        min_heap.array[0] = (temp.next, min_heap.array[0][1])
    else:
        min_heap.array[0] = min_heap.array[min_heap.count - 1]
        min_heap.count -= 1
    
    min_heapify(min_heap, 0)
    return temp
```

使用python自带的heapq实现

```python
import heapq

class ListNode:
    def __init__(self, data, next = None):
        self.data = data
        self.next = next

def push(head, ndata):
    new_node = ListNode(ndata)
    new_node.next = head
    head = new_node
    return head

def merge_lists(lists):
    min_heap = []
    for li in lists:
        heapq.heappush(min_heap, (li.data, li))
    return min_heap

def external_sort(array, n):
     # Create a min heap of size equal to number of machines
    min_heap = merge_lists(array)

    while min_heap:
        data, node = heapq.heappop(min_heap)
        print(data, end=" ")
        if node.next != None:
            heapq.heappush(min_heap, (node.next.data, node.next))

if __name__ == '__main__':
    N = 3  # Number of machines
    array = [None] * N

    # an array of pointers storing the head nodes of the linked lists
    array[0] = None
    array[0] = push(array[0], 50)
    array[0] = push(array[0], 40)
    array[0] = push(array[0], 30)

    # Create a Linked List 35->45 for second machine
    array[1] = None
    array[1] = push(array[1], 45)
    array[1] = push(array[1], 35)

    # Create Linked List 10->60->70->80 for third machine

    array[2] = None
    array[2] = push(array[2], 100)
    array[2] = push(array[2], 80)
    array[2] = push(array[2], 70)
    array[2] = push(array[2], 60)
    array[2] = push(array[2], 10)

    external_sort(array, N)
```


### 按照二进制中1的数量排序


一种简单的方法是调用库函数

```python
def countBits(a):
    count = 0
    while (a):
        if (a & 1 ):
            count += 1
        a = a>>1
    return count

arr.sort(key= countBits, reverse=True)
```

还有利用计数排序的方法，即对于数组中的每个元素计算1的个数，然后按照1的个数出现次数包括每个元素。

### 让数组各元素均不同的最小增加量

给定一个数组，希望通过给一些元素加1，来使所有元素都不同

一种简单的方法是先排序，再比较前一个元素和后一个元素，始终保持后一个元素比前一个元素大1。

```python
def minIncrements(arr): 
	cnt = 0
	
	arr.sort()
	n = len(arr)
	
	for i in range(1, n):
		if arr[i] <= arr[i-1]:
			cnt += (arr[i-1] - arr[i]) + 1
			arr[i] = arr[i-1] + 1
	return cnt
```


另一种方法是使用一个频率数组记录原数组中所有元素的出现次数，然后只需要让所有元素的出现次数小于等于1即可。

```python
def minIncrements(arr): 
	max_value = max(arr) + 1
	
	freq = [0] * max_value
	
	for i in range(len(arr)):
		freq[arr[i]] += 1
	
	cnt = 0
	
	for i in range(max_value-1):
		if freq[i] > 1:
			cnt += freq[i] - 1
			freq[i+1] += freq[i] - 1
	
	while freq[max_value-1] > 1:
		cnt += freq[max_value-1] - 1
		freq[max_value-1] -= 1
	
	return cnt
```

### 火车到达的最少平台问题

https://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station

假设有若干列火车到达某个站点，到达时间为 arr，离站时间为dep，请问该站点最少需要多少个平台

一种方法是先分别对到达时间和离站时间进行排序，然后统计在每辆车来之前有多少辆车走即可

```python
def minimumPlatform(arr,dep):
	n = len(arr)
	arr.sort()
	dep.sort()
	min_plat = 0
	plat = 0
	j = 0
	for i in range(n):
		while j < n and dep[j] < arr[i]:
			j += 1
			plat -= 1   # 一辆车在本辆车来之前离站
		plat += 1   # 一辆车来了
		min_plat = max(min_plat, plat)
	return min_plat
```

另一种方法是将其转为有多少个区间重叠的问题，参考数组问题中给定范围内最常出现的整数解法。


### 距离最近的坐标点

[Closest Pair of Points using Divide and Conquer algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/)

分治算法：先按照x轴坐标对点进行排序，然后根据x轴坐标选择一个中间点，将数组分成两个部分，重复这个步骤，将数组分成大小小于3的子数组，在这些子数组中使用暴力解法求最小距离，得到左半边和右半边的最小距离 d，然后选择x轴距离中点小于d的点，再按照y轴排序，在这些点中使用暴力解法求出最小距离。

```python
import math

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
def dist(p1: Point, p2: Point):
    return math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)

def bruteForce(P, n):
    min_dist = float("inf")
    for i in range(n):
        for j in range(i+1, n):
            d = dist(P[i], P[j])
            min_dist = min(min_dist, d)
    return min_dist

def compX(item):
    return item.x

def compY(item):
    return item.y

def stripClosest(arr, n, d):
    min_dist = d
    arr = sorted(arr, key=compY)

    for i in range(n):
        for j in range(i + 1, n):
            # 减少可能的迭代次数
            if arr[j].y - arr[i].y > min_dist:
                break
            if dist(arr[i], arr[j]) < min_dist:
                min_dist = dist(arr[i], arr[j])
    return min_dist

def divide(arr, n):
    if n <= 3:
        return bruteForce(arr, n)
    
    mid = n // 2
    dl = divide(arr[:mid], mid)
    dr = divide(arr[mid:], n - mid)

    d = min(dl, dr)

    stripes = []
    for i in range(n):
        if abs(arr[i].x - arr[mid].x) < d:
            stripes.append(arr[i])
    return min(d, stripClosest(stripes, len(stripes), d))
    
P = [Point(x=2, y=3), Point(x=12, y=30),
         Point(x=40, y=50), Point(x=5, y=1), Point(x=12, y=10), Point(x=3, y=4)]
n = len(P)
P = sorted(P, key=compX)
print(divide(P, n))
```

### 计算交换次数

[Count Inversions of an Array - GeeksforGeeks](https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/)
[Minimum swaps to sort an array - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/)

给定一个未排序的数组，计算将其排好序所需的交换次数

#### 归并排序

可以使用归并排序来解决这一问题，参考数组问题中找到数组中每一个元素右侧大于自己的数

如果左侧序列中的某个数 `left[i]` 大于右侧序列中的某个数 `right[j]`，那么 `right[j]` 要和 `left[i]` 右侧和自身所有的数交换，交换次数为 n-i

```python
class Solution:
    def merge(self, arr, low, mid, high):
        res = 0
        left = arr[low: mid+1]
        right = arr[mid+1:high+1]
        n1 = len(left)
        n2 = len(right)
        
        i, j = 0, 0
        k = low
        while i < n1 and j < n2:
            if left[i] <= right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                res += n1 - i    # 唯一需要注意的地方，如果
                j += 1
            k += 1
        
        while i < n1:
            arr[k] = left[i]
            i += 1
            k += 1
        while j < n2:
            arr[k] = right[j]
            j += 1
            k += 1
        return res
    
    def mergeSort(self, arr, low, high):
        res = 0
        if low < high:
            mid = low + (high - low) // 2
            res += self.mergeSort(arr, low, mid)
            res += self.mergeSort(arr, mid+1, high) 
            res += self.merge(arr, low, mid, high)
        return res
        
    def inversionCount(self, arr):
        # Your Code Here
        n = len(arr)
        res = self.mergeSort(arr, 0, n-1)
        return res
```


#### 哈希方法（适用于不同的元素）

先使用自带的排序方法对数组进行排序，记录原数组的元素位置，将排好序的数组与原数组比较，如果不一致，进行交换

```python
def minSwaps(arr):
    
    # Temporary array to store elements in sorted order
    temp = sorted(arr)
    
    # Hashing elements with their correct positions
    pos = {}
    for i in range(len(arr)):
        pos[arr[i]] = i
    
    swaps = 0
    for i in range(len(arr)):
        if temp[i] != arr[i]:
            
            # Index of the element that should be at index i.
            ind = pos[temp[i]]
            arr[i], arr[ind] = arr[ind], arr[i]

            # Update the indices in the dictionary
            pos[arr[i]] = i
            pos[arr[ind]] = ind

            swaps += 1
    return swaps
```


#### 环检测

一个未排序的元素处于一个环中，找出这个环，环的大小减一就是这个环内元素需要交换的次数

```python
def minSwaps(arr):
    n = len(arr)
        
    # Array to Keep track of those elements
    # who already been included in the cycle.
    vis = [False] * n
    
    # Hashing elements with their original positions
    pos = {}
    for i in range(len(arr)):
        pos[arr[i]] = i
        
    arr.sort()

    swaps = 0
    for i in range(n):

        # Already a part of another cycle Or
        # in its correct position
        if vis[i] or pos[arr[i]] == i:
            continue

        j, cycleSize = i, 0

        # We make a cycle until it comes
        # back to first element again.
        while not vis[j]:
            vis[j] = True

            # move to next element of the cycle
            j = pos[arr[j]]
            cycleSize += 1

        # Update answer by adding current cycle.
        if cycleSize > 0:
            swaps += (cycleSize - 1)
    return swaps
```



### 排序多个有序链表

1、将K个有序链表，以类似归并排序中的分割方法，分割成单个，然后两两merge

2、使用最小堆，可以参考排序多个机器上的数组问题中的解法，维持一个大小为K的最小堆，将K个有序链表的头节点塞入最小堆中，每次弹出最小的头节点，并将最小头节点对应的链表中的下一个元素再塞入最小堆中。

```python
def mergeKLists(arr):
    pq = []
    
    # Insert the head nodes of k lists 
    for i in range(0, len(arr)):
        head = arr[i]
        if head is not None:
            heapq.heappush(pq, (head.data, i, head))
    
    # Initialize a dummy head
    dummy = Node(-1)
    tail = dummy

    while pq:
        
        # Pop the min node
        _, index, top = heapq.heappop(pq)
        
        # Append the node into list
        tail.next = top
        tail = top
        
        # If top node has next node, add it to the heap.
        if top.next is not None:
            heapq.heappush(pq, (top.next.data, index, top.next))

    return dummy.next
```


### 找到最小长度的未排序序列

[Find the Minimum length Unsorted Subarray, sorting which makes the complete array sorted - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/)

最简单的方法是先对序列排序，然后将排好序的数组和未排序的数组做对比，找到第一个和最后一个两者不相等的点。

一种时间复杂度为 $O(n)$ 的方法，考虑到如下情况

1、对于第`i`个元素，如果前面 i-1 个元素中存在比这个元素大的值，那么该元素是乱序的
2、从开始索引，从遇到逆序开始时，记录见到的最小值
3、第二步记录的最小值是整个乱序子序列的最小值，需要将其排到合适的地方

```python
def solve(arr):
    n = len(arr)
    
    has_meet_max = arr[0]
    unsort_min = float("inf")
    unsort_begin = 0
    unsort_end = 0 

    for i in range(1, n):
        has_meet_max = max(has_meet_max, arr[i-1]) # 前面 i - 1个数字的最大值
        
        if has_meet_max > arr[i]: # 如果前面 i-1 个元素中存在大于当前元素的元素，那么证明该元素是乱的
            unsort_end = i
        if arr[i] < arr[i-1]:   # 如果出现逆序，找出逆序数组中最小的元素 
            if unsort_min > arr[i]:
                unsort_min = arr[i]
                unsort_begin = i

    if unsort_begin > 0:     # 保证逆序数组中最小元素大于未排序数组左侧的元素
        while unsort_begin > 0 and arr[unsort_begin - 1] > unsort_min:
            unsort_begin -= 1

    print(f"{unsort_begin}, {unsort_end}")
```


另外一种更容易理解的方法：考虑到如下的情况
1、从左到右，找到第一个逆序的地方 `l`，从右到左，找到第一个逆序的地方 `r`
2、`[l, r]` 是一个可能的逆序子序列，从中找出最小值和最大值
3、在 `[0, l-1]` 中找到比最小值还小的地方，在 `[r+1,n-1]` 中找到比最大值还大的地方

```python
def printUnsorted(arr, n):
    e = n-1
	# 从左到右，找到逆序的地方
    for s in range(0,n-1):
        if arr[s] > arr[s+1]:
            break
        
    if s == n-1:
        print ("The complete array is sorted")
        exit()

    # 从右到左，找到逆序的地方
    e= n-1
    while e > 0:
        if arr[e] < arr[e-1]:
            break
        e -= 1

    # 找到逆序序列中的最大值和最小值
    max = arr[s]
    min = arr[s]
    for i in range(s+1,e+1):
        if arr[i] > max:
            max = arr[i]
        if arr[i] < min:
            min = arr[i]
            
    # 找到 [0, s-1] 中比最小值还小的地方
    for i in range(s):
        if arr[i] > min:
            s = i
            break

    # 找到 [e+1, n-1] 中比最大值还大的地方
    i = n-1
    while i >= e+1:
        if arr[i] < max:
            e = i
            break
        i -= 1
```


### K-排序问题

https://www.geeksforgeeks.org/nearly-sorted-algorithm

对于一个几乎排好序的序列，即每个元素位于和其应处位置的距离小于等于k的位置

可以使用堆排序，维持一个大小为k的堆，将前k个元素放进堆里，如果第k+1个元素小于堆顶元素，那么将其放到第一个位置，否则将堆顶元素弹出，并放入第一个位置，再将第k+1个元素塞进去

因为每个元素最多位于正确位置距离为k的位置，因此第k+2个元素不可能会比第1个元素还小，否则距离就是k+1了。

```python
def nearlySorted(self, arr, k):
	#code
	n = len(arr)
	min_heap = []
	if k == 0:
		return
	
	for i in range(k):
		heapq.heappush(min_heap, arr[i])
	
	for i in range(k, n):
		if arr[i] < min_heap[0]:
			arr[i - k] = arr[i]
		else:
			item = heapq.heappop(min_heap)
			arr[i - k] = item
			heapq.heappush(min_heap, arr[i])
	
	for i in range(n-k, n):
		item = heapq.heappop(min_heap)
		arr[i] = item
```


### 在线性时间排序固定范围内的数据

如果想要在线性时间排序范围为 0 到 $n^2-1$ 的数据，可以使用基数排序，将基数设置为 n 即可实现

```python
def sort(arr, n) :
    
    # Do counting sort for first digit in base n. 
    # Note that instead of passing digit number,
    # exp (n^0 = 1) is passed. 
    countSort(arr, n, 1) 
    # Do counting sort for second digit in base n. 
    # Note that instead of passing digit number, 
    # exp (n^1 = n) is passed. 
    countSort(arr, n, n)
```

### 让两个包含相同元素的数组相等所需的最小交换次数


[Minimum swaps to make two arrays consisting unique elements identical - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-to-make-two-array-identical/)

假设有两个数组包含了相同的元素，并且这些元素各不相同，但是顺序不同，请问如何计算让这两个数组排列顺序相同的最小交换次数。

因为只需要计算最小交换次数，因此只需要获取第二个数组的元素在第一个数组中的索引，最后该问题转换为了排序时计算交换次数。

如 `arrA = {3, 6, 4, 8}`，`arrB = {4, 6, 8, 3}`，arrB 中的元素在 arrA 中的索引为 `[2, 1, 3, 0]`，接着对索引排序即可。



### 无需额外空间融合两个有序列表

https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space

使用两个指针分别指向一个列表的结尾和另一个列表的开始，如果`a[i]>b[j]`，就交换，并移动到下一位，否则让一个指针继续前进，直至停止迭代。


```python
def mergeArrays(a, b):
	n1 = len(a)
	n2 = len(b)
	i = n1 - 1
	j = 0
	
	while i >= 0 and j < n2:
		if a[i] > b[j]:
			a[i], b[j] = b[j], a[i]
			i -= 1
			j += 1
		else:
			i -= 1
	a.sort()
	b.sort()
```


### 包含连续数的最小子集数

[Partition into minimum subsets of consecutive numbers - GeeksforGeeks](https://www.geeksforgeeks.org/count-minimum-number-subsets-subsequences-consecutive-numbers/)

注意只有一个数也算是连续数，因此，在排好序的数组中只需要 `arr[n] != arr[n-1]+1`，那么就代表有一个最小子集包含了连续数。

还可以用哈希，将数组转成一个集合，对于数组中的每个数X，如果 X-1不在集合中就代表有一个子集

### 将所有小于k的数排在一起的最小交换数


[Minimum swaps required to bring all elements less than or equal to k together - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-required-bring-elements-less-equal-k-together/)

首先统计所有小于k的数的个数 s，然后创建一个滑动窗口，大小为 s，统计这个窗口内大于等于k的元素的个数，最小交换数取这些窗口内大于等于k的元素个数的最小值即可。

上述结论基于这样的思考，如果想让所有小于k的元素排在一起，即排在一个滑动窗口内。这样的话，只需要将滑动窗口内大于等于k的元素交换出去即可。

```python
def minSwap (arr, k) : 
	n = len(arr)
	ws = 0
	for i in range(n):
		if arr[i] <= k:
			ws += 1
	
	if ws == 0:
		return 0
		
	bad = 0
	
	# 计算初始窗口中大于k的数量
	for i in range(ws):
		if arr[i] > k:
			bad += 1
	
	res = bad
	
	for i in range(ws, n):
		if arr[i - ws] > k:
			bad -= 1
		
		if arr[i] > k:
			bad += 1
		
		res = min(res, bad)
	return res
```


### 二叉树转为二叉搜索树的最小交换次数

[Minimum swap required to convert binary tree to binary search tree - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swap-required-convert-binary-tree-binary-search-tree/)

先进行中序遍历（in-order），将得到的数组排列出来，再计算将该数组排序所需的次数



### 计算文本中某个模式的出现次数


[Count distinct occurrences as a subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/count-distinct-occurrences-as-a-subsequence/)

给定一个文本，计算某个模式的出现次数，如

txt = banana, pat = ban，ban 在 banana 中的出现次数为3次，分别为 `[ban]`、`[ba n]` 和 `[b an]`

#### 自己写的解法


使用一个栈保存已经匹配好的字符，匹配到文本的末尾后就弹出栈中保存的字符，继续进行匹配。

```python
def patCount(txt, pat):
    n1 = len(txt)
    n2 = len(pat)

    stack = []    # 储存当前已经匹配好的字符
    
    i, j = 0, 0   # i 和 j分别是 txt 和 pat的索引，其中j是pat中目前需要匹配的字符索引
    cnt = 0
    while True:
        if i < n1:      # 如果没有索引到 txt 的末尾
            if txt[i] != pat[j]:   # 如果不相等，就向后索引
                i += 1
                continue
            if j == n2 - 1:        # 已经完成了一次匹配，继续尝试向后匹配更多的字符
                cnt += 1
                i += 1
                j = n2 - 1
            else: 
                stack.append(i+1)  # 储存字符的位置
                j += 1
                i += 1
        else:
            if len(stack) == 0:    # 已经匹配到末尾了，如果栈为空，证明已经没有可以匹配到的字符了
                break
            else:
                i = stack.pop()    # 弹出栈中的一个元素，进行下一次循环，匹配第j个元素
                j = len(stack)
    return cnt
```

#### 回溯法

对于两个字符串 txt 和 pat，从前到后，如果`txt[i+1]=pat[j+1]`，那么考虑`i+1` 之后的txt和 `j+1` 之后pat 以及 `i+1` 之后的txt和`j` 之后的pat

```python
def count(txt, pat, i, j, n1, n2):
    if j == n2 - 1:
        return 1
    if i == n1 - 1:
        return 0
    
    if txt[i+1] == pat[j+1]:
        return count(txt, pat, i + 1, j+1, n1, n2) + count(txt, pat, i + 1, j, n1, n2)
    
    return count(txt, pat, i+1, j, n1, n2)

count(txt, pat, -1, -1, n1, n2)   # 注意从-1开始
```

反过来，从后向前

```python
def subCountRec(i, j, txt, pat):
    if j == 0:    # 如果pat已经匹配完毕
        return 1

    if i == 0:    # 如果 txt 已经匹配完了 
        return 0

    if txt[i - 1] == pat[j - 1]:
        return subCountRec(i - 1, j - 1, txt, pat) \
          + subCountRec(i - 1, j, txt, pat)

    return subCountRec(i - 1, j, txt, pat)
subCountRec(0, 0, txt, pat)
```


这样做复杂度过高，可以使用一个矩阵保存已经计算过的情况。

```python
def countSubsequences(i, j, pat, txt, memo):
    if i == 0:
        return 1 
    if j == 0:
        return 0 

    # If already computed, return the result
    if memo[i][j] != -1:
        return memo[i][j]

    # If last characters don't match
    if pat[i - 1] != txt[j - 1]:
        memo[i][j] = countSubsequences(i, j - 1, pat, txt, memo)
    else:
      
        # Both characters match
        memo[i][j] = (countSubsequences(i, j - 1, pat, txt, memo)
                      + countSubsequences(i - 1, j - 1, pat, txt, memo))

    return memo[i][j]
  
def findSubsequencecount(txt, pat):
    m, n = len(pat), len(txt)

    # pat can't appear as a subsequence in txt
    if m > n:
        return 0

    # Create a memoization table
    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]

    return countSubsequences(m, n, pat, txt, memo)
```


#### 动态规划

```python
def find_subsequence_count(txt, pat):
    m = len(pat)
    n = len(txt)

    # pat can't appear as a subsequence
    # in txt
    if m > n:
        return 0

    # Create a 2D list initialized with 0
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Initializing first row with all 1s. An empty string
    # is a subsequence of all.
    for j in range(n + 1):
        dp[0][j] = 1

    # Fill mat[][] in bottom-up manner
    for i in range(1, m + 1):
        for j in range(1, n + 1):
          
            # If last characters don't match, then value
            # is the same as the value without the last character in txt.
            if pat[i - 1] != txt[j - 1]:
                dp[i][j] = dp[i][j - 1]
            else:
              
                # Value is obtained considering two cases:
                # a) All substrings without last character in txt
                # b) All substrings without last characters in both.
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1])

    return dp[m][n]
```




## 双指针

双指针一般用于已经排好序的数组中

### 三元组两个之和为第三个值

给定一个数组，找到一个三元组，其中两个值之和等于第三个值。

可以使用双指针来解决这一问题，对数组先排序，先确定第三个值，用双指针指向前两个值进行搜索

```python
def findTriplet(arr):
	arr.sort()
	n = len(arr)
	for i in range(2, n):   # i 指向第三个值
		l, r = 0, i - 1     # l, r 指向前两个值
		
		while l < r:
			target = arr[l] + arr[r]
			if target == arr[i]:
				return True
			elif target > arr[i]:
				r -= 1
			else:
				l += 1
		
	return False
```


### 雨水收集问题

[Trapping Rain Water Problem - Tutorial with Illustrations - GeeksforGeeks](https://www.geeksforgeeks.org/trapping-rain-water/)

#### 自己的算法

先找到全局最大值，然后从两边向最大值靠拢计算能收集的雨水。从左到右，如果遇到右侧大于等于左侧的**最大值**就计算一个能存储的雨水量。

如果用前缀和代替这里的求和过程，时间复杂度就能降为 $O(n)$

```python
def findMaxWater(self, arr):
        max_units = 0
        now_units = 0
        
        si = 0
        while arr[si] == 0:
            si += 1
        
        for i in range(si + 1, len(arr)):
            if arr[i] >= arr[si]:
                now_units = (i - si - 1) * arr[si] - sum(arr[si+1: i])
                si = i
                max_units += now_units
        return max_units
        
    def maxWater(self, arr):
        max_units = 0
        max_height = max(arr)
        max_height_index = arr.index(max_height)
        
        left_arr = arr[:max_height_index+1]
        right_arr = arr[max_height_index:][::-1]
        
        left_units = 0
        right_units = 0
        
        if len(left_arr) > 1:
            left_units = self.findMaxWater(left_arr)
        
        if len(right_arr) > 1:
            right_units = self.findMaxWater(right_arr)
        return left_units + right_units
```


#### 官方解法

找到每个点左边和右边的最大值，然后取较小的一个，减去该点的值即为该点的水量。使用两个数组分别存储每个点左侧和右侧的最大值，可以降低时间复杂度

```python
def maxWater(arr):
    n = len(arr)

    # Left[i] contains height of tallest bar to the
    # left of i'th bar including itself
    left = [0] * n

    # Right[i] contains height of tallest bar to
    # the right of i'th bar including itself
    right = [0] * n

    res = 0

    # Fill left array
    left[0] = arr[0]
    for i in range(1, n):
        left[i] = max(left[i - 1], arr[i])

    # Fill right array
    right[n - 1] = arr[n - 1]
    for i in range(n - 2, -1, -1):
        right[i] = max(right[i + 1], arr[i])

    # Calculate the accumulated water element by element
    for i in range(1, n - 1):
        minOf2 = min(left[i - 1], right[i + 1])
        if minOf2 > arr[i]:
            res += minOf2 - arr[i]

    return res
```


#### 双指针优化空间


考虑到如果我们知道 `arr[left]` 的左边最大值，和`arr[right]` 的右边最大值，左边最大值小于右边最大值，可以确定 `arr[left]`（因为`arr[left]` 的右侧最大值肯定大于左侧最大值），否则可以确定 `arr[right]`。

```python
def maxWater(arr):
    left = 1
    right = len(arr) - 2

    # lMax : Maximum in subarray arr[0..left-1]
    # rMax : Maximum in subarray arr[right+1..n-1]
    lMax = arr[left - 1]
    rMax = arr[right + 1]

    res = 0
    while left <= right:
      
        # If rMax is smaller, then we can decide the 
        # amount of water for arr[right]
        if rMax <= lMax:
          
            # Add the water for arr[right]
            res += max(0, rMax - arr[right])

            # Update right max
            rMax = max(rMax, arr[right])

            # Update right pointer as we have decided 
            # the amount of water for this
            right -= 1
        else: 
          
            # Add the water for arr[left]
            res += max(0, lMax - arr[left])

            # Update left max
            lMax = max(lMax, arr[left])

            # Update left pointer as we have decided 
            # the amount of water for this
            left += 1
    return res
```


#### 使用栈

```python
# Function to return the maximum water that can be stored
def maxWater(arr):
    st = []
    res = 0

    for i in range(len(arr)):
       
        # Pop all items smaller than arr[i]
        while st and arr[st[-1]] < arr[i]:
            pop_height = arr[st.pop()]

            if not st:
                break

            # arr[i] is the next greater for the removed item
            # and new stack top is the previous greater 
            distance = i - st[-1] - 1

            # Take the minimum of two heights (next and prev greater)
            water = min(arr[st[-1]], arr[i])

            # Find the amount of water
            water -= pop_height

            res += distance * water
        st.append(i)

    return res
```


## 滑动窗口

一般用于找到满足特定要求的子序列，找到包含不同字符的最长子字符串等问题。可以分为定长和不定长。


### 子序列和为K

在一个序列中找到一个子序列，其和为K。该问题可以通过前缀和求解，下面给出使用滑动窗口的解法

先设置窗口的左右点均为0，处于同一个点，先滑动右窗口，再滑动左窗口。

```python
def subarraySum(arr, target):
        
	l, r = 0, 0
	n = len(arr)
	
	s = 0
	
	while l <= r and r < n:
		while s < target and r < n:
			s += arr[r]
			r += 1
		
		if s == target:
			return [l+1, r]
		if s < target:
			return [-1]
		
		while s > target and l < r:
			s -= arr[l]
			l += 1
			
		if s == target:
			return [l+1, r]
	
	return [-1]
```


### 固定大小的子序列中的最大值

找到一个序列中每个固定长度的子序列的最大值。使用一个有序列表作为窗口

```python
from sortedcontainers import SortedList

def maxSlidingWindow(arr, k):
    ans = []
    window = SortedList()

    # Initialize the window with the first k elements
    for i in range(k):
        window.add((-arr[i], i))  # Use negative value for max-heap behavior

    # The maximum element in the first window
    ans.append(-window[0][0])

    # Process the remaining elements
    for i in range(k, len(arr)):
        window.add((-arr[i], i))
        # Remove the element that is out of the window
        if i - k >= 0:
            window.remove((-arr[i - k], i - k))
        # The maximum element in the current window
        ans.append(-window[0][0])

    return ans
```

也可以用一个最大堆保存

```python
import heapq

def max_sliding_window(arr, k):
    ans = []
    heap = []

    # Initialize the heap with the first k elements
    for i in range(k):
        heapq.heappush(heap, (-arr[i], i))

    # The maximum element in the first window
    ans.append(-heap[0][0])

    # Process the remaining elements
    for i in range(k, len(arr)):
        heapq.heappush(heap, (-arr[i], i))

        # Remove elements that are outside the current window
        while heap[0][1] <= i - k:
            heapq.heappop(heap)

        # The maximum element in the current window
        ans.append(-heap[0][0])

    return ans
```


### 长度为K的子序列中的首个负数

[First negative integer in every window of size k - GeeksforGeeks](https://www.geeksforgeeks.org/first-negative-integer-every-window-size-k/)

使用一个queue来保存窗口内有用的信息，在本问题中就是保存负数对应的索引

```python
from collections import deque

def printFirstNegativeIntegar(arr, n, k):
    Di = deque()

    for i in range(k):
        if arr[i] < 0:
            Di.append(i)
    
    for i in range(k, n):
        if not Di:
            print(0, end=" ")
        else:
            print(arr[Di[0]], end=" ")
        
        while Di and Di[0] <= (i - k):
            Di.popleft()
        
        if arr[i] < 0:
            Di.append(i)
    
    if not Di:
        print(0)
    else:
        print(arr[Di[0]])
```



### 长度至少为K的子序列之和的最大值

[Largest sum subarray of size at least k - GeeksforGeeks](https://www.geeksforgeeks.org/largest-sum-subarray-least-k-numbers/)


kadane算法：先计算每个索引前的最大和，然后用一个大小为k的窗口，计算连续k个元素之和。

```python
def maxSumWithK(a, n, k):
	maxSum = [a[0]]
	currMaxSum = a[0]
	# kadane算法
	for i in range(1, n):
		# 要么是a[i] 要么是前面i-1所对应的序列和a[i]
		currMaxSum = max(a[i], maxSum[i-1]+a[i])
		maxSum.append(currMaxSum)
	
	s = 0
	for i in range(k):
		s += a[i]
	res = s
	for i in range(k, n):
		s += a[i] - a[i - k]
		
		res = max(res, s)
		# 如果加上前面i-k的最大值
		res = max(res, s + maxSum[i-k])
	
	return res
```

另一种算法：用一个长度为k的窗口计算连续k个元素之和，然后计算窗口之前的元素之和，如果和为负值，就丢弃前面这些元素

```python
def maxSumWithK(arr, k):
    
    # Calculate initial sum of first k elements (first window)
    sum = 0
    for i in range(k):
        sum += arr[i]

    last = 0
    j = 0
    ans = float('-inf')
    ans = max(ans, sum)

    # Process rest of the array after first k elements
    for i in range(k, len(arr)):

        # Add current element to window sum
        sum = sum + arr[i]

        # Add element at j to 'last' and increment j
        last = last + arr[j]
        j += 1

        # Update answer if current window sum is greater
        ans = max(ans, sum)

        # If sum of elements before window becomes negative
        if last < 0:
            sum = sum - last
            ans = max(ans, sum)
            last = 0

    return ans
```


## 前缀和


前缀和的大小和原数组相同，`prefixSum[i] = arr[0]+arr[1]+...+arr[i]`

从 L 到 R 的和用前缀和表达为（L 和 R 均从 1 开始计数）
如果 L 大于1，`prefixSum[R] - prefixSum[L-1]`，否则为 `prefixSum[R]`

前缀和可以用于产生满足一定概率分布的随机数 [Prefix Sum Array - Implementation and Applications in Competitive Programming - GeeksforGeeks](https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/)

### 令所有子序列之和小于k的最大子序列长度

[Maximum subarray size, such that all subarrays of that size have sum less than k - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-subarray-size-subarrays-size-sum-less-k/)

给定一个子序列，找到一个最大的序列长度，使得所有小于该长度的子序列之和小于k。

该问题可以转为找到一个最小的子序列长度使得其之和大于k，可以使用滑动窗口解决

```python
def solve(arr, k):
    l = 0
    n = len(arr)
    s = 0
    res = n
    no_res = False
    for r in range(n):

        s += arr[r]

        while s > k:
            s -= arr[l]
            l += 1
            res = min(res, r - l + 1)

            # 对于全部大于0的序列来说，如果s等于0，意味着 l > r，
            # 证明arr[r]为一个大于k的数，这样不可能出现和小于k的子序列
            if s == 0:
                no_res = True
                break
        if no_res:
            res = -1
            break
```


### 子序列模m余数的最大值

对于一个序列，求其子序列模m后的余数的最大值

首先求前缀和关于m的余数，并存入一个集合中，每次求出余数后，在这个集合中找到比这个余数至少大1的余数，假设找到余数正好大 `a`，这样两个前缀和相减之后，余数为`m-a`。

```python
def solve(arr, m):
    n = len(arr)

    mp = set()
    mp.add(0)   # 空子序列之和为0，余数也为0
    prefix = 0
    res = 0

    for i in range(n):

        prefix = (prefix + arr[i]) % m
        res = max(res, prefix)
        _p = 0
        for p in mp:
            if p >= prefix + 1:
                _p = p
        
        if _p != 0:
            res = max(res, prefix - _p + m)
        mp.add(prefix)
    return res
```



## 字符串

### 打印所有的可能的带空格的字符串

[Print all possible strings that can be made by placing spaces - GeeksforGeeks](https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/)

```python
def print_util(str):
    strs = []
    if len(str) == 1:
        strs.append(str)
        return strs

    strtemp = print_util(str[1:])

    for i in range(len(strtemp)):
        strs.append(str[0]+ strtemp[i])
        strs.append(str[0] + " "+ strtemp[i])
    
    return strs


def print_all_strings(s):
    strs = print_util(s)
    for i in strs:
        print(i)
```


另一种解法

```python
def get_all_possible_string_utils(s, res, i, r):
	if i >= len(s):
		res.append(r)
		return
	
	self.get_all_possible_string_utils(s, res, i+1, r + " "+ s[i])
	self.get_all_possible_string_utils(s, res, i+1, r + "" + s[i])
    
def get_all_possible_string(s):
	res = []
	get_all_possible_string_utils(s, res, 1, s[0])
	return res
```


### 字符串的数值运算

[Multiply Large Numbers represented as Strings - GeeksforGeeks](https://www.geeksforgeeks.org/multiply-large-numbers-represented-as-strings/)

[Divide large number represented as string - GeeksforGeeks](https://www.geeksforgeeks.org/divide-large-number-represented-string/)



### 字符串是否一一映射

[Isomorphic Strings Check - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-two-given-strings-are-isomorphic-to-each-other/)

判断两个字符串是否能一一对应，基本思路为统计每个字符串每个字母的首次出现位置，如果相同的话就证明，两个字母出现的位置相同（只需要记录首次出现即可，因为如果后续不匹配，就会遇到不同的字母，结果自然不同）

```python
def areIsomorphic(self,s1,s2):
	d1 = {}
	d2 = {}
	
	if len(s1) != len(s2):
		return False
	
	for i in range(len(s1)):
		if s1[i] not in d1:
			d1[s1[i]] = i
		
		if s2[i] not in d2:
			d2[s2[i]] = i
			
		if d1[s1[i]] != d2[s2[i]]:
			return False
	return True
```


### 判断字符串是否为其它两个字符串的插值

[Check if a String is Interleaving of Other Two - GeeksforGeeks](https://www.geeksforgeeks.org/find-if-a-string-is-interleaved-of-two-other-strings-dp-33/)

给定三个字符串，判断第三个字符串是否是另外两个字符串的插值。

#### 回溯法

用 `i` 和 `j` 分别索引前两个字符串，然后 `i + j` 索引第三个字符串

```python
def interleave(s1, s2, s3, i, j):

    if i == len(s1) and j == len(s2) and i + j == len(s3):
        return True
    
    # 如果 s3[i+j] 为 s1 的第i个元素，继续匹配 s1的下一个元素
    a = i < len(s1) and s3[i+j] == s1[i] and interleave(s1, s2, s3, i+1, j)
    b = j < len(s2) and s3[i+j] == s2[j] and interleave(s1, s2, s3, i, j+1)
    return a or b

def solve(s1, s2, s3):
    if len(s1) + len(s2) != len(s3):
        print(False)
        return
    res = interleave(s1, s2, s3, 0, 0)
    print(res)
```


#### 动态规划

。。。



### 获取字符串所有的置换结果

[Permutations of given String - GeeksforGeeks](https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/)



![](https://media.geeksforgeeks.org/wp-content/uploads/20250106173028544574/4.webp)


```python
def recurPermute(index, s, ans):

    # Base Case
    if index == len(s):
        ans.append("".join(s))
        return

    # Swap the current index with all possible indices and recur
    for i in range(index, len(s)):
        s[index], s[i] = s[i], s[index]
        recurPermute(index + 1, s, ans)
        s[index], s[i] = s[i], s[index]

# Function to find all unique permutations
def findPermutation(s):

    # Stores the final answer
    ans = []

    recurPermute(0, list(s), ans)

    # sort the resultant list
    ans.sort()
    return ans
```


### 最长回文字符串

[Longest Palindromic Substring - GeeksforGeeks](https://www.geeksforgeeks.org/longest-palindromic-substring/)

遍历字符串的每个位置 `i`，以 `i` 为中心向两边扩展统计回文字符串的长度。


### 回文字符串的最小切割

[Palindrome Partitioning - GeeksforGeeks](https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/)

对一个字符串进行切割，使其每个子字符串都是回文的，求最小切割次数

递归：对问题进行分析，首先需要编写一个判断回文的函数，递归过程中输入字符串，子字符串的起始点和终点，对这两个点之间的每一个点都尝试一次切割，取其中的最小值

```python
import sys

# Function to check if a substring is a palindrome
def isPalindrome(s, i, j):
    while i < j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True

# Recursive function to find the minimum number 
# of cuts needed for palindrome partitioning
def palPartitionRec(s, i, j):
    if i >= j or isPalindrome(s, i, j):
        return 0

    res = sys.maxsize
    
    for k in range(i, j):
        cuts = 1 + palPartitionRec(s, i, k) \
                 + palPartitionRec(s, k + 1, j)
        res = min(res, cuts)

    return res

def palPartition(s):
    return palPartitionRec(s, 0, len(s) - 1)
```


加上矩阵存储状态

```python
# Function to check if a substring is a palindrome
def isPalindrome(s, i, j):
    while i < j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True

# Recursive function to find the minimum number of
# cuts needed for palindrome partitioning
def palPartitionRec(s, i, j, memo):
  
    # Check memo for previously computed results
    if memo[i][j] != -1:
        return memo[i][j]

    # Base case: If the substring is empty or 
    # a palindrome, no cuts needed
    if i >= j or isPalindrome(s, i, j):
        memo[i][j] = 0
        return 0

    res = sys.maxsize

    # Iterate through all possible partitions and
    # find the minimum cuts needed
    for k in range(i, j):
        cuts = 1 + palPartitionRec(s, i, k, memo) \
        + palPartitionRec(s, k + 1, j, memo)
        res = min(res, cuts)

    memo[i][j] = res
    return res

def palPartition(s):
    n = len(s)
    memo = [[-1 for _ in range(n)] for _ in range(n)]
    return palPartitionRec(s, 0, n - 1, memo)
```


使用动态规划，在计算是否是回文字符串时也采用了动态规划的方法

```c
int palPartition(string& s) {
    int n = s.length();

    // dp[i][j] = Minimum number of cuts needed for
    // palindrome partitioning of substring s[i..j]
    int dp[n][n];

    // isPalin[i][j] = true if substring s[i..j] 
      // is palindrome,else false
    bool isPalin[n][n];

    // Every substring of length 1 is a palindrome
    for (int i = 0; i < n; i++) {
        isPalin[i][i] = true;
        dp[i][i] = 0;
    }

    for (int len = 2; len <= n; len++) {

        // Build solution for all substrings s[i ... j] 
          // of length len
        for (int i = 0, j = i + len - 1; j < n ; i++, j++) {
          
            // If len is 2, then we just need to
            // compare two characters. 
            if (len == 2)
                isPalin[i][j] = (s[i] == s[j]);
            else
                isPalin[i][j] = (s[i] == s[j]) && 
                                      isPalin[i + 1][j - 1];

            // IF s[i..j] is palindrome, then dp[i][j] is 0
            if (isPalin[i][j] == true)
                dp[i][j] = 0;
            else {

            // Make a cut at every possible location starting 
              // from i to j, and get the minimum cost cut.
                dp[i][j] = INT_MAX;
                for (int k = i; k <= j - 1; k++)
                    dp[i][j] = min(dp[i][j], 1 + 
                                   dp[i][k] + dp[k + 1][j]);
            }
        }
    }

    // Return the min cut value for
    // complete string. i.e., s[0..n-1]
    return dp[0][n - 1];
}
```


上面这一方法还能继续优化，先动态规划计算子字符串是否为回文字符串，然后用dp表示 0 到 i的字符串的最小切分次数，如果`0`到`i`不是回文字符串，就在 `1` 到 `i` 之间重新划分起点。

```python
def generatePal(s, isPalin):
    n = len(s)

    # Substring s[i .. i] of len 1 
    # is always palindromic
    for i in range(n):
        isPalin[i][i] = True

    # Iterate over different lengths of substrings
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            # Check whether s[i] == s[j] and the
            # substring between them is a palindrome
            if s[i] == s[j] and (length == 2 or isPalin[i + 1][j - 1]):
              
                # Mark the substring from i to j as a palindrome
                isPalin[i][j] = True

# Function to calculate the minimum number of cuts required
# to make all substrings of 's' palindromic
def palPartition(s):
    n = len(s)

    # 2D array to store whether substring s[i, j] is a palindrome or not
    isPalin = [[False] * n for _ in range(n)]

    generatePal(s, isPalin)

    # dp[i] stores minimum cuts for Palindrome Partitioning of substring s[0...i] 
    dp = [n] * n
    
    # There is no cut required for single character as it is always palindrome
    dp[0] = 0

    # Iterate over the given string
    for i in range(1, n):

        # Check if string 0 to i is palindrome.
        if isPalin[0][i]:
            # if palindrome then cuts required is 0
            dp[i] = 0
        else:
            for j in range(1, i+1):
                # if substring s[j...i] is palindromic
                # then we can make a cut over here
                if isPalin[j][i]:
                    # update dp[i] with minimum cuts
                    dp[i] = min(dp[i], 1 + dp[j - 1])

    # Return the minimum cuts required 
    # for the entire string 's'
    return dp[n - 1]
```


### 获取所有的顺序子字符串

回溯法

```python
def solve(s):
    def _solve(s, idx, res, sols):
        
        if idx == len(s)+1:
            return
        if len(res) > 0:
            sols.append(res)

        for i in range(idx, len(s)):
            res += s[i]
            _solve(s, i+1, res, sols)
            res = res[:-1]
    
    sols = []
    _solve("".join(sorted(s)), 0, "", sols)
    print(sols)

solve("cab")
```

使用二进制mask实现

```python
def solve_b(s):

    n = len(s)
    sols = []
    s = ''.join(sorted(s))

    for i in range(1, 2 ** n):
        mask = bin(i)[2:].zfill(n)
        subs = "".join([s[j] for j in range(n) if mask[j] == "1"])
        sols.append(subs)
    sols.sort()
    print(sols)
```


### 打印所有的回文字符串（拆分字符串）

[Print all Palindromic Partitions of a String using Backtracking - GeeksforGeeks](https://www.geeksforgeeks.org/given-a-string-print-all-possible-palindromic-partition/)

首先拆分字符串为子字符串，然后判断子字符串是否是回文字符串

拆分子字符串的代码为

```python
def palPartitionRec(s, idx, p, sols):
	if idx == len(s):
		sols.append(p[:])
		return
	temp = ""
	for i in range(idx, len(s)):
		temp += s[i]
		
		p.append(temp)
		# 注意是i+1，不是 idx + 1
		palPartitionRec(s, i+1, p, sols)
		p.pop()
sols = []
palPartitionRec(s, 0, [], sols)
print(sols)
```


只需要加上判断temp是否为回文的条件即可
```python
def allPalindromicPerms(s):
	# code here 
	def is_palindrome(s):
		return s == s[::-1]
	
	def _all_palindrome(s, idx, res, sols):
		
		if idx == len(s):
			sols.append(res[:])
			return
		
		temp = ""
		for i in range(idx, len(s)):
			temp += s[i]
			if is_palindrome(temp):
				res.append(temp)
				_all_palindrome(s, i+1, res, sols)
				res.pop()
	
	sols = []
	_all_palindrome(s, 0, [], sols)
	return sols
```

### 判断一个字符串是否是scramble

[Check if a string is a scrambled form of another string - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-string-is-a-scrambled-form-of-another-string/)


### 判断一句话能否被给定词表分解

[Word Break - GeeksforGeeks](https://www.geeksforgeeks.org/word-break-problem-dp-32/)

判断一句话能否被给定的词表分解，使用动态规划的方法，通过一个数组保存 `s[0:i+1]` 时是否可以被分，如果可以，就尝试一下在 `i+1` 之后是否存在可以被分解的，每次只取最短的一种可能。

```python
def wordBreak(s, dictionary):
	# Complete this function
	n = len(s)
	dp = [False for _ in range(n)]

	for i in range(n):
		
		if (not dp[i] and s[:i+1] in dictionary):
			dp[i] = True
		
		if dp[i]:

			if i == n-1:
				return True
			
			for j in range(i, n):
				if (not dp[j] and s[i+1:j+1] in dictionary):
					dp[j] = True
				
				if dp[j] and j == n-1:
					return True
	return False
```


### 获取字符串中的异序词对

[Count of total anagram substrings - GeeksforGeeks](https://www.geeksforgeeks.org/count-total-anagram-substrings/)

异序词对指两个词之间字母种类和数量相同，但是排列顺序不同。

首先获取所有的子字符串，对每个子字符串排序后塞入字典中，对于出现次数大于1的子字符串，可能的异序词对为 $C_n^2$


### 统计没有连续1的二进制字符串个数

[Count number of binary strings without consecutive 1's - GeeksforGeeks](https://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/)

```python
def solve(n):
    def _solve(s, n, last):
        if n == 1:
            if last == "1":
                return 1
            else:
                return 2
        cnt = 0
        if last == "0":
            cnt += _solve(s, n-1, "0")
            cnt += _solve(s, n-1, "1")
        else:
            cnt += _solve(s, n-1, "0")
        
        return cnt
    s = ""
    cnt = _solve(s, n-1, "0") + _solve(s, n-1, "1")
    print(cnt)
```

带记忆矩阵的

```python
def solve_m(n):

    def _solve(memo, n, last):
        if n == 1:
            if last == "1":
                return 1
            else:
                return 2
        
        if memo[n][int(last)] != -1:
            return memo[n][int(last)]

        cnt = 0
        if last == "0":
            cnt += _solve(memo, n-1, "0")
            cnt += _solve(memo, n-1, "1")
            memo[n][int(last)] = cnt
        else:
            cnt += _solve(memo, n-1, "0")
            memo[n][int(last)] = cnt
        
        return cnt
    
    memo = [[-1, -1] for _ in range(n)]
    cnt = _solve(memo, n-1, "0") + _solve(memo, n-1, "1")
    print(cnt)
```

动态规划

```python
def solve_dp(n):

    dp = [[0, 0] for _ in range(n)]  # 第 i 位为0或1时的可能性

    # 如果字符串长度为 1，那么只有 dp[0][0] + dp[0][1] = 2 种可能性
    dp[0][0] = 1
    dp[0][1] = 1

    for i in range(1, n):
        dp[i][0] = dp[i-1][0] + dp[i-1][1]
        dp[i][1] = dp[i-1][0]

    cnt = dp[n-1][0] + dp[n-1][1]
    print(cnt)
```


### 判断字符串是否能被拆分四个不同的子字符串

[Check if given string can be split into four distinct strings - GeeksforGeeks](https://www.geeksforgeeks.org/check-given-string-can-split-four-distinct-strings/)

对于长度大于等于10的字符串来说，必定可以拆分为长度为1、2、3、4的子字符串，所以只需要考虑长度小于10的字符串

```python
def solve(s):
    if len(s) >= 10:
        return True
    
    n = len(s)
    for i in range(0, n-3):
        for j in range(i+1, n-2):
            for k in range(j+1, n-1):
                s1 = s[:i+1]
                s2 = s[i+1:j+1]
                s3 = s[j+1:k+1]
                s4 = s[k+1:]

                if s1 != s2 and s1 != s3 and s1 != s4 \
                and s2 != s3 and s2 != s4 and s3 != s4:
                    return True
    return False
```


### 最长平衡子序列

[Length of Longest Balanced Subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/length-longest-balanced-subsequence/)


### 平衡子序列的最小相邻交换次数

[Min Adjacent Swaps for Bracket Balancing - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-bracket-balancing/)

注意这里计算的相邻交换，所以像 `]][[` 这种需要三次相邻交换。

```python
def minimumNumberOfSwaps(s):
	cnt = 0
	n = len(s)
	c1 = 0
	c2 = 0
	for i in range(n):
		if s[i] == "[":
			c1 += 1
		else:
			c2 += 1
			cnt += max(0, c2 - c1)
	return cnt
```


### 给定序列的最小数

[Form minimum number from given sequence - GeeksforGeeks](https://www.geeksforgeeks.org/form-minimum-number-from-given-sequence/)


### 增加最长公共子序列的方式

[Count ways to increase LCS length of two strings by one - GeeksforGeeks](https://www.geeksforgeeks.org/count-ways-increase-lcs-length-two-strings-one/)

有两个序列，现在向第一个序列中添加一个元素，使得两个序列的最长公共子序列增加1，请问有多少种方式

使用动态规划的方法，在第一个字符串中添加一个元素，为了使最长公共子序列加1，那就要这个元素匹配到第二个序列的某个元素，即删除掉第二个序列的这个元素后，仍然能够保证最长公共子序列长度不变。

```python
def solve(s1, s2):

    n1 = len(s1)
    n2 = len(s2)
    positions = {}
    for i in range(n2):
        if s2[i] in positions:
            positions[s2[i]].append(i+1)
        else:
            positions[s2[i]] = [i+1]
    
    lcs = [[0 for _ in range(n2+2)] for _ in range(n1+2)]
    # lcs[i][j]: s1[0...i] 和 s2[0...j] 的最长公共长度
    for i in range(1, n1+1):
        for j in range(1, n2+1):
            if s1[i-1] == s2[j-1]:
                lcs[i][j] = 1 + lcs[i-1][j-1]
            else:
                lcs[i][j] = max(lcs[i][j-1], lcs[i-1][j])
    
    lcsr = [[0 for _ in range(n2+2)] for _ in range(n1+2)]

    # lcsr[i][j]: s1[i...n1] 和 s2[j...n2] 的最长公共子序列长度
    for i in range(n1, 0, -1):
        for j in range(n2, 0, -1):
            if s1[i-1] == s2[j-1]:
                lcsr[i][j] = 1 + lcsr[i+1][j+1]
            else:
                lcsr[i][j] = max(lcsr[i+1][j], lcsr[i][j+1])
    
    ways = 0

    for i in range(n1+1):
        for c in range(26):
            if chr(c+97) in positions:
                for j in range(len(positions[chr(c+97)])):
                    p = positions[chr(c+97)][j]

                    if lcs[i][p-1] + lcsr[i+1][p+1] == lcs[n1][n2]:
                        ways += 1
    return ways
```



### 判断字符串数组能否被串联起来

[Find if an array of strings can be chained to form a circle | Set 2 - GeeksforGeeks](https://www.geeksforgeeks.org/find-array-strings-can-chained-form-circle-set-2/)


### 外星人字典

[Alien Dictionary - GeeksforGeeks](https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/)

根据排序顺序，找到字符顺序


### 最小词表分解次数

[Minimum Word Break - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-word-break/)

自己的解法（不一定正确），参考判断一句话能否被给定词表分解问题的解法

```python
def solve(s, d):
    n = len(s)
    dp = [None] * n

    if s in d:
        return 0

    temp = ""
    for i in range(n):
        temp += s[i]
        if temp in d:
            dp[i] = 0

        if dp[i] is not None:
            if i == n-1:
                return dp[i] - 1
            tmp = ""
            for j in range(i+1, n):
                tmp += s[j]
                if tmp in d:
                    dp[j] = dp[i] + 1
                
    return dp[n-1] - 1
```

官方解法

```python
def min_word_break(s, dict):
    n = len(s)
    dp = [float('inf')] * (n + 1)  # Initialize a list to store minimum word breaks needed
    dp[0] = 0  # No breaks needed for an empty string

    for i in range(1, n + 1):
        for word in dict:
            length = len(word)
            if i >= length and s[i - length:i] == word:
                # Check if the substring from i-length to i matches a word in the dictionary
                dp[i] = min(dp[i], dp[i - length] + 1)
                # Update the minimum word breaks needed at position i

    return dp[n] - 1  # Return the minimum word breaks needed for the entire string
```



### 词搜索

在二维数据中搜索某个词：[Word Search in a 2D Grid of characters - GeeksforGeeks](https://www.geeksforgeeks.org/search-a-word-in-a-2d-grid-of-characters/)

[Word Search - Check if a word exists in a grid or not - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-word-exists-in-a-grid-or-not/)

```python
def solve(mat, word):
    def _solve(mat, word, x, y, idx):

        if idx == len(word):
            return True
        
        m = len(mat)
        n = len(mat[0])

        if x < 0 or y < 0 or x >= m or y >= n:
            return False
        
        if mat[x][y] == word[idx]:

            temp = mat[x][y]
            mat[x][y] = "#"   # 标记此处已经搜索过了

            result = _solve(mat, word, x + 1, y, idx+1) or \
            _solve(mat, word, x-1, y, idx+1) or _solve(mat, word, x, y+1, idx+1) \
            or _solve(mat, word, x, y- 1, idx+1)

            mat[x][y] = temp

            return result
        return False

    m = len(mat)
    n = len(mat[0])

    if len(word) > m * n:
        return False
    
    for i in range(m):
        for j in range(n):
            if mat[i][j] == word[0]:
                if _solve(mat, word, i, j, 0):
                    return True
    return False
```


### 使得括号是否平衡的最小转变次数

[Minimum number of bracket reversals needed to make an expression balanced - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-number-of-bracket-reversals-needed-to-make-an-expression-balanced/)
首先需要保证括号数量为偶数。

一种递归的方法是，对于字符串中的每个 `{` 都进行翻转，如果是 `{` 就转成 `}`，反之转成 `{`，再判断翻转后的字符串是否平衡。

```python
def recur(expr, n, ind, change, ans):
    # When we've covered the whole string, check if it's balanced
    if ind == n:
        if isBalanced(expr):
            ans[0] = min(ans[0], change)   # ans 是一个列表，方便保存结果
        return

    # Keep the bracket as it is
    recur(expr, n, ind + 1, change, ans)

    # Reverse the bracket
    if expr[ind] == '{':
        expr = expr[:ind] + '}' + expr[ind + 1:]
    else:
        expr = expr[:ind] + '{' + expr[ind + 1:]
    recur(expr, n, ind + 1, change + 1, ans)
```


另一种方法是删除字符串中所有的已经平衡的括号，然后剩下的只能是类似 `}}}{{{` 这种形式，假设有 `m` 个 `{` 和 `n` 个 `}`，则最小转变次数为 `ceil(m/2)+ceil(n/2)`（分别将 `{` 和 `}` 中的一半转变）

```python
def countMinReversals(expr):

    lenn = len(expr)

    # length of expression must be even
    # to make it balanced by using reversals.
    if (lenn % 2):
        return -1

    # After this loop, stack contains
    # unbalanced part of expression,
    # i.e., expression of the form "...."
    s = []
    for i in range(lenn):
        if (expr[i] == '}' and len(s)):

            if (s[0] == '{'):
                s.pop(0)
            else:
                s.insert(0, expr[i])
        else:
            s.insert(0, expr[i])

    # Length of the reduced expression
    # red_len = (m+n)
    red_len = len(s)

    # count opening brackets at the
    # end of stack
    n = 0
    while (len(s)and s[0] == '{'):
        s.pop(0)
        n += 1

    # return ceil(m/2) + ceil(n/2) which
    # is actually equal to (m+n)/2 + n%2
    # when m+n is even.
    return (red_len // 2 + n % 2)
```


### 词换行问题

[Word Wrap Problem - GeeksforGeeks](https://www.geeksforgeeks.org/word-wrap-problem-dp-19/)


自己的解法（会超时），每次递归时传入 idx （目前索引的arr元素），row 为当前行的长度

```python
def solve_m(arr, k):

    def _solve(arr, idx, row, k, memo):
        if idx == len(arr):
            return 0
        
        if memo[idx][row] != -1:
            return memo[idx][row]

        cost = 0
        if row != 0:
            nr = arr[idx] + 1 + row
        else:
            nr = arr[idx]
        
        if nr <= k:
	        # 换到下一行更好还是在本行更好
            cost = min( (k - row) ** 2 + _solve(arr, idx+1, arr[idx], k, memo),  _solve(arr, idx+1, nr, k, memo))
        else:
	        # 换到下一行
            cost = (k - row) ** 2 + _solve(arr, idx+1, arr[idx], k, memo)
        memo[idx][row] = cost
        return cost
    
    memo = [[-1 for _ in range(k+1)] for _ in range(len(arr))]
    cost = _solve(arr, 0, 0, k, memo)
    return cost
```


官方解法（回溯法，未添加memo），添加memo后，这种回溯方法对于memo的利用会更高，将row放到循环里面了。

```python
import sys
 
def calculateCost(curr, n, arr, k):
    # Base case: If current index is beyond or at the last word, no cost
    if curr >= n:
        return 0

    # Keeps track of the current line's total character count
    sum = 0

    # Initialize with a large value to find the minimum cost
    ans = sys.maxsize

    # Try placing words from the current position to the next
    for i in range(curr, n):
      
        # Add the length of the current word
        sum += arr[i]

        # Including spaces between words
        tot = sum + (i - curr)

        # If the total exceeds the line width, break out of the loop
        if tot > k:
            break

        # If this is not the last word in the array, compute the 
        # cost for the next line
        if i != n - 1:
            temp = (k - tot) * (k - tot) + calculateCost(i + 1, n, arr, k)
            ans = min(ans, temp)
            
        # If it's the last word, there's no cost added
        else:
            ans = 0
    return ans

def solveWordWrap(arr, k):
    n = len(arr)
    return calculateCost(0, n, arr, k)
```


动态规划

```python
def solve_dp(arr, k):
    n = len(arr)
    dp = [float("inf") for _ in range(n+1)]

    for curr in range(n-1, -1, -1):
        s = 0
        for i in range(curr, n):
            s += arr[i]
            tot = s + i - curr

            if tot > k:
                break

            if i != n-1:
                dp[curr] = min(dp[curr], dp[i+1] + (k - tot) * (k - tot))
            else:
                dp[curr] = min(dp[curr], 0)
    return dp[0]

```





## 回溯（递归）


将大问题拆分为小问题


### 十进制转二进制

```python
def decimal2Binary(num):
    res = ""
    if num < 2:
        return str(num)
    res += decimal2Binary(num // 2) + str(num % 2)
    return res
```



### 反转队列

[Reversing a queue using recursion - GeeksforGeeks](https://www.geeksforgeeks.org/reversing-queue-using-recursion/)

先取出最前面的元素，再反转剩下的队列，反转好之后，将最前面的元素加到最后。


```python
def reverse_queue(queue: Queue):
    # Base case
    if queue.empty():
        return
 
    # Dequeue current item (from front)
    item = queue.queue[0]
    queue.get()
 
    # Reverse remaining queue
    reverse_queue(queue)
 
    # Enqueue current item (to rear)
    queue.put(item)
```



### 硬币之和问题

[Coin Change - Count Ways to Make Sum - GeeksforGeeks](https://www.geeksforgeeks.org/coin-change-dp-7/)

对于每个硬币，考虑使用和不使用该硬币时的情况，如果不这么做，容易出现重复的情况

```python
def countRecur(coins, n, sum):
  
    # If sum is 0 then there is 1 solution
    # (do not include any coin)
    if sum == 0:
        return 1

    # 这里考虑分不出的情况
    if sum < 0 or n == 0:
        return 0

    # count is sum of solutions (i)
    # including coins[n-1] (ii) excluding coins[n-1]
    return countRecur(coins, n, sum - coins[n - 1]) + \
              countRecur(coins, n - 1, sum)

def count(coins, sum):
    return countRecur(coins, len(coins), sum)
```

一般情况下可以使用一个矩阵保存已经计算过的结果

```python
def countRecur_m(coins, n, sum, memo):
    if sum == 0:
        return 1
    
    if sum < 0 or n == 0:
        return 0
    
    if memo[n][sum] != -1:
        return memo[n][sum]

    memo[n][sum] = countRecur_m(coins, n, sum - coins[n - 1], memo) + countRecur_m(coins, n - 1, sum, memo)
    return memo[n][sum]

def count_m(coins, sum):
    memo = [[-1 for _ in range(sum + 1)] for _ in range(len(coins)+1)]
    return countRecur_m(coins, len(coins), sum, memo)
```

>memo的初始化方式似乎需要注意一下，只能采用这种方法，不能采用 `[[-1] * a] * b` 这种形式，因为这样创建的第二个维度似乎会共享一片内存。



### 求最长回文子字符串的长度

[Length of longest palindrom>ic sub-string : Recursion - GeeksforGeeks](https://www.geeksforgeeks.org/length-of-longest-palindromic-sub-string-recursion/)

递归中止情况是左右相等或左大于右，如果左右相等，那么将count+2，如果不相等的话，count变为0，分别计算一下左边加1和右边减1的情况。

```python
def longestPalindromic(strn, l, r, count):

    if l > r:
        return count
    
    if l == r:
        return count + 1
    
    if strn[l] == strn[r]:
        count = longestPalindromic(strn, l + 1, r - 1, count + 2)

        return max(max(count, longestPalindromic(strn, l + 1, r, 0)), longestPalindromic(strn, l, r - 1, 0))
    
    return max(longestPalindromic(strn, l + 1, r, 0), longestPalindromic(strn, l, r - 1, 0))
```

>用count传入信息时，似乎不能简单的使用memo来简化操作

### 二叉树的底部视图


[Bottom View of a Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/bottom-view-binary-tree/)


### 生成数组的全部子集

[Print all subsets of a given Set or Array - GeeksforGeeks](https://www.geeksforgeeks.org/backtracking-to-find-all-subsets/)

解法1：从后向前，每次去除数组中的一个元素

```python
def get_all_subsets(arr, n, subs: list):
    
    if n == 0:
        subs.append(arr)
        return
    get_all_subsets(arr[:n-1] + arr[n:], n-1, subs)
    get_all_subsets(arr, n-1, subs)
```

解法2：从前到后，每次向结果中添加一个元素

```python
def get_all_subsets2(arr, l, idx, subs):
    if idx == len(arr):
        subs.append(l[:])   # 注意需要使用切片
        return

    l.append(arr[idx])
    get_all_subsets2(arr, l, idx+1, subs)

    l.pop()
    get_all_subsets2(arr, l, idx + 1, subs)
```

解法3：使用比特位来控制

假设数组中有n个元素，那么子集合共有 $2^n$ 个，可以使用比特来表示，如共有3个元素，则可以用 0- 7这8个数字表示，0 表示三个位置都为0，即空集，7 三个位置都是1，即全集。

```python
for i in range(1 << len(arr)):
	# Creating a list to store the current subset.
	cur = []

	# Iterating over each element of the array.
	for j in range(len(arr)):
		# Checking if the jth bit of i is set.
		if i & (1 << j):
			# If yes, then include that element in the subset.
			cur.append(arr[j])

	# Adding the current subset to the result list.
	ans.append(cur)

# Sorting the subsets in lexicographical order.
ans.sort()
```

### 拆分数组

将数组拆分为连续的子数组，即 `[1,2,3,4]` 拆分为 `[1,2]` 和 `[3,4]`

普通的拆分，每个子数组不为空

```python
def solve_p2(arr):
    n = len(arr)
    def _solve(arr, res, idx):
        if idx >= n:
            print(res)
            return
        temp = []
        for i in range(idx, n):
            temp.append(arr[i])
            res.append(temp[:])   # 注意需要存入切片
            _solve(arr, res, i+1)
            res.pop()
            
    _solve(arr, [], 0)
```

拆分为固定的 k 个子数组，每个子数组不为空

```python
def solve_p(arr, k):
    
    n = len(arr)
    def _solve(arr, nk, res, idx):

        if idx >= n:
            return
        
        if nk == k - 1:
            print(res+[arr[idx:]])
            return 
        temp = []
        for i in range(idx, n):
            temp.append(arr[i])
            res.append(temp[:])
            _solve(arr, nk+1, res, i+1)
            res.pop()
            
    _solve(arr, 0, [], 0)
```


### 矩阵最短路径

[Print all possible paths from top left to bottom right in matrix - GeeksforGeeks](https://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/)

求出所有从矩阵的左上方到右下方的最短路径

每次添加一个路径节点，然后选择向下还是向右

```python
def findAllPossiblePaths(n : int, m : int, grid):
	def get_all_possible_paths(grid, n, m, i,j, path, sols):
		if i == n-1 and j == m-1:
			sols.append(path[:]+[grid[-1][-1]])
			return
		
		path.append(grid[i][j])
		
		if i < n-1:
			get_all_possible_paths(grid, n, m, i+1,j, path, sols)
		
		if j < m - 1:
			get_all_possible_paths(grid, n, m, i,j+1, path, sols)
		
		path.pop()
		
	path = []
	sols = []
	get_all_possible_paths(grid, n, m, 0, 0, path, sols)
	return sols
```

### 生成平衡括号

[Print all combinations of balanced parentheses - GeeksforGeeks](https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/)

注意左括号的数量不超过一半，右括号数不大于左括号

```python
def gen_parenthesis_util(n, open, close, s, ans):
	# 如果左右括号都有 n 个
    if open == n and close == n:
        ans.append(s)
        return

    # 如果左括号的数量小于 n
    if open < n:
        gen_parenthesis_util(n, open + 1, close, s + "{", ans)

    # 只有当close < open时才会放，如果close已经大于等于open，再放右括号就会不平衡
    if close < open:
        gen_parenthesis_util(n, open, close + 1, s + "}", ans)

def AllParenthesis(n):
  
    # List for storing the answer
    ans = []
    if n > 0:
        gen_parenthesis_util(n, 0, 0, "", ans)
    return ans
```


### 最长公共子序列

[Longest Common Subsequence (LCS) - GeeksforGeeks](https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/)

这里的子序列允许不连续的情况出现

从末尾开始匹配，i 和 j 分别代表当前长度

```python
def lcs(s1, s2):
    def _lcs(s1, s2, i, j):
        if i == 0 or j == 0:
            return 0
        
        if s1[i-1] == s2[j-1]:
            return 1 + _lcs(s1, s2, i-1, j-1)
    
        return max(_lcs(s1, s2, i-1, j), _lcs(s1, s2, i, j-1))     
    cnt = _lcs(s1, s2, len(s1), len(s2))
    return cnt
```


使用一个矩阵保存计算过的状态

```python
def lcs_m(s1, s2):
    def _lcs(s1, s2, i, j, memo):
        if i == 0 or j == 0:
            return 0
        
        if memo[i][j] != -1:
            return memo[i][j]
        
        if s1[i-1] == s2[j-1]:
            memo[i][j] = 1 + _lcs(s1, s2, i-1, j-1, memo)
            return memo[i][j]
        memo[i][j] = max(_lcs(s1, s2, i-1, j, memo), _lcs(s1, s2, i, j-1, memo))  
        return memo[i][j]
    
    memo = [[-1 for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]
    
    cnt = _lcs(s1, s2, len(s1), len(s2), memo)

    return cnt
```


### 栈的递归排序

[How to Sort a Stack using Recursion - GeeksforGeeks](https://www.geeksforgeeks.org/sort-a-stack-using-recursion/)

```python
def sort_stack(stack: list):
    if len(stack) == 0:
        return
    
    top = stack.pop()

    sort_stack(stack)

    temp = []

    while len(stack) > 0 and stack[-1] > top:
        temp.append(stack.pop())
    
    stack.append(top)

    while len(temp) > 0:
        stack.append(temp.pop())
```


### 翻转双向链表

[Reverse a Doubly linked list using recursion - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-doubly-linked-list-using-recursion/)


### N-皇后问题

[N Queen Problem - GeeksforGeeks](https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/)

[N Queen Problem using Branch And Bound - GeeksforGeeks](https://www.geeksforgeeks.org/n-queen-problem-using-branch-and-bound/)

可以考虑使用三个布尔数组来表示某一行、对角线和反对角线是否已经被占用了。具体做法是为每一行，每个对角线和反对角线都设置相同的数。

反对角线

![](https://media.geeksforgeeks.org/wp-content/uploads/king.jpg)

对角线
![](https://media.geeksforgeeks.org/wp-content/uploads/kingqueen.jpg)


```python
def solve(N):
    board = [[0 for i in range(N)] for i in range(N)]

    slashCode = [[0 for i in range(N)] for i in range(N)]
    backslashCode = [[0 for i in range(N)] for i in range(N)]

    # 初始化对角线和反对角线
    for i in range(N):
        for j in range(N):
            slashCode[i][j] = i + j
            backslashCode[i][j] = i - j + N - 1
    # True 表示该位置可以放
    slashLookUp = [True] * (2 * N - 1)
    backslashLookUp = [True] * (2 * N - 1)
    rowLookUp = [True] * N

    def isSafe(r, c):
        return slashLookUp[slashCode[r][c]] \
            and backslashLookUp[backslashCode[r][c]] \
                and rowLookUp[r]

    def _solve(board, c):
        if c == N:
            print(board)
            return True
        
        for r in range(N):
            if isSafe(r, c):
                # 该位置已经放置
                slashLookUp[slashCode[r][c]] = False
                backslashLookUp[backslashCode[r][c]] = False
                rowLookUp[r] = False
                board[r][c] = 1
                # 如果需要打印所有的解法，这里可以不返回True
                if  _solve(board, c+1):
                    return True
	            
                # 该位置不可行，删除
                slashLookUp[slashCode[r][c]] = True
                backslashLookUp[backslashCode[r][c]] = True
                rowLookUp[r] = True
                board[r][c] = 0
        return False
    _solve(board, 0)
```


### 数独问题

[Algorithm to Solve Sudoku | Sudoku Solver - GeeksforGeeks](https://www.geeksforgeeks.org/sudoku-backtracking-7/)


### 国王旅行问题

[The Knight's tour problem - GeeksforGeeks](https://www.geeksforgeeks.org/the-knights-tour-problem/)


## 矩阵


### 矩阵计算斐波那契数列

对于广义斐波那契数列 $g(n)=a*g(n-1)+b*g(n-2)+c$ ，使用迭代方法时间复杂度为 $O(n)$，使用矩阵计算可以将时间复杂度降为 $O(log_2n)$

矩阵计算可以表示成

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = \left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]\left[ \matrix{
  g(n - 1) \hfill \cr 
  g(n - 2) \hfill \cr 
  c \hfill \cr}  \right]
$$
这样$g(n)$ 可以这样计算

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = {\left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]^{n - 2}}\left[ \matrix{
  g(2) \hfill \cr 
  g(1) \hfill \cr 
  c \hfill \cr}  \right]
$$

等式右侧的幂次矩阵可以一次算两个，甚至可以先算好两次方，直接用也行

具体实现如下

```python
mat = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix
res = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix

def mul(self, res, mat, m):
	res1 = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix
	for i in range(3):
		for j in range(3):
			for k in range(3):
				res1[i][j] += (res[i][k]*mat[k][j]) # Multiplying matrices element-wise and summing
				res1[i][j] %= m # Taking modulo m to avoid overflow
	
	for i in range(3):
		for j in range(3):
			res[i][j] = res1[i][j] # Updating the resultant matrix

def mat_exp(self, n, m):
	while n>0:
		if n&1:  
			self.mul(self.res, self.mat, m) # Multiplying the result matrix with the current matrix
		self.mul(self.mat,self.mat,m) # Squaring the current matrix
		n //= 2 # Halving the power of the matrix
```



### 验证井字棋

[Validity of a given Tic-Tac-Toe board configuration - GeeksforGeeks](https://www.geeksforgeeks.org/validity-of-a-given-tic-tac-toe-board-configuration/)

先列举所有的获胜情况，然后对 `X` 和 `O` 分别验证获胜情况


### 名人问题

[The Celebrity Problem - GeeksforGeeks](https://www.geeksforgeeks.org/the-celebrity-problem/)

假设有n个人，他们之间是否相互认识通过一个矩阵给定，找出其中所有人都认识的人，但这个人不认识其他人。

该问题可以转变为找到一列全为1，但对应行只有对角线元素为1，使用双指针解决这一问题

左指针 `l` 指向 0，右指针 `r` 指向 n-1

```python
def solve(mat, ):
    n = len(mat)
    l, r = 0, n-1

    while l < r:

        # 如果 l 不知道 r，那么r不是名人
        if mat[l][r] == 0:
            r -= 1
        # 如果 r 不知道 l，那么l不是名人
        if mat[r][l] == 0:
            l += 1
        
        # r 和 l 之间知道或者不知道，l 和 r 都不是名人
        if mat[r][l] == mat[l][r] and l != r:
            r -= 1
            l += 1
    if l > r:
        return -1
    else:
        for i in range(n):
            if mat[l][i] == 1 and i != l:
                return -1
            if mat[i][l] == 0 and i != l:
                return -1
    return l
```


### 矩阵旋转

[Rotate Matrix Clockwise by 1 - GeeksforGeeks](https://www.geeksforgeeks.org/rotate-matrix-elements/)

```python
def solve(mat):
    n = len(mat)
    m = len(mat[0])
    if n == 1:
        return
    
    left = 0
    right = m - 1
    top = 0
    down = n - 1

    while left < right and top < down:
        # 旋转最左侧
        tl = mat[top][left]
        for i in range(top, down):
            mat[i][left] = mat[i+1][left]

        mat[down][left] = mat[down][left+1]

        # 旋转最上方
        tr = mat[top][right]
        for i in range(right, left+1, -1):  # 1, n-1
            mat[top][i] = mat[top][i-1]
        
        mat[top][left+1] = tl

        # 旋转最右边
        dr = mat[down][right]

        for i in range(down, top+1, -1):
            mat[i][right] = mat[i-1][right]
        mat[top+1][right] = tr

        # 旋转最下边
        for i in range(left, right-1):
            mat[down][i] = mat[down][i+1]
        mat[down][right-1] = dr

        left += 1
        right -= 1
        top += 1
        down -= 1
```


### 被 X 包围的最大边界

[Largest Cross Bordered Square - GeeksforGeeks](https://www.geeksforgeeks.org/given-matrix-o-x-find-largest-subsquare-surrounded-x/)

最一般的方法是对矩阵的每个元素，从大小为1开始，判断边界是否全为 `X`

另一种方法，先创建一个right和down矩阵，`right[i][j]` 表示从 `(i,j)` 这个点到右侧有多少个连续的 `X`，`down[i][j]` 表示从 `(i,j)` 这个点到下侧有多少个连续的 `X`

因此对于左上角的 `[i,j]` 而言，其边界均为`X`的最大长度为 `right[i][j]` 和 `down[i][j]` 中的最小值。同时对长度进行遍历，判断左下和右上是不是也满足至少有若干个连续的 `X`

```python
def solve(mat):
    n = len(mat)

    right = [[0 for _ in range(n)] for _ in range(n)]
    down = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n-1, -1, -1):
        for j in range(n-1, -1, -1):
            if mat[i][j] == "X":
                right[i][j] = 1 if j+1 == n else right[i][j+1]+1
                down[i][j] = 1 if i+1 == n else down[i+1][j] + 1
    maxSize = 0
    for i in range(n):
        for j in range(n):
            maxSide = min(right[i][j], down[i][j])

            for side in range(maxSide, 0, -1):
                if down[i][j+side-1] >= side \
                      and right[i+side-1][j] >= side:
                    maxSize = max(maxSize, side)
                    break
    return maxSize
```


### 最大全 1 方阵

[Maximum size square sub-matrix with all 1s - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/)

回溯法，如果一个点为0，那么返回0，如果为1，看其右、下和右下方的全1方阵大小。

```python
def solve(mat):
    def _solve(mat, i, j, ans):
        if i >= len(mat) or j >= len(mat[0]):
            return 0
        right = _solve(mat, i, j + 1, ans)
        down = _solve(mat, i + 1, j, ans)
        rd = _solve(mat, i + 1, j + 1, ans)

        if mat[i][j] == 0:
            return 0
        nv = 1 + min(min(right, down), rd)
        ans[0] = max(nv, ans[0])
        return nv

    ans = [0]
    _solve(mat, 0, 0, ans)
    print(ans)
```

动态规划

```python
def solve_dp(mat):
    n = len(mat)
    m = len(mat[0])

    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
    ans = 0
    for i in range(n-1, -1, -1):
        for j in range(m-1, -1, -1):
            if mat[i][j] == 1:
                dp[i][j] = 1 + min(min(dp[i+1][j], dp[i][j+1]), dp[i+1][j+1])
            else:
                dp[i][j] = 0
            ans = max(ans, dp[i][j])
    print(ans)
```


### 矩阵相等的最小转换次数

只允许每次在矩阵的某行某列加1，问这样的操作能否使得两个矩阵相等，如果可以求出最小转换次数

如何判断两个矩阵能否通过加1相等，只需要判断 `a[0][j]+a[i][0]==a[i][j]+a[0][0]`是否成立即可

```python
def countOperations(a, b):
    n = len(a)
    m = len(a[0])

    # Create difference matrix (a = a - b)
    for i in range(n):
        for j in range(m):
            a[i][j] -= b[i][j]

    # Check if transformation is possible using the property
    # a[i][j] - a[i][0] - a[0][j] + a[0][0] should be 0
    for i in range(1, n):
        for j in range(1, m):
            if a[i][j] - a[i][0] - a[0][j] + a[0][0] != 0:
                return -1

    result = 0

    # Add operations needed for first column
    for i in range(n):
        result += abs(a[i][0])

    # Add operations needed for
    # first row (excluding a[0][0])
    for j in range(m):
        result += abs(a[0][j] - a[0][0])

    return result
```


### 计算行排序矩阵的中位数

[Find median in row wise sorted matrix - GeeksforGeeks](https://www.geeksforgeeks.org/find-median-row-wise-sorted-matrix/)

如果矩阵的行和列都是奇数，即肯定能在矩阵中找到一个点为中位数，可以使用二分搜索的方法进行搜索

```python
# python3 program to find median of a matrix
# using binary search
from bisect import bisect_right

def median(mat):
    r = len(mat)
    c = len(mat[0])

    minVal = float('inf')
    maxVal = float('-inf')

    # Finding the minimum and maximum elements in the matrix
    for i in range(r):
        minVal = min(minVal, mat[i][0])
        maxVal = max(maxVal, mat[i][c - 1])

    desired = (r * c + 1) // 2
    lo = minVal
    hi = maxVal

    # Binary search to find the median
    while lo < hi:
        mid = lo + (hi - lo) // 2
        place = 0

        # Count elements smaller than or equal to mid using bisect_right
        for i in range(r):
            place += bisect_right(mat[i], mid)

        if place < desired:
            lo = mid + 1
        else:
            hi = mid    # 此处为mid而不是mid-1

    return lo
```


### 矩阵连乘问题

[Matrix Chain Multiplication - GeeksforGeeks](https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/)

回溯法

将矩阵连乘分解到两两相乘的地步

```python
def solve(chains):

    def _solve(chains, i, j):

        # 已经分解成单个矩阵了        
        if i + 1 == j:
            return 0
        
        ans = float("inf")

        # 在 i，j 之间寻找一个点分成两个矩阵
        for k in range(i+1, j):
            res = _solve(chains, i, k) + _solve(chains, k, j) + chains[i] * chains[k] * chains[j]
            ans = min(ans, res)
        return ans

    if len(chains) == 2:
        return 0
    res = _solve(chains, 0, len(chains) - 1)
    return res
```

对应的动态规划

```python
def solve_dp(arr):

    n = len(arr)
    if n == 2:
        return 0
    
    dp = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n-1, -1, -1):
        for j in range(i+2, n, 1):
            ans = float("inf")
            for k in range(i+1, j):
                res = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]
                ans = min(ans, res)
            dp[i][j] = ans
    
    return dp[0][n-1]
```



### 最大全1矩阵

[Maximum size rectangle binary sub-matrix with all 1s - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/)

第一种解法：参考数组问题中的计算直方图的最大面积问题。从上到下，对每一行，统计每一列的连续1个数，如果该列为0，就是0，将其作为一个直方图，计算最大面积

```python
def getMaxArea(arr):
    n = len(arr)
    s = []
    res = 0

    for i in range(n):
        while s and arr[s[-1]] >= arr[i]:

            # The popped item is to be considered as the 
            # smallest element of the histogram
            tp = s.pop()

            # For the popped item previous smaller element is 
            # just below it in the stack (or current stack top)
            # and next smaller element is i
            width = i if not s else i - s[-1] - 1

            res = max(res, arr[tp] * width)
        s.append(i)

    # For the remaining items in the stack, next smaller does
    # not exist. Previous smaller is the item just below in
    # stack.
    while s:
        tp = s.pop()
        curr = arr[tp] * (n if not s else n - s[-1] - 1)
        res = max(res, curr)

    return res

# Function to find the maximum area of rectangle
# in a 2D matrix.
def maxArea(mat):
    n = len(mat)
    m = len(mat[0])

    # Array to store matrix 
    # as a histogram.
    arr = [0] * m

    ans = 0

    # Traverse row by row.
    for i in range(n):
        for j in range(m):
            if mat[i][j] == 1:
                arr[j] += 1
            else:
                arr[j] = 0

        ans = max(ans, getMaxArea(arr))

    return ans
```


动态规划：统计每个点`(i,j)`1的宽度，然后从下向上遍历每一行，找到最小宽度，乘上高度

```python
def maxArea(mat):
    n, m = len(mat), len(mat[0])

    # 2D matrix to store the width of 1's 
    # ending at each cell.
    memo = [[0] * m for _ in range(n)]
    ans = 0

    for i in range(n):
        for j in range(m):
            if mat[i][j] == 0:
                continue

            # Set width of 1's at (i, j).
            if j == 0:
                memo[i][j] = 1
            else:
                memo[i][j] = 1 + memo[i][j - 1]

            width = memo[i][j]

            # Traverse row by row, update the 
            # minimum width and calculate area.
            for k in range(i, -1, -1):
                width = min(width, memo[k][j])
                area = width * (i - k + 1)

                ans = max(ans, area)

    return ans
```


### 二叉树构造祖先矩阵

[Construct Ancestor Matrix from a Given Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/construct-ancestor-matrix-from-a-given-binary-tree/)

给定二叉树，构造一个祖先矩阵，即若 i 是 j 的祖先，则有 `arr[i][j]=1`

```python
def solve(node: Node, n):

    def _solve(node: Node, anc, mat):
        if node is None:
            return
        
        x = node.data

        for i in range(len(anc)):
            mat[anc[i]][x] = 1

        anc.append(x)

        _solve(node.left, anc, mat)
        _solve(node.right, anc, mat)

        anc.pop()
    
    anc = []
    mat = [[0 for _ in range(n)] for _ in range(n)]

    _solve(node, anc, mat)
    print(mat)
```


### 找到最多的+型矩阵

[Find size of the largest '+' formed by all ones in a binary matrix - GeeksforGeeks](https://www.geeksforgeeks.org/find-size-of-the-largest-formed-by-all-ones-in-a-binary-matrix/)

构造四个矩阵，分别计算上下左右的连续1个数

主要看如何一次性构造四个矩阵


### 走二进制迷宫

在一个二进制矩阵中，1 表示可以走，0表示不可以走，给定起点和终点，求出一条最短矩阵

回溯法：注意使用一个矩阵保存已经访问过的节点，避免重复访问

```python
def solve(mat, x, y):

    def isSafe(mat, i, j, visited, m, n):
        if i >=0 and j >=0 and i < m and j < n \
        and mat[i][j] == 1 and not visited[i][j]:
            return True
        return False

    def _solve(mat, i, j, x, y, visited, m, n):
        
        if i == x and j == y:
            return 0
        
        res = m * n
        visited[i][j] = True
        if isSafe(mat, i - 1, j, visited, m, n):
            res = min(res, 1 + _solve(mat, i-1, j, x, y, visited, m, n))

        if isSafe(mat, i + 1, j, visited, m, n):
            res = min(res, 1 + _solve(mat, i+1, j, x, y, visited, m, n))

        if isSafe(mat, i, j - 1, visited, m, n):
            res = min(res, 1 + _solve(mat, i, j-1, x, y, visited, m, n))
        
        if isSafe(mat, i, j + 1, visited, m, n):
            res = min(res, 1 + _solve(mat, i, j+1, x, y, visited, m, n))
        
        visited[i][j] = False
        return res
    
    m = len(mat)
    n = len(mat[0])
    visited = [[False for _ in range(n)] for _ in range(m)]
    res = _solve(mat, 0, 0, x, y, visited, m, n)
    print(res)
```

这样的复杂度过高，可以采用bfs的方法进行遍历

```python
def solve_bfs(mat, x, y):
    class Node:
        def __init__(self, x, y, d):
            self.p = (x, y)
            self.d = d

    def isSafe(mat, i, j, visited, m, n):
        if i >=0 and j >=0 and i < m and j < n \
        and mat[i][j] == 1 and not visited[i][j]:
            return True
        return False
    
    def _solve(mat, i, j, x, y, m, n):
        if mat[i][j] != 1 or mat[x][y] != 1:
            return -1
        
        q = []
        s = Node(i, j, 0)
        q.append(s)
        
        visited[i][j] = True

        while len(q) != 0:
            curr = q.pop(0)
            if curr.p[0] == x and curr.p[1] == y:
                return curr.d

            for i in range(4):
                row = curr.p[0] + rowNum[i]
                col = curr.p[1] + colNum[i]

                if isSafe(mat, row, col, visited, m, n):
                    visited[row][col] = True
                    adj = Node(row, col, curr.d + 1)
                    q.append(adj)
        return -1
    m = len(mat)
    n = len(mat[0])
    visited = [[False for _ in range(n)] for _ in range(m)]
    rowNum = [-1, 0, 0, 1]
    colNum = [0, -1, 1, 0]

    res = _solve(mat, 0, 0, x, y, m, n)
    print(res)
```


### 矩阵的最大和矩形

[Maximum sum rectangle in a 2D matrix | DP-27 - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/)

只讨论时间复杂度最低的第三种算法，由于需要求的是矩形，所以可以先确定左右边界，然后对左右边界之间的元素按行求和得到一维数组，然后使用kadane算法求最大和

```python
def kadaneAlgorithm(temp):
    rows = len(temp)

    currSum = 0
    maxSum = float('-inf')

    # Traverse the array
    for i in range(rows):
        currSum += temp[i]

        # Update maxSum if the current sum is greater
        if maxSum < currSum:
            maxSum = currSum

        # If the current sum becomes negative, reset it to 0
        if currSum < 0:
            currSum = 0

    return maxSum


def maxSumRectangle(mat):
    rows = len(mat)
    cols = len(mat[0])

    maxSum = float('-inf')

    # Initialize a temporary array to store row-wise
    # sums between left and right boundaries
    temp = [0] * rows

    # Check for all possible left and right boundaries
    for left in range(cols):
        # Reset the temporary array for each new left
        # boundary
        temp = [0] * rows

        for right in range(left, cols):
            # Update the temporary array with the current
            # column's values
            for row in range(rows):
                temp[row] += mat[row][right]

            # Find the maximum sum of the subarray for the
            # current column boundaries
            sumValue = kadaneAlgorithm(temp)

            # Update the maximum sum found so far
            maxSum = max(maxSum, sumValue)

    return maxSum
```


## 栈


栈：先入先出


### 使用栈实现队列

[Queue using Stacks - GeeksforGeeks](https://www.geeksforgeeks.org/queue-using-stacks/)

使用两个栈，有两种算法可以选择

1、在入队列时，将stack1中的元素全部pop，并push到stack2，再将新元素push到stack1，再将stack2的元素全部push回stack1；在出队列时，直接pop即可

2、在入队列时，直接将元素push到stack1；出队列时，如果两个栈都为空报错，如果stack2为空，将stack1的所有元素塞入stack2，从stack2 pop出元素。

算法2比算法1好，因为算法2的出栈和入栈次数少。

### 队列实现栈

[Implement Stack using Queues - GeeksforGeeks](https://www.geeksforgeeks.org/implement-stack-using-queue/)

使用两个队列时，有两种算法可选

1、在入栈时，直接将元素入队列queue1；出栈时，将queue1中的元素（除了最后一个）全部送入queue2中，然后queue1的最后一个元素出队列，完成后，交换queue1和queue2的名字

2、在入栈时，将元素送入queue2的队列，将queue1中的所有元素送入queue2中，交换queue1和queue2；出栈时，直接从queue1出队列即可

如果只有一个队列，当第一个元素到来时，将元素送入队列，当第二个元素到来时，直接塞进去，但是再将第一个元素送入，将原本的第一个元素弹出


### 使用优先队列实现栈

[geeksforgeeks.org/implement-stack-using-priority-queue-or-heap/](https://www.geeksforgeeks.org/implement-stack-using-priority-queue-or-heap/)

入栈时，不仅让元素入队列，还加上元素的序号，如第一个元素 a 以 `(0, a)` 的方式入队列，由于python中没有最大堆，所以可以在序号前加上负号，来让最后一个元素优先出队列。


### 表达式互转

[Convert Infix expression to Postfix expression - GeeksforGeeks](https://www.geeksforgeeks.org/convert-infix-expression-to-postfix-expression/)

遇到操作符，比较操作符和目前栈顶的操作符的优先级顺序（`(`的运算级顺序设为最低），如果大于压入栈，小于等于就出栈，遇到操作数就放入结果中，遇到 `(` 直接入栈，遇到 `)` 出栈直到遇到 `(`

[Postfix to Infix - GeeksforGeeks](https://www.geeksforgeeks.org/postfix-to-infix/)

从左到右，遇到操作数直接入栈，遇到操作符，弹出两个元素合成一个子表达式（加上括号），再将子表达式压入栈中


[Prefix to Postfix Conversion - GeeksforGeeks](https://www.geeksforgeeks.org/prefix-postfix-conversion/)

[Postfix to Prefix Conversion - GeeksforGeeks](https://www.geeksforgeeks.org/postfix-prefix-conversion/)

### 翻转栈

[How to Reverse a Stack using Recursion - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-a-stack-using-recursion/)

使用递归进行处理，数据出栈，处理剩下的stack，最后将数据塞入栈的最下方

```python
def solve(stack):

    def _insert(stack, item):
        if len(stack) == 0:
            stack.append(item)
        else:
            temp = stack.pop()
            _insert(stack, item)
            stack.append(temp)

    def _solve(stack):
        if len(stack) == 0:
            return
        
        a = stack.pop()
        _solve(stack)
        _insert(stack, a)
    print(stack)
    _solve(stack)
    print(stack)
```


基于链表翻转栈
[Reverse a stack without using extra space in O(n) - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-stack-without-using-extra-space/)

使用单向链表实现一个栈

```python
class LinkedList:
    def __init__(self):
        self.head = None

    def push(self, data):
        if self.head is None:
            self.head = Node(data)
            return
        
        temp = Node(data)
        temp.next = self.head
        self.head = temp
    
    def pop(self):
        temp = self.head
        self.head = self.head.next
        return temp

    def reverse(self):
        if self.head is None:
            return
        prev = self.head
        curr = self.head.next
        prev.next = None

        while curr is not None:
            next = curr.next   # 保存下一个节点
            curr.next = prev   # 翻转当前节点
            prev = curr
            curr = next
        self.head = prev
```



### 可合并栈

[How to create mergeable stack? - GeeksforGeeks](https://www.geeksforgeeks.org/create-mergable-stack/)

如何创建一个可以合并的栈

使用双向链表实现，下面简单给出pop的代码

```python
def pop(self):
         
	if (self.head == None):
		print("Stack underflow")

	if (self.head == self.tail):
		self.head = None
		self.tail = None

	else:
		node = self.tail
		self.tail = self.tail.prev
		del node
		self.tail.next = None
```


### 前一个更小值和后一个更大值

[Nearest smaller numbers on left side in an array - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/)

[Next Greater Element (NGE) for every element in given Array - GeeksforGeeks](https://www.geeksforgeeks.org/next-greater-element/)

在求前一个更小值时，遍历数组，如果栈非空且栈顶元素大于等于当前元素，就弹出这个元素，反之这个元素的更小值就是栈顶元素。注意栈保存的是元素的索引和值

在求后一个更大值时，同样用一个栈保存元素索引和值，遍历数组，如果栈顶元素的值小于当前元素，就弹出栈顶元素，栈顶元素对应的后一个更大值便是当前元素


前一个更小值代码

```python
def solve(arr):
    n = len(arr)
    smaller = [-1] * n
    stack = []
    
    for i in range(n):

        while len(stack) != 0 and stack[-1][1] >= arr[i]:
            stack.pop()
        
        if len(stack)!=0 and stack[-1][1] < arr[i]:
            smaller[i] = stack[-1][1]
        
        stack.append((i+1, arr[i]))

    print(smaller)
```


下一个更大值的代码

```python
def solve(arr):
    n = len(arr)
    greater = [-1] * n
    stack = []
    
    for i in range(n):
        while len(stack)!=0 and stack[-1][1] < arr[i]:
            p,v = stack.pop()
            greater[p] = arr[i]
        
        stack.append((i, arr[i]))
    print(greater)
```


### 所有子数组的最大值

[Sum of Max of Subarrays - GeeksforGeeks](https://www.geeksforgeeks.org/sum-of-maximum-elements-of-all-possible-sub-arrays-of-an-array/)

用一个数组记录数组中每个数的左边界距离和右边界距离，从左到右，使用一个单调栈记录每个元素的左边界（左侧更大的值所处的位置），从右到左用一个单调栈记录每个元素的右边界（右侧更大的值所处位置）。左右边界相乘就是该元素作为最大值出现的次数

考虑数组 10 8 5 7 3 9，元素7的左边界（`arr[1]=8`）和右边界（`arr[5]=9`）的距离都是2，这样元素7所能取得最大值的子数组只能在 5 7 3 这个范围取，子数组的数量为 2 * 2 = 4，即 `{5,7}`、`{7,3}`、`{7}` 和 `{5,7,3}`。


### 每个窗口大小的最小值的最大值

[Maximum of minimums of every window size in a given array - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-maximum-of-minimums-for-every-window-size-in-a-given-array/#expected-approach-using-stack-on-time-and-on-space)


对于每个元素找到其右侧较小值的位置，根据这个位置确定window size，对于右侧没有较小值，则看看左侧的较小值，如果都没有，那么就是数组长度


### 最长有效连续子字符串

[Longest Valid Parentheses Substring - GeeksforGeeks](https://www.geeksforgeeks.org/length-of-the-longest-valid-substring/)




## 队列


### BFS

[Breadth First Search or BFS for a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)

BFS 算法如下：对于一个给定的邻接矩阵进行遍历，创建一个queue来存储访问到的节点，用一个visited存储已经访问过的节点

时间复杂度为 $O(V+E)$，V 和 E 分别是顶点和边的数量，空间复杂度为 $O(V)$


```python
def bfs(adj, node): # 从顶点node开始遍历
    n = len(adj)
    queue = deque()
    queue.append(node)
    visited = [False] * n
    
    while len(queue) != 0:
        curr = queue.popleft()
        print(f"now: {curr}")
        visited[curr] = True
        for neigh in adj[curr]:
            if not visited[neigh]:
                queue.append(neigh)
                visited[neigh] = True
```


如果图中存在无连接的情况，可以从每个顶点开始进行bfs。

#### BFS检测无向图中的环


[Detect cycle in an undirected graph using BFS - GeeksforGeeks](https://www.geeksforgeeks.org/detect-cycle-in-an-undirected-graph-using-bfs/?ref=rp)

从每个节点开始遍历，维持一个访问数组，已经访问过的节点不再访问，对于每个节点，访问其邻接节点。如果一个节点已经访问过了，并且还不是父节点，那么就是存在环。

如果是树结构，就不需要访问数组了，因为可以通过左右节点向下传递，不会重新访问到父节点

#### BFS搜索节点的level

[Find the level of given node in an Undirected Graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-level-of-given-node-in-an-undirected-graph/)

在搜索时保存节点和level

```python
def nodeLevel(V, adj, X):
	# code here
	queue = deque()
	if X == 0:
		return 0
	# 从节点0开始
	queue.append((0, 0))
	visited = [False] * V
	while len(queue) != 0:
		curr, level = queue.popleft()
		for neigh in adj[curr]:
			if not visited[neigh]:
				if X == neigh:
					return level + 1
				visited[neigh] = True
				queue.append((neigh, level+1))
	return -1
```


#### 到达数组末尾的最小跳跃次数

[Minimum jumps to same value or adjacent to reach end of Array - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-jumps-to-same-value-or-adjacent-to-reach-end-of-array/)

每次只能跳到同一个值或者左右

自己的解法，不一定正确，先遍历数组，根据只能跳到同一个值和左右两个值这一条件，确定每个节点的邻接点，然后用bfs进行搜索

```python
def solve(arr):
    n = len(arr)
    adj = [[] for _ in range(n)]

    for i in range(n):
        if i < n - 1:
            adj[i].append(i+1)
        
        if i > 0:
            adj[i].append(i-1)
        for j in range(n):
            if j != i:
                if arr[i] == arr[j]:
                    adj[i].append(j)
    
    queue = deque()
    visited = [False] * n
    queue.append((0, 0))  # 初始化最大跳跃次数为0
    min_jumps = n
    while queue:
        curr, jumps = queue.popleft()
        visited[curr] = True
        for neigh in adj[curr]:
            if not visited[neigh]:
                visited[neigh] = True
                queue.append((neigh, jumps+1))
            
            if neigh == n - 1:
                min_jumps = min(min_jumps, jumps + 1)
    return min_jumps
```

>注意官方给出的代码中各种实现的结果有些不同


#### 可移除k个墙壁的最短路径

[Shortest path by removing K walls - GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-by-removing-k-walls/)

创建一个三维数组，保存已经访问过的节点和该节点时还能移除的墙壁数 k，一个queue保存当前的坐标和还能移除的墙壁数，

在循环中，从queue中弹出最前面的元素，探索当前点四个方向

如果当前点为0且未访问，探索所有的方向，将这些方向的点放入queue中，标记当前点已经访问

如果当前点为1且未访问，如果还能移除墙壁，可以移除这个墙壁并探索所有的方向，将所有的未探索的点放入queue中

```python
m = len(mat)
    n = len(mat[0])

    if m == 1 and n == 1 and (mat[0][0] == 0 or k >= 1):
        return 0
    
    visited = [[[False for _ in range(k+1)] for _ in range(n)] for _ in range(m)]

    steps = 0

    queue = deque()

    queue.append((0, 0, k))

    dir1 = [1, -1, 0, 0]
    dir2 = [0, 0, 1, -1]

    while queue:
        steps += 1
        size = len(queue)
        while size:  # 探索完当前已经有的点
            ox, oy, ok = queue.popleft()
            visited[ox][oy][ok] = True
            for i in range(4):  # 探索四个方向上的点
                nx = ox + dir1[i]
                ny = oy + dir2[i]

                if nx >= 0 and nx < m and ny >= 0 and ny < n:
                    if mat[nx][ny] == 0 and not visited[nx][ny][ok]:
                        if nx == m - 1 and ny == n - 1:
                            return steps
                        queue.append([nx, ny, ok])
                        visited[nx][ny][ok] = True
                    
                    elif mat[nx][ny] == 1 and ok > 0 and not visited[nx][ny][ok-1]:
                        if nx == m - 1 and ny == n - 1:
                            return steps
                        queue.append([nx, ny, ok-1])
                        visited[nx][ny][ok-1] = True
            size -= 1
    return -1
```


#### 判断二分图

[Check whether a given graph is Bipartite or not - GeeksforGeeks](https://www.geeksforgeeks.org/bipartite-graph/)

二分图指用两种颜色对图节点进行染色，保证相邻节点的颜色不一样

```python
def solve(V, adj):
    n = len(adj)
    queue = deque()

    queue.append((0, 0))
    visited = [False] * n
    colors = [-1] * n
    colors[0] = 0
    while queue:
        curr, color = queue.popleft()
        visited[curr] = True
        for neigh in adj[curr]:
            if not visited[neigh]:
                visited[neigh] = True
                if color == 0:
                    colors[neigh] = 1
                    queue.append((neigh, 1))
                else:
                    colors[neigh] = 0
                    queue.append((neigh, 0))
            else:
                if colors[neigh] == color:
                    return False
    return True
```



### DFS

[Depth First Search or DFS for a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)

DFS的过程有点像递归

```python
def dfs_rec(adj, visited, s):
    visited[s] = True
    print(s, end=" ")
    for i in adj[s]:
        if not visited[i]:
            dfs_rec(adj, visited, i)   # 对每个邻接节点进行dfs
# s 为开始的点
def dfs(adj, s):
    visited = [False] * len(adj)
    dfs_rec(adj, visited, s)
```


#### dfs 判断两个点之间是否存在路径

[Find if there is a path between two vertices in a directed graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/)

```python
def dfs(start: int, end: int, visited: List[bool], V: int) -> bool:
    if start == end:
        return True
    visited[start] = True
    for x in adj[start]:
        if not visited[x]:
            if dfs(x, end, visited, V):
                return True
    return False
```


### 找到二叉树中所有在给定层级之间的节点

[Print all nodes between two given levels in Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/print-all-nodes-between-two-given-levels-in-binary-tree/)

使用BFS进行搜索，为了避免在queue中保存level这样的信息，可以采用内外循环的方法，BFS每遍历一遍都是将同一级的节点遍历一次，这样可以先保存节点数，每pop一次减1，这样当节点数为0时，这个层级上的节点全部被遍历了。

```python
def solve(root, l1, l2):
    queue = deque()

    queue.append(root)
    level = 1

    while queue:
        size = len(queue)
        while size > 0:
            node = queue.popleft()

            if l1 <= level <= l2:
                print(node.data, end=" ")
            if node.left != None:
                queue.append(node.left)
            if node.right != None:
                queue.append(node.right)
            size -= 1
        if (level >= l1 and level <= l2) :
            print("")
        level += 1
```


### 国王靠近目标的最小步

[Minimum steps to reach target by a Knight | Set 1 - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-steps-reach-target-knight/)

在一个二维平面上，将国王移动到目标的最小步长。因为是求最小步长，所以可以使用BFS，只要搜索到目标就是最小步长。


### 孤岛的数量

[Number of Islands - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-number-of-islands-using-dfs/)

在一个二值矩阵中，1代表有孤岛，且所有相邻的1代表一个孤岛。

可以使用DFS来解决，首先遍历矩阵，当遇到1时，使用DFS来标记周围所有的1，使用一个visited矩阵来标记已经访问过的，防止重复统计孤岛

```python
def solve(grid):

    def isSafe(x, y):
        return (0 <= x < m) and (0 <= y < n)

    def _solve(grid, x, y):
        if grid[x][y] == "0":
            return
        
        visited[x][y] = True

        # 在 8 个方向上搜索，将能找到的 1 全部标记为已经访问
        for i in range(8):
            nx = x + dir1[i]
            ny = y + dir2[i]

            if isSafe(nx, ny) and not visited[nx][ny]:
                _solve(grid, nx, ny)
            

    dir1 = [-1, -1, -1, 0, 0, 1, 1, 1]
    dir2 = [-1, 0, 1, -1, 1, -1, 0, 1]
    m = len(grid)
    n = len(grid[0])

    visited = [[False for _ in range(n)] for _ in range(m)]
    cnt = 0
    for i in range(m):
        for j in range(n):

            if grid[i][j] == '1' and not visited[i][j]:
                _solve(grid, i, j)
                cnt += 1
    return cnt
```

也可以使用BFS，只需要修改 `_solve` 函数中的内容即可，但是似乎会超时

```python
# BFS 的搜索过程
def _solve(grid, x, y):
	queue = deque()
	queue.append((x, y))
	
	while queue:
		x, y = queue.popleft()
		visited[x][y] = True
		for i in range(8):
			nx = x + dir1[i]
			ny = y + dir2[i]

			if isSafe(nx, ny) and grid[nx][ny] == '1' and not visited[nx][ny]:
				queue.append((nx, ny))
```

这种问题的变体还有 [Flood Fill Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/flood-fill-algorithm/)（每次只搜索前后左右四个方向）


### 生成二进制数1-n的快速方法

[An Interesting Method to Generate Binary Numbers from 1 to n - GeeksforGeeks](https://www.geeksforgeeks.org/interesting-method-generate-binary-numbers-1-n/)

```python
from collections import deque

n  = 10

queue = deque()

queue.append("1")
while n > 0:
    n -= 1
    s1 = queue.popleft()
    print(s1)
    queue.append(s1 + "0")
    queue.append(s1 + "1")
```


### 从起点到终点至多k个中间点的最大cost路径

[Maximum cost path from source node to destination node via at most K intermediate nodes - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-cost-path-from-source-node-to-destination-node-via-at-most-k-intermediate-nodes/)

```python
# Python3 program for the above approach
from collections import deque

# Function to find the longest distance
# from source to destination with at
# most K intermediate nodes
def findShortestPath(n, edges, src, dst, K):
    
    # Initialize the adjacency list
    adjlist = [[] for i in range(n)]
    
    # Initialize a queue to perform BFS
    q = deque()

    mp = {}

    # Store the maximum distance of
    # every node from source vertex
    ans = -10**9

    # Initialize adjacency list
    for i in range(len(edges)):
        edge = edges[i]
        adjlist[edge[0]].append([edge[1], 
                                 edge[2]])

    # Push the first element into queue
    q.append([src, 0])

    level = 0

    # Iterate until the queue becomes empty
    # and the number of nodes between src
    # and dst vertex is at most to K
    while (len(q) > 0 and level < K + 2):

        # Current size of the queue
        sz = len(q)

        for i in range(sz):
            
            # Extract the front
            # element of the queue
            pr = q.popleft()
            
            # Pop the front element
            # of the queue
            # q.pop()

            # If the dst vertex is reached
            if (pr[0] == dst):
                ans = max(ans, pr[1])

            # Traverse the adjacent nodes
            for pr2 in adjlist[pr[0]]:
                
                # If the distance is greater
                # than the current distance
                if ((pr2[0] not in mp) or 
                  mp[pr2[0]] > pr[1] + pr2[1]):
                      
                    # Push it into the queue
                    q.append([pr2[0], pr[1] + pr2[1]])
                    mp[pr2[0]] = pr[1] + pr2[1]

        # Increment the level by 1
        level += 1

    # Finally, return the maximum distance
    return ans if ans != -10**9 else -1

# Driver Code
if __name__ == '__main__':
    
    n, src, dst, k = 3, 0, 2, 1

    edges= [ [ 0, 1, 100 ],
             [ 1, 2, 100 ],
             [ 0, 2, 500 ] ]

    print(findShortestPath(n, edges,src, dst, k))

# This code is contributed by mohit kumar 29
```


### 计算起点到终点的所有路径长度为k的可行路径

[Count all possible walks from a source to a destination with exactly k edges - GeeksforGeeks](https://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/)

使用memo优化递归过程

```python
def MinimumWalk(graph, u, v, k):
	def _solve(graph, _u, _v, _k, memo):
		if _u == _v and _k == 0:
			return 1
		if _k <= 0:
			return 0
		if memo[_u][_k] != -1:
			return memo[_u][_k]
		cnt = 0

		for i in range(len(graph)):
			if graph[_u][i] == 1:
				cnt += _solve(graph, i, _v, _k-1, memo)
				cnt = cnt % (10**9 + 7)
		memo[_u][_k] = cnt 
		return cnt
	
	V = len(graph)
	memo = [[-1 for _ in range(k+1)] for _ in range(V)]
	res = _solve(graph, u, v, k, memo)

	return res
```


动态规划的方法（耗时更长）

```python
def solve_dp(graph, u, v, k):
    n = len(graph)
    dp = [[[0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]
    for e in range(0, k+1):
        for i in range(n):
            for j in range(n):
                if e == 0 and i == j:
                    dp[i][j][e] = 1
                if e == 1 and graph[i][j] == 1:
                    dp[i][j][e] = 1
                
                # 只考虑 e > 1 时的情况
                if e > 1:
                    for a in range(n):
                        if graph[i][a] == 1:
                            dp[i][j][e] += dp[a][j][e-1]
                            dp[i][j][e] %= (10 ** 9 + 7)

    return dp[u][v][k]
```



### 有向加权图的最小代价路径

[Minimum Cost of Simple Path between two nodes in a Directed and Weighted Graph - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-cost-of-simple-path-between-two-nodes-in-a-directed-and-weighted-graph/)

加权图不适合使用BFS搜索路径，使用DFS，同时这里注意要在搜索完之后，将起点给设置为未访问，使得可以搜索到其他路径。

```python
V = 5
INF = sys.maxsize

def solve(s, t, visited, graph):
    if s == t:
        return 0

    res = 1000
    visited[s] = 1
    for i in range(V):
        if graph[s][i] != INF and not visited[i]:
            cost = graph[s][i] + solve(i, t, visited, graph)
            res = min(cost, res)
    
    # 允许探索其它路径
    visited[s] = 0
    return res
```


### 有向加权图的最小代价路径（指定需要经过的节点）

[Minimum Cost Path in a directed graph via given set of intermediate nodes - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-cost-path-in-a-directed-graph-via-given-set-of-intermediate-nodes/)

使用DFS，当找到一条路径时，如果指定节点被经过（被访问），就更新最小代价。


### 天然气站问题

[Gas Station - GeeksforGeeks](https://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/)

有一个环形公路，公路上有n个天然气站，每个天然气站的天然气储量为 `gas[i]`，有一辆车从某个天然气站出发，初始天然气容量为0，从第 i 个天然气站出发到下一个天然气站所耗费的天然气为 `cost[i]`，求从哪个站出发能到达所有的天然气站，并最终返回。

最简单的方法是以每个天然气站作为起点进行尝试

另一种算法是使用贪心算法

```python
def solve(gas, cost):

    curr_gas = 0
    all_gas = 0
    start_idx = 0
    for i in range(len(gas)):
        curr_gas += gas[i] - cost[i]
        all_gas += gas[i] - cost[i]

        # 如果从第i个天然气站出发到不了之后的站，就从i+1出发
        if curr_gas < 0:
            start_idx = i + 1
            curr_gas = 0
    # 如果总的天然气不够的话，自然不存在可行的站点
    if all_gas < 0:
        return -1
    return start_idx
```


## 链表

### 常见操作

#### 统计链表长度

[Find Length of a Linked List (Iterative and Recursive) - GeeksforGeeks](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive/)

```python
def getCount(self, head):
	# code here
	
	count = 0
	curr = head
	while curr is not None:
		count += 1
		curr = curr.next
	return count
```


#### 链表插入

```python
# 插入最开始
def insert_at_front(head, data):
    new_node = Node(data)
    new_node.next = head
    return new_node

# 在key之后插入
def insert_after(head, data, key):
    new_data = Node(data)
    curr = head
    while curr is not None:
        if curr.data == key:
            break
        curr = curr.next
    # 找不到目标
    if curr is None:
        return head
    new_data.next = curr.next
    curr.next = new_data
    return head

# 在key之前插入
def insert_befor(head, data, key):
    new_data = Node(data)
    curr = head
    while curr.next is not None:
        if curr.next.data == key:
            break
        curr = curr.next
    # 找不到目标
    if curr.next is None:
        return head
    
    new_data.next = curr.next
    curr.next = new_data
    return head

# 在末尾插入
def insert_end(head, data):
    new_data = Node(data)
    curr = head
    while curr.next != None:
        curr = curr.next
    
    curr.next = new_data
    return head
```

#### 删除节点

删除指定值

```python
def delete_node(head, key):
    if head is None:
        return 
    
    if head.data == key:
        curr = head.next
        del head
        return curr
    curr = head
    prev = curr
    while curr is not None:
        if curr.data == key:
            break
        prev = curr
        curr = curr.next
    
    cnext = curr.next
    prev.next = cnext
    return head
```

> python 中删除链表可以直接将head置为None，而在C++中则需要将每个元素都删除



### 找到链表的中点

[Find Middle of the Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/)

用快慢指针，快指针每次走两步，慢指针每次走一步，快指针走到末尾时，慢指针指向中点

快慢指针还能用来检测链表中的环，如果快慢指针相等代表存在环 [Check if a linked list is Circular Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-linked-list-is-circular-linked-list/)


### 双向链表的删除

[Deletion in a Doubly Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list/)


删除当前点

```python
def del_node(head, key):
    
    curr = head

    while curr is not None:
        if curr.data == key:
            break
        curr = curr.next
    
    if curr is None:
        return head
    
    prev = curr.prev
    next = curr.next
    if prev is not None:
        prev.next = next
    if next is not None:
        next.prev = prev
    
    if head == curr:
        head = curr.next
    
    curr.prev = None
    curr.next = None
    return head
```



### 翻转链表

[Reverse a Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-a-linked-list/)

翻转单向链表，用三个指针指向prev、curr和next，最后返回prev

```python
def reverse_single(head):
    if head is None:
        return head
    prev = None
    curr = head
    next = head.next

    while curr is not None:
        next = curr.next
        curr.next = prev

        prev = curr
        curr = next
    
    return prev
```


翻转双向链表，用两个指针指向prev 和 next，返回prev.prev

```python
def reverse_r(head):
    if head is None or head.next is None:
        return head
    
    prev = None
    curr = head
    while curr is not None:
        prev = curr.prev
        # 开始翻转
        curr.prev = curr.next
        curr.next = prev
        curr = curr.prev
    return prev.prev
```



### 判断环的节点数

[Find length of loop/cycle in given Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/find-length-of-loop-in-linked-list/)

用快慢指针，如果快慢指针相遇了，只移动慢指针，并且计算慢指针的移动次数，快慢指针再次相遇时，慢指针移动次数即为环的节点数

```python
def countNodesInLoop(head):
        
	slow = head
	fast = head

	cnt = 0
	flag = False

	while slow is not None and fast is not None and fast.next is not None:
		slow = slow.next
		if not flag:
			fast = fast.next.next
		
		if flag:
			cnt += 1

		if slow == fast:
			if not flag:
				flag = True
			else:
				return cnt
	return cnt
```



### 链表的快速排序

[QuickSort on Singly Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/quicksort-on-singly-linked-list/)

```python
def getTail(cur):
    while cur and cur.next:
        cur = cur.next
    return cur

# Partitions the list taking the first element as the pivot
def partition(head, tail):
  
    # Select the first node as the pivot node
    pivot = head

    # 'pre' and 'curr' are used to shift all
    # smaller nodes' data to the left side of the pivot node
    pre = head
    curr = head

    # Traverse the list until you reach the node after the tail
    while curr != tail.next:
        
        # If current node's data is less than the pivot's data
        if curr.data < pivot.data:
            
            # Swap the data between 'curr' and 'pre.next'
            curr.data, pre.next.data = pre.next.data, curr.data
            
            pre = pre.next
        
        curr = curr.next

    # Swap the pivot's data with 'pre' data
    pivot.data, pre.data = pre.data, pivot.data
    
    # Return 'pre' as the new pivot
    return pre

def quickSortHelper(head, tail):
  
    # Base case: if the list is empty or consists of a single node
    if head is None or head == tail:
        return
    
    # Call partition to find the pivot node
    pivot = partition(head, tail)

    # Recursive call for the left part of the list (before the pivot)
    quickSortHelper(head, pivot)

    # Recursive call for the right part of the list (after the pivot)
    quickSortHelper(pivot.next, tail)

# The main function for quick sort.
# This is a wrapper over quickSortHelper
def quickSort(head):
  
    # Find the tail of the list
    tail = getTail(head)
    
    # Call the helper function to sort the list
    quickSortHelper(head, tail)
    return head
```


## 树

### 四种遍历

中序遍历 [Inorder Traversal of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/inorder-traversal-of-binary-tree/)

先遍历左子树，然后遍历根节点，然后遍历右子树

```python
def inorder_traversal(root: Node):

    if root is None:
        return
    
    inorder_traversal(root.left)
    print(root.data, end=" ")
    inorder_traversal(root.right)
```

前序遍历 [Preorder Traversal of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/preorder-traversal-of-binary-tree/)

先遍历根节点、再遍历左子树，最后遍历右子树

```python
def preorder_traversal(root: Node):
    if root is None:
        return
    
    print(root.data, end=" ")
    preorder_traversal(root.left)
    preorder_traversal(root.right)
```


后序遍历 [Postorder Traversal of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/postorder-traversal-of-binary-tree/)

先遍历左子树，再遍历右子树，最后遍历根节点

```python
def postorder_traversal(root: Node):
    if root is None:
        return
    postorder_traversal(root.left)
    postorder_traversal(root.right)
    print(root.data, end=" ")
```


层序遍历 [Level Order Traversal (Breadth First Search or BFS) of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/level-order-tree-traversal/)

一层一层的遍历


```python
def levelOrder(root):
    if root is None:
        return []

    # Create an empty queue for level order traversal
    q = deque()
    res = []

    # Enqueue Root
    q.append(root)
    currLevel = 0

    while q:
        len_q = len(q)
        res.append([])

        for _ in range(len_q):
            # Add front of queue and remove it from queue
            node = q.popleft()
            res[currLevel].append(node.data)

            # Enqueue left child
            if node.left is not None:
                q.append(node.left)

            # Enqueue right child
            if node.right is not None:
                q.append(node.right)
        currLevel += 1

    return res
```


### Morris 遍历

[Morris traversal for Inorder - GeeksforGeeks](https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/)

一种时间复杂度为1的遍历，


### 二叉树的插入和删除

[Insertion in a Binary Tree in level order - GeeksforGeeks](https://www.geeksforgeeks.org/insertion-in-a-binary-tree-in-level-order/)

[Deletion in a Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/deletion-binary-tree/)

插入：使用层序遍历，如果一个节点的左节点为NULL，就放在左节点，右节点为NULL，放在右节点。

```python
def InsertNode(root, data):
    if root is None:
        root = Node(data)
        return root
    q = deque()
    q.append(root)

    while q:
        curr = q.popleft()

        if curr.left is not None:
            q.append(curr.left)
        else:
            curr.left = Node(data)
            return root

        if curr.right is not None:
            q.append(curr.right)
        else:
            curr.right = Node(data)
            return root
```


删除：首先找到这个节点，将这个节点的值换成最深的节点的值，然后删除这个最深的节点，下面的代码是删除最深的节点

```python
def delete_deepest(root, dNode):
    queue = [root]

    while queue:
        curr = queue.pop(0)

        # If current node is the deepest 
        # node, delete it
        if curr == dNode:
            curr = None
            del dNode
            return

        # Check the right child first
        if curr.right:
          
            # If right child is the deepest
            # node, delete it
            if curr.right == dNode:
                curr.right = None
                del dNode
                return
            queue.append(curr.right)

        # Check the left child
        if curr.left:
          
            # If left child is the deepest
            # node, delete it
            if curr.left == dNode:
                curr.left = None
                del dNode
                return
            queue.append(curr.left)
```


### 找到和为给定值的二叉树子树

[Subtree with given sum in a Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/subtree-given-sum-binary-tree/)

```python
# foundSum 用数组保存结果
def subtreeSum(root, foundSum, target):
  
    # Base case: If the node is NULL, return 0
    if root is None:
        return 0

    # Calculate the sum of the current subtree
    currentSum = (root.data +
                  subtreeSum(root.left, foundSum, target) +
                  subtreeSum(root.right, foundSum, target))

    # If the current subtree sum matches the target,
    # set foundSum to True
    if currentSum == target:
        foundSum[0] = True

    # Return the current subtree sum
    return currentSum
```


### 判断完全二叉树

[Check whether a given Binary Tree is Complete or not (Iterative Solution) - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-complete-tree-or-not/)

完全二叉树指除了最后一层，其它层全部填满，并且最后一层优先填充左子树。即如果左子树有，那么右子树也必定有


```python
def is_complete_binary_tree(root):
    if root is None:
        return True

    q = deque([root])
    end = False 

    while q:
        current = q.popleft()

        # Check left child
        if current.left:
            if end:
                return False
            q.append(current.left)
        else:
          
            # If left child is missing,
            # mark the end
            end = True

        # Check right child
        if current.right:
            if end:
                return False
            q.append(current.right)
        else:
          
            # If right child is missing, 
            # mark the end
            end = True

    return True 
```


### 计算前序二叉树的深度

[Calculate depth of a full Binary tree from Preorder - GeeksforGeeks](https://www.geeksforgeeks.org/calculate-depth-full-binary-tree-preorder/)

假设存在一个字符串，字符串中 n 表示中间节点，l 表示叶节点，求前序遍历的高度


```python
def solve(s):

    def _solve(s, n, index):

        if index[0] > n or s[index[0]] == 'l':
            return 0
        
        # 左子树
        index[0] += 1
        left = _solve(s, n, index)

        # 右子树
        index[0] += 1
        right = _solve(s, n, index)

        return max(left, right) + 1

    n = len(s)
    index = [0]
    depth = _solve(s, n, index)
    return depth
```


### AVL 树

AVL 是自平衡的二叉搜索树，即任何节点的两个子树的高度差的绝对值不超过1。AVL 树的搜索、插入、删除、最大、最小等操作的时间复杂度为 `O(Log(n))`。

给定高度的AVL树最小节点满足条件 `h(n)=h(n-1)+h(n-2)`

给定高度的AVL树的不同形状的可能性为 `N(h)=2*N(h-1)*N(h-2)` [Different shapes of AVL possible at height h - GeeksforGeeks](https://www.geeksforgeeks.org/different-shapes-of-avl-possible-at-height-h/)

#### AVL 树的插入

[Insertion in an AVL Tree - GeeksforGeeks](https://www.geeksforgeeks.org/insertion-in-an-avl-tree/)

插入采用递归方法，每次插入完毕后需要判断是否需要重整子树

1、如果右子树高度过高，且插入值比右子树的值大：只需要左旋一次
2、如果右子树高度过高，且插入值比右子树的值小：先右旋右子树，再左旋根节点
3、如果左子树高度过高，且插入值比左子树的值小：只需要右旋一次
4、如果左子树高度过高，且插入值比左子树的值大：先左旋左子树，再右旋根节点

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1
    
def height(node: Node):
    if not node:
        return 0
    return node.height

def right_rotate(root: Node):
    left = root.left      # 获得根节点的左子树作为新的根节点
    leftright = left.right  # 获得左子树的右节点
    left.right = root       # 左子树的右节点赋为旧的根节点
    root.left = leftright   # 将左子树的右节点放到根节点的左侧
    root.height = 1 + max(height(root.left), height(root.right))
    left.height = 1 + max(height(left.left), height(left.right))
    return left

def left_rotate(root: Node):
    right = root.right
    rightleft = right.left
    right.left = root
    root.right = rightleft
    root.height = 1 + max(height(root.left), height(root.right))
    right.height = 1 + max(height(right.left), height(right.right))
    return right

def right_left_rotate(root: Node):
    root.right = right_rotate(root.right)
    root = left_rotate(root)
    return root

def left_right_rotate(root: Node):
    root.left = left_rotate(root.left)
    root = right_rotate(root)
    return root

def get_balance(node: Node):
    return height(node.left) - height(node.right)

def insert(root: Node, key):
    if not root:
        return Node(key)
    
    if key < root.key:
        root.left = insert(root.left, key)
    elif key > root.key:
        root.right = insert(root.right, key)
    else:
        return root
    
    root.height = 1 + max(height(root.left), height(root.right))

    balance = get_balance(root)

    if balance > 1 and key < root.left.key:
        return right_rotate(root)
    
    if balance > 1 and key > root.left.key:
        return left_right_rotate(root)
    
    if balance < -1 and key > root.right.key:
        return left_rotate(root)
    
    if balance < -1 and key < root.right.key:
        return right_left_rotate(root)

    return root

def pre_order(root):
    if root:
        print(root.key, end=" ")
        pre_order(root.left)
        pre_order(root.right)


root = None

# Constructing tree given in the above figure
root = insert(root, 10)
root = insert(root, 20)
root = insert(root, 30)
root = insert(root, 40)
root = insert(root, 50)
root = insert(root, 25)
pre_order(root)
```


> 如果存在重复数据，可以加上count属性，记录每种元素出现的次数，详见[AVL with duplicate keys - GeeksforGeeks](https://www.geeksforgeeks.org/avl-with-duplicate-keys/)


#### AVL 树删除

[Deletion in an AVL Tree - GeeksforGeeks](https://www.geeksforgeeks.org/deletion-in-an-avl-tree/)

要删除某个节点，如果该节点无子节点，则直接将该节点置为None，如果存在一个子节点，那就直接将子节点作为该节点。如果两个子节点都存在，那么再右子树中找到最小的值（在右子树中搜索左节点），然后令该节点的值为最小值，然后在右子树中删除这个最小值。

删除完之后，更新该节点的高度，如果不平衡需要进行旋转。


```python
def min_value_node(node):
    current = node
    while current.left is not None:
        current = current.left

    return current

def delete_node(root, key):
    if root is None:
        return root
    if key < root.key:
        root.left = delete_node(root.left, key)
        
    elif key > root.key:
        root.right = delete_node(root.right, key)
    # 删除根节点
    else:
        # 有一个子节点或者没有子节点
        if root.left is None or root.right is None:
            temp = root.left if root.left else root.right
            
            if temp is None:
                root = None
            else:
                root = temp
        else:
            # 右子树的最小值
            temp = min_value_node(root.right)

            root.key = temp.key
			# 删除最小值对应的节点
            root.right = delete_node(root.right, temp.key)

    if root is None:
        return root

    # 更新节点高度
    root.height = max(height(root.left), 
                      height(root.right)) + 1


    balance = get_balance(root)

    # If this node becomes unbalanced, then 
    # there are 4 cases

    # Left Left Case
    if balance > 1 and get_balance(root.left) >= 0:
        return right_rotate(root)

    # Left Right Case
    if balance > 1 and get_balance(root.left) < 0:
        root.left = left_rotate(root.left)
        return right_rotate(root)

    # Right Right Case
    if balance < -1 and get_balance(root.right) <= 0:
        return left_rotate(root)

    # Right Left Case
    if balance < -1 and get_balance(root.right) > 0:
        root.right = right_rotate(root.right)
        return left_rotate(root)

    return root
```


#### 统计AVL树比某个值大的元素的数量

[Count greater nodes in AVL tree - GeeksforGeeks](https://www.geeksforgeeks.org/count-greater-nodes-in-avl-tree/)

在生成AVL树时，加上一个属性来记录比该节点大的元素的数量


#### 有序列表转为AVL

[Sorted Array to Balanced BST - GeeksforGeeks](https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/)

对于一个有序列表，中点为根节点，中点两侧为左右子树，采用递归的方法，不断划分中点即可

```python
def sortedArrayToBSTRecur(arr, start, end):
    if start > end:
        return None

    # Find the middle element
    mid = start + (end - start) // 2

    # Create root node
    root = Node(arr[mid])

    # Create left subtree
    root.left = sortedArrayToBSTRecur(arr, start, mid - 1)

    # Create right subtree
    root.right = sortedArrayToBSTRecur(arr, mid + 1, end)

    return root
sortedArrayToBSTRecur(arr, 0, len(arr) - 1)
```

### 红黑树

[Introduction to Red-Black Tree - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-red-black-tree/)

相较于AVL树，红黑树允许节点的平衡因子大于1，红黑树具有以下5个性质

1、所有节点都是红色或者黑色

2、根节点是黑色

3、红色节点不能有红色子节点

4、从一个节点到所有的后续None节点的路径包含相同数量的黑色节点

5、所有的叶节点（None节点）为黑色

红黑树的统计性能好于 AVL树（特别是在插入和删除时）

n 个节点构成的红黑树的高度满足 $h\le 2\log_2(n+1)$

#### 红黑树的插入

[Insertion in Red-Black Tree - GeeksforGeeks](https://www.geeksforgeeks.org/insertion-in-red-black-tree/)

为了保持平衡，红黑树中引入了重填色和旋转两种方法。

在插入节点时，首先给节点涂上红色，如果该节点是根节点，将颜色改为黑色。如果不是根节点，检查其父节点的颜色，如果是黑色就不用管，否则检查叔节点，如果叔节点是红色，将父节点和叔节点改为黑色，再将祖父节点改为红色，再对祖父节点进行判断。

如果叔节点是黑色，分为四种情况


#### 红黑树的删除

[Deletion in Red-Black Tree - GeeksforGeeks](https://www.geeksforgeeks.org/deletion-in-red-black-tree/)



### 三元搜索树

[Ternary Search Tree - GeeksforGeeks](https://www.geeksforgeeks.org/ternary-search-tree/)

有三个指针，分别指向比自己小的，和自己一样大的和比自己大的。三元搜索树一般用于字符搜索，与一般的字典树相比，每个节点只需要有三个指针，而字典树需要26个。

除了三个指针，还有一个属性来标记该节点是否为某个字符串的结束点

>三元搜索树中只有和自己一样大的子节点才会存储字母


#### 插入

```python
def insert(root, word):
    if root is None:
        root = Node(word[0])

    if word[0] < root.data:
        root.left = insert(root.left, word)
    elif word[0] > root.data:
        root.right = insert(root.right, word)
    else:
        if len(word) > 1:
            root.eq = insert(root.eq, word[1:])
        else:
            root.isEndOfString = True
    return root

```

#### 遍历

```python
def traverseTST(root):
    buffer = [""] * 50

    def _traverse(root, buffer, depth):
        if root:
            _traverse(root.left, buffer, depth)
            buffer[depth] = root.data
            if root.isEndOfString:
                print("".join(buffer[:depth+1]))
            _traverse(root.eq, buffer, depth+1)
            _traverse(root.right, buffer, depth)
    _traverse(root, buffer, 0)
```


#### 搜索

```python
def searchTST(root, word):
    if word[0] < root.data:
        return searchTST(root.left, word)
    elif word[0] > root.data:
        return searchTST(root.right, word)
    else:
        if len(word) > 1:
            return searchTST(root.eq, word[1:])
        else:
            return root.isEndOfString
```

#### 删除

删除一个字符串

[Ternary Search Tree (Deletion) - GeeksforGeeks](https://www.geeksforgeeks.org/ternary-search-tree-deletion/)

```python
# 判断是否有子节点
def isFreeNode(root):
    return not (root.left or root.eq or root.right)

def delete_node(root, s, level):
    if not root:
        return False
 
    # CASE 4 Key present in TST, having atleast
    # one other key as prefix key.
    if level+1 == len(s):
        # 如果该节点是某个字符串的末尾，重置该节点，并判断是否有子节点
        if root.isleaf:
            root.isleaf = False
            return isFreeNode(root)
 
        # string not present in TST and return 0
        return False

    if s[level] < root.key:
        return delete_node(root.left, s, level)
    if s[level] > root.key:
        return delete_node(root.right, s, level)
 
    # CASE 1 Key may not be there in TST.
    if s[level] == root.key and delete_node(root.eq, s, level+1):
        # 如果查询到了，并且该节点后面没有子节点了，将后面置为 None
        root.eq = None
        return not root.isleaf and isFreeNode(root)
 
    return False
```


### 找到三元搜索树中最长的单词

[Longest word in ternary search tree - GeeksforGeeks](https://www.geeksforgeeks.org/longest-word-ternary-search-tree/)

```python
def maxLengthTST(root):
 
    if (root == None):
            return 0
    return max(maxLengthTST(root.left),
                maxLengthTST(root.eq)+1,
                maxLengthTST(root.right))
```


### B-树

[Introduction of B-Tree - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-of-b-tree-2/)

下面是一个 B 树的例子

![](https://media.geeksforgeeks.org/wp-content/uploads/20200506235136/output253.png)

m 阶的 B 树的所有叶节点有着同样的深度，
每个节点至多有m个子节点和m-1个键
B 树的一个节点（除了根节点）至少有 m / 2 - 1 个键，
所有的非叶节点都有至少 m/2 个子节点，
一个有 n-1个键的非叶节点有 n 个不为NULL的子节点。


#### 插入

[Insert Operation in B-Tree - GeeksforGeeks](https://www.geeksforgeeks.org/insert-operation-in-b-tree/)

在插入时，如果待插入节点为叶节点，则直接插入

如果待插入节点不是叶节点，检查子节点是否已经满了，如果已满，将子节点分成两部分，将子节点的中间值放回父节点（待插入节点）

![](https://media.geeksforgeeks.org/wp-content/uploads/20250114142352865981/example_btree_2.webp)



### B+树

[Introduction of B+ Tree - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-of-b-tree/)


### 并查集

[Introduction to Disjoint Set (Union-Find Algorithm) - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-disjoint-set-data-structure-or-union-find-algorithm/)

并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。

并查集主要由一个整型数组 pre和两个函数 find( )、join( ) 构成。
数组 pre 记录了每个点的前驱节点是谁，函数 find(x) 用于查找指定节点 x 属于哪个集合，函数 join(x,y) 用于合并两个节点 x 和 y 。

find函数的实现

```python
class DisjointSet:
    def __init__(self, n):
        self.pre = list(range(n))
    
    def find(self, i):
        # 如果 i 和i的上级节点相同，证明i自己就是最上级的节点（代表）
        while self.pre[i] != i:
            i = self.pre[i]
        return i

    # 合并两个不相交的集合
    def join(self, i, j):
        ir = self.find(i)  # 找到 i 的代表
        jr = self.find(j)  # 找到 j 的代表

        self.pre[ir] = jr  # i 的代表也是 j 的代表
```


在查询时，如果遇到节点是一级一级的情况会很浪费时间，这时候需要进行路径压缩，一种简单的方法是，如果节点 i 的代表节点为 k 的话，直接将 k 作为 i 的上级节点

```python
def find2(self, i):
	ip = self.pre[i]
	if self.pre[ip] != ip:
		self.pre[i] = self.find2(ip)   # 将代表节点作为上级节点
		return self.pre[i]
	return ip
```


在合并时，也有优化的算法，为所有的节点添加一个属性，表示该节点在树中的高度，在合并时，根据树的高度来判断谁是谁的上级，树高的作为上级。

```python
class DisjointSet:
    def __init__(self, n):
        self.pre = list(range(n))
        self.rank = [0] * n
    
    def find2(self, i):
        ip = self.pre[i]
        if self.pre[ip] != ip:
            self.pre[i] = self.find2(ip)
            return self.pre[i]
        return ip
    
    def join2(self, i, j):
        ir = self.find(i)
        jr = self.find(j)
        if ir == jr:
            return
        # i 的代表更高，将 i 的代表作为 j 的代表
        if self.rank[ir] > self.rank[jr]:
            self.pre[jr] = ir
        elif self.rank[ir] < self.rank[jr]:
            self.pre[ir] = jr
        else:
            # j 的代表也是 i 的代表，i 的代表高度加1
            self.pre[jr] = ir
            self.rank[ir] += 1
```




## 堆

对于第 `i` 个元素，左节点为第 `2i+1` 个元素，右节点为第 `2i+2` 个元素

堆是一个完全树（除了最后一层，其他层都需要是满的），父节点的值需要大于左右节点。


### 霍夫曼编码

[Huffman Coding | Greedy Algo-3 - GeeksforGeeks](https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/)

使用堆来保存频率和其对应的节点，每次弹出两个节点，将左右节点的频率加起来形成新的节点，再放入堆中。


### 序列的最大重排

[Largest Derangement of a Sequence - GeeksforGeeks](https://www.geeksforgeeks.org/largest-derangement-sequence/)

将序列进行重排使其位置完全发生改变，求出最大的序列

```python
def largest_derangement(seq):
    n = len(seq)
    res = [0] * n
    pq = []

    for i in range(n):
        pq.append(seq[i])
    
    for i in range(n):
        pq.sort(reverse=True)   # 倒序排序

        d = pq[0]
        del pq[0]
        if (d != seq[i] or i == n - 1):    # 如果顺序不同，就直接赋值
            res[i] = d
        else:                   # 如果顺序相同，就取下一个最大值
            res[i] = pq[0]
            del pq[0]
            pq.append(d)
    return res
```


### 二叉搜索树转为最小堆

[Convert BST to Min Heap - GeeksforGeeks](https://www.geeksforgeeks.org/convert-bst-min-heap/)

先中序遍历二叉搜索树，再前向遍历二叉树时填入对应的值

```python
def inorder_traversal(root, arr):
    if root is None:
        return
    
    inorder_traversal(root.left, arr)
    arr.append(root.data)
    inorder_traversal(root.right, arr)

def preorder_fill(root, arr, idx):
    if root is None:
        return idx
    
    root.data = arr[idx]
    idx += 1
    idx = preorder_fill(root.left,  arr, idx)
    idx = preorder_fill(root.right, arr, idx)
    return idx

def solve(root):
    arr = []
    inorder_traversal(root, arr)
    preorder_fill(root, arr, 0)
```


### 合并两个最大堆

[Merge Two Binary Max Heaps - GeeksforGeeks](https://www.geeksforgeeks.org/merge-two-binary-max-heaps/)


直接两个堆合并在一起，然后转成最大堆。


## 图

### BFS 和 DFS

BFS 使用队列（FIFO）来存储节点，DFS 使用栈（LIFO）来存储节点

BFS 是一种遍历方法，其中我们首先遍历同一级别上的所有节点，然后再转移到下一级别。

DFS 也是一种遍历方法，遍历从根节点开始，尽可能地穿过节点，直到我们到达没有未访问的邻近节点的节点。

BFS 广泛应用于二部图、最短路径等领域。如果每个边的权重相同，则 BFS 给出从源到每个其他顶点的最短路径。

DFS 广泛应用于无圈图和求强连通分量等领域。有很多应用程序可以同时使用 BFS 和 DFS，比如拓扑排序、循环检测等等。


### DFS 检测有向图中的环

[Detect Cycle in a Directed Graph - GeeksforGeeks](https://www.geeksforgeeks.org/detect-cycle-in-a-graph/)

```python
def is_cyclic_util(adj, u, visited, rec_stack):
    
    # If already present in the recursion call
    # stack, then there is a cycle
    if rec_stack[u]:
        return True

    # Mark the current node as visited
    # and part of recursion stack
    visited[u] = True
    rec_stack[u] = True

    # Recur for all the vertices adjacent
    # to this vertex
    for x in adj[u]:
        if not visited[x] and is_cyclic_util(adj, x, visited, rec_stack):
            return True
        elif rec_stack[x]:
            return True

    # Remove the vertex from recursion stack
    rec_stack[u] = False
    return False

# Function to detect cycle in a directed graph

def is_cyclic(adj):
    V = len(adj)
    visited = [False] * V
    rec_stack = [False] * V

    # Call the recursive helper function to
    # detect cycle in different DFS trees
    for i in range(V):
        if not visited[i] and is_cyclic_util(adj, i, visited, rec_stack):
            return True

    return False
```


### Dijkstras最短算法

[Find Shortest Paths from Source to all Vertices using Dijkstra’s Algorithm](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)

从一点出发，找到到其它点的最短路径，不适用于带负值的路径

1、初始化路径数组（初始化为正无穷）和访问数组（初始化为False）
2、循环：每次选择一个最短的路径，并设置该点已被访问过，更新路径数组，判断从新选择的点到该点是否会更近一点

```python
def dijkstra(src):

	dist = [sys.maxsize] * self.V
	dist[src] = 0
	sptSet = [False] * self.V
	
	for cout in range(self.V):
		# 找到最短路径
		x = minDistance(dist, sptSet)

		sptSet[x] = True
	
		# 更新路径
		for y in range(self.V):
			if self.graph[x][y] > 0 and sptSet[y] == False and \
					dist[y] > dist[x] + self.graph[x][y]:
				dist[y] = dist[x] + self.graph[x][y]
```


### Bellman-Ford 算法

[Bellman–Ford Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/)

可以用来处理负权重

初始化一个从起点到其他点的距离数组 `dist`，遍历V次（V为顶点数），每次遍历时遍历所有的边，每条边由起点`u`，终点`v`和距离`wt` 组成，如果满足 `dist[u]+wt < dist[v]`就更新 `dist[v]`。注意当遍历最后一次时，仍然存在需要更新的情况，则证明存在负边。

```python
def bellmanFord(V, edges, src):
    dist = [100000000] * V
    dist[src] = 0
    
    for i in range(V):
        for edge in edges:
            u, v, wt = edge
            if dist[u] != 100000000 and dist[u] + wt < dist[v]:
            
                if i == V - 1:
                    return [-1]
                
                # Update shortest distance to node v
                dist[v] = dist[u] + wt
    return dist
```


### Floyd Warshall 算法

[Floyd Warshall Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/)

可以用来处理负权重边，用来求每对起点到终点之间的距离，用动态规划的方法求解

先初始化一个距离矩阵 `dist`，考虑每个顶点作为中间点，更新这种情况下的最短路径，如果一个顶点 `k` 不是 `i` 到 `j` 的中间点，则保持 `dist[i][j]`，否则如果 `dist[i][j]>dist[i][k]+dist[k][j]`

该方法需要三次循环（循环顶点数），时间复杂度为 $O(V^3)$，因此该方法适合边很多的图，不适合边很稀少的图

```python
def solve(graph):
    V = len(graph)
    
    for k in range(V):
        for i in range(V):
            for j in range(V):
                # 当 i 到 j 未更新距离，或者加入k能让路径更短时
                # 且k到j，i 到k已经更新距离时
                # 更新距离
                if (graph[i][j] == -1 \
                or graph[i][k] + graph[k][j] < graph[i][j]) \
                and (graph[k][j] != -1 and graph[i][k] != -1):
                    graph[i][j] = graph[i][k] + graph[k][j]
```


### Johnson 算法

[Johnson's algorithm for All-pairs shortest paths - GeeksforGeeks](https://www.geeksforgeeks.org/johnsons-algorithm/)

用来找到所有的成对最短路径，该方法适用于边比较稀少的图

首先在图中添加一个新节点 s，该节点可以到达所有其它节点，权重为0。通过Bellman-Ford算法求出以 s 作为起点时到所有点的最短路径，如果找到负权重环，返回。最终可以算出从 s 到其它节点的最短距离 `h`，然后用公式 `w(u,v)=w(u,v)+h(u)-h(v)` 重新分配权重。这样图中所有路径都不是负值，可以使用 Dijkstra 算法求解成对最短路径。


### 有向无环图的最短路径

[Shortest Path in Directed Acyclic Graph - GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/)

在有向无环图中有更好的最短路径求解方法，采用拓扑排序

初始化一个距离数组（初始化为正无穷），从起点出发创建所有节点的拓扑排序，以拓扑排序的顺序遍历所有的节点 `u`，对于 `u` 的相邻节点 `v`，如果 `dist[v]>dist[u]+weight[u,v]`，更新 `dist[v]`


```python
class Graph:
    def __init__(self,vertices):
 
        self.V = vertices # No. of vertices
 
        # dictionary containing adjacency List
        self.graph = defaultdict(list)
 
    # function to add an edge to graph
    def addEdge(self,u,v,w):
        self.graph[u].append((v,w))
        
def solve(g: Graph, s):

    # 拓扑排序，实际路径为 1->3->4->5 和 1->2->5
    # 拓扑排序结果为 5 4 3 2 1
    def topologicalSort(v):
        visited[v] = True
        if v in g.graph.keys():
            for n, w in g.graph[v]:
                if not visited[n]:
                    topologicalSort(n)
        stack.append(v)
        
    n = g.V
    visited = [False] * n
    stack = []

    for i in range(n):
        if not visited[i]:
            topologicalSort(s)
    dist = [float("inf")] * n
    dist[s] = 0

    while stack:
        i = stack.pop()
        for n, w in g.graph[i]:
            if dist[n] > dist[i] + w:
                dist[n] = dist[i] + w
```


### 无权图的最短路径

[Shortest path in an unweighted graph - GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-unweighted-graph/)

使用BFS，用一个数组记录距离和每个节点的父节点

```python
def bfs(graph, S, par, dist):
    q = deque()
    # S 为起点
    dist[S] = 0
    q.append(S)

    while q:
        node = q.popleft()
        for neighbor in graph[node]:
            # 判断是否未访问
            if dist[neighbor] == float('inf'):
                # 标记父节点
                par[neighbor] = node
                # 更新距离
                dist[neighbor] = dist[node] + 1
                q.append(neighbor)
```


如果权重为0或者1，也能用BFS求解

[0-1 BFS (Shortest Path in a Binary Weight Graph) - GeeksforGeeks](https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/)

如果权重为0，将节点放在队列前面，否则将节点放在队列后面

```python
def zeroOneBFS(src: int):
    dist = [INT_MAX] * V

    Q = deque()
    dist[src] = 0
    Q.append(src)

    while Q:
        v = Q.popleft()
        for i in range(len(edges[v])):
            if (dist[edges[v][i].to] > 
                dist[v] + edges[v][i].weight):
                dist[edges[v][i].to] = dist[v] + edges[v][i].weight

                # 权重为0的节点放在前面，可以优先处理
                if edges[v][i].weight == 0:
                    Q.appendleft(edges[v][i].to)
                else:
                    Q.append(edges[v][i].to)
```

### 无向图找到最小的权重环

[Find minimum weight cycle in an undirected graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-minimum-weight-cycle-undirected-graph/)

假定所有的路径的权重都大于0，遍历所有的边，尝试删除这条边之后求起点到终点的最小路径，然后加上这条边的权重，更新最小权重。

```python
class Edge:
    def __init__(self, u, v, weight) -> None:
        self.u = u
        self.v = v
        self.weight = weight

class Graph:
     
    def __init__(self, V: int) -> None:
         
        self.V = V
        self.adj = [[] for _ in range(V)]
        self.edge = []
 
    # 添加边
    def addEdge(self, u, v, w) -> None:
        self.adj[u].append((v, w))
        self.adj[v].append((u, w))
 
        e = Edge(u, v, w)
        self.edge.append(e)
 
    # 删除边
    def removeEdge(self, u, v, w) -> None:
        self.adj[u].remove((v, w))
        self.adj[v].remove((u, w))
 
    # 求最短路径（dijkstra）
    def ShortestPath(self, u: int, v: int) -> int:
         
        # 储存已经处理过的节点
        setds = set()
        
        dist = [INF] * self.V
 
        # 初始添加起点
        setds.add((0, u))
        dist[u] = 0
 
        while (setds):
             
            # 弹出父节点
            _, uu = setds.pop()
 
            # 遍历邻接节点
            for vv, weight in self.adj[uu]:
                if (dist[vv] > dist[uu] + weight):
                     
                    # 删除旧的路径
                    if (dist[vv] != INF):
                        if ((dist[vv], vv) in setds):
                            setds.remove((dist[vv], vv))
					
                    # 更新新的路径
                    dist[vv] = dist[uu] + weight
                    setds.add((dist[vv], vv))
        return dist[v]
 
    def FindMinimumCycle(self) -> int:
         
        min_cycle = maxsize
        E = len(self.edge)
        # 遍历所有的边
        for i in range(E):
            e = self.edge[i]
 
            # 删除当前边
            self.removeEdge(e.u, e.v, e.weight)
 
            # 计算最短距离
            distance = self.ShortestPath(e.u, e.v)
 
            # 更新最小权重环
            min_cycle = min(min_cycle,  distance + e.weight)
 
            # 重新添加当前边
            self.addEdge(e.u, e.v, e.weight)
        return min_cycle
```


### Prim最小生成树

[Prim’s Algorithm for Minimum Spanning Tree (MST) - GeeksforGeeks](https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/)

在一个无向连通加权图中，最小生成树是一棵包含图中所有顶点，且边的权值之和最小的树。它是原图的一个子图，具备树的性质（无回路且连通），同时在所有可能的生成树中总权值最小。

最小生成树可以用来解决：连通所有节点的最短路径

任意选择一个顶点作为开始节点，找到任意树节点和外围节点（还没有纳入树的节点）相连的边，在这些边中找到最小的，将所选的边加入最小生成树中。如此循环直到节点全部处理完。

```python
class Graph():
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for column in range(vertices)]
                      for row in range(vertices)]
    
    # 求最小键对应的索引
    def minkey(self, mstSet, key):
        mink = float("inf")
        idx = 0
        for i in range(self.V):
            if not mstSet[i]:
                if mink > key[i]:
                    idx = i
                    mink = key[i]
        return idx
    
    def solve(self):
        key = [float("inf")] * self.V
        parent = [None] * self.V

        key[0] = 0
        mstSet = [False] * self.V

        parent[0] = -1

        for _ in range(self.V):
            # 从未处理的节点中选择最小距离的节点，最开始选择的是0
            mk = self.minkey(mstSet, key)
            mstSet[mk] = True
            for v in range(self.V):
                # 更新未处理且存在边的顶点距离
                if not mstSet[v] and self.graph[mk][v] > 0:
                    if key[v] > self.graph[mk][v]:
                        key[v] = self.graph[mk][v]
                        parent[v] = mk
        for i in range(1, self.V):
            print(parent[i], "-", i, "\t", self.graph[parent[i]][i])
```

时间复杂度为 $O(V^2)$，适合边很多的图，用最小堆来实现可以进一步减少时间复杂度

```python
import heapq

def findMST(n, edges):
    adj = [[] for _ in range(n + 1)]  # 1-based indexing

    # Convert edge list to adjacency list
    for u, v, w in edges:
        adj[u].append((w, v))
        adj[v].append((w, u))

    pq = [(0, 1)]  # (weight, node), start from node 1
    inMST = [False] * (n + 1)  # 1-based indexing
    mstCost = 0

    while pq:
        w, u = heapq.heappop(pq)
        if inMST[u]:
            continue
        inMST[u] = True
        mstCost += w
		# 将邻接的节点塞入堆中，这时候也不需要更新，直接塞进去就可以了
        for weight, v in adj[u]:
            if not inMST[v]:
                heapq.heappush(pq, (weight, v))
    return mstCost
```

### Kruskal 最小生成树算法

[Kruskal’s Minimum Spanning Tree (MST) Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)

按权重大小升序排列所有的边，选择权重最小的边，并且检查和是否和已有的边形成一个环（使用并查集检测环，如果两个端点在已有的边中有相同的代表，则证明存在环），如果形成环，就不选择这条边，否则选择，直到所有的顶点都被选择。

```python
def kruskals_mst(V, edges):
    edges = sorted(edges,key=lambda x: x[2])
    dsu = DSU(V)
    cost = 0
    count = 0
    for x, y, w in edges:
        # Make sure that there is no cycle
        if dsu.find(x) != dsu.find(y):
            dsu.union(x, y)
            cost += w
            count += 1
            if count == V - 1:
                break
    return cost
```

时间复杂度为 $O(E\log E)$，适合边比较少的


### 生成树的数量

[Total number of Spanning Trees in a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/total-number-spanning-trees-graph/)

有计算方法


### 拓扑排序

[Topological Sorting - GeeksforGeeks](https://www.geeksforgeeks.org/topological-sorting/)

拓扑排序用于排列有向无环图的顶点

拓扑排序的结果不唯一

初始化一个栈 stack 和已经访问过的数组 visited；对于图中每个未访问过的顶点，调用DFS，在DFS中标记该顶点已被访问，并且递归调用DFS遍历未访问过的邻接节点，当所有的邻接节点全部被访问过，将该顶点塞入栈中，栈中最上面保存的即为最靠后的节点。栈中的数组反向输出便为最终的结果。

```python
def topologicalSort(adj):
    V = len(adj)
    st = []
    visited = [False] * V

    def dfs(root):
        visited[root] = True
        for neigh in adj[root]:
            if not visited[neigh]:
                dfs(neigh)
        st.append(root)

    for i in range(V):
        if not visited[i]:
            dfs(i)
    return st[::-1]
```


### Kahn 算法实现拓扑排序

[Kahn's algorithm for Topological Sorting - GeeksforGeeks](https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/)

用一个队列保存所有入度为0的节点，当队列非空时，从队列中删除一个节点，然后将所有与该节点相连的节点的入度减1，如果有节点入度减为1，则将其入队列。

如果队列已空，而图中仍存在节点，证明存在环

队列中的节点代表拓扑排序的顺序。

```python
def solve(adj, V):
    indegree = [0] * V
    
    for i in range(V):
        for v in adj[i]:
            indegree[v] += 1

    queue = deque()
    for i in range(V):
        if indegree[i] == 0:
            queue.append(i)
    result = []
    while queue:
        node = queue.popleft()
        result.append(node)
        # 邻接节点入度减1
        for j in adj[node]:
            indegree[j] -= 1
            # 如果入度降为0，入队列
            if indegree[j] == 0:
                queue.append(j)
    # 存在环，没有拓扑排序
    if len(result) != V:
        return []
    return result
```



### 保持有向无环图的最大可添加边的数量

[Maximum edges that can be added to DAG so that it remains DAG - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-edges-can-added-dag-remains-dag/)

有公式可以计算，保证有向无环图的最多的边数为 $n(n-1)/2$


### 打印所有的拓扑排序

[All Topological Sorts of a Directed Acyclic Graph - GeeksforGeeks](https://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/)

先初始化入度数组，再采用递归的方法打印所有的拓扑排序

```python
def findAllTopologicalOrders(graph, path, discovered, N):
    
    for v in range(N):
        if not discovered[v] and graph.indegree[v] == 0:
            
            discovered[v] = True
            path.append(v)
            for neigh in graph.adjList[v]:
                graph.indegree[neigh] -= 1
            
            findAllTopologicalOrders(graph, path, discovered, N)

            # 还原信息
            discovered[v] = False
            path.pop()
            for neigh in graph.adjList[v]:
                graph.indegree[neigh] += 1
    if len(path) == N:
        print(path)
```




### 有向无环图的最长路径

[Longest Path in a Directed Acyclic Graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-longest-path-directed-acyclic-graph/)

与最短路径不同，最长路径没有所谓的最优子结构，一般图的最长路径是NP-hard问题。但是有向无环图的最长路径有线性的时间复杂度解法

首先初始化一个距离数组 dist（初始化为正无穷），假设起点为 s，令 `dist[s]=0`。

对于所有的顶点进行拓扑排序，按照拓扑排序的顺序遍历所有的节点 u

对于节点 `u` 的邻接节点 `v`，如果 `dist(v)<dist(u)+weight(u,v)`，就更新 `dist(v)`

```python
def solve(V, adj, s):
	# kahn 算法排序
    def topological_sort(adj):
        result = []

        indegree = [0] * V

        for i in range(V):
            for v, w in adj[i]:
                indegree[v] += 1
        
        queue = deque()
        for i in range(V):
            if indegree[i] == 0:
                queue.append(i)
        
        while queue:
            node  = queue.popleft()
            result.append(node)
            for neigh, w in adj[node]:
                indegree[neigh] -= 1
                if indegree[neigh] == 0:
                    queue.append(neigh)
        return result
    
    dist = [-float("inf")] * V
    dist[s] = 0
    # 拓扑排序
    topo = topological_sort(adj)

    for i in topo:
        if dist[i] == -float("inf"):
            continue
        for v, w in adj[i]:
            if dist[v] < dist[i] + w:
                dist[v] = dist[i] + w
    print(dist)
```


### 图中关节点的数量

[Articulation Points (or Cut Vertices) in a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/)

关节点指如果去掉这个点，图会被分成多个不相连的子图

一种简单的方法是尝试每个节点，然后对图进行DFS，一次DFS之后，如果还有节点没有被访问过，证明存在多个图

```python
def solve(adj, V):
    res = []

    def dfs(i, curr):
        vis[curr] = True
        for neigh in adj[curr]:
            # 保证不经过关节点 i
            if neigh != i:
                if not vis[neigh]:
                    dfs(i, neigh)

    for i in range(V):
        components = 0
        vis = [0] * V

        # dfs判断子图数
        for j in range(V):
            if j != i:
                if not vis[j]:
                    components += 1
                    dfs(i, j)
        # 如果存在多个子图
        if components > 1:
            res.append(i)
    print(res)
```


使用 Tarjan 算法求解关节点的数量

```python
def findPoints(adj, u, visited, disc, low, time, parent, isAP):
    
    # Count of children in DFS Tree
    children = 0
    
    visited[u] = 1
    
    # Initialize discovery time and low value
    time[0] += 1
    disc[u] = time[0]
    low[u] = time[0]
    
    # Go through all vertices adjacent to this
    for v in adj[u]:
        
        # If v is not visited yet, then make it a child of u
        # in DFS tree and recur for it
        if visited[v] == 0:
            children += 1
            findPoints(adj, v, visited, disc, low, time, u, isAP)
            
            # Check if the subtree rooted with v has
            # a connection to one of the ancestors of u
            low[u] = min(low[u], low[v])
            
            # If u is not root and low value of one of
            # its child is more than discovery value of u.
            if parent != -1 and low[v] >= disc[u]:
                isAP[u] = 1
        
        # Update low value of u for parent function calls.
        elif v != parent:
            low[u] = min(low[u], disc[v])
    
    # 如果 u 为根节点，且有多个子节点，则为关键点
    if parent == -1 and children > 1:
        isAP[u] = 1

def articulationPoints(adj):
    
    V = len(adj)
    
    res = []
    
    # 记录顶点的发现时间
    disc = [0] * V
    
    # to store earliest visited vertex (the vertex with minimum
    # discovery time) that can be reached from subtree
    low = [0] * V
    
    # to keep track of visited vertices
    visited = [0] * V
    
    # to mark the articulation points
    isAP = [0] * V
    
    # to store time and parent node
    time = [0]
    par = -1
    
    # Adding this loop so that the code works
    # even if we are given disconnected graph
    for u in range(V):
        if visited[u] == 0:
            findPoints(adj, u, visited, disc, low, time, par, isAP)
    
    # storing the articulation points
    for u in range(V):
        if isAP[u] == 1:
            res.append(u)
    
    # if no points are found, return -1
    if not res:
        return [-1]
    
    return res
```


### 计算图中树的数量

[Count number of trees in a forest - GeeksforGeeks](https://www.geeksforgeeks.org/count-number-trees-forest/)

对每个未访问的节点都进行DFS，计数加1，表示存在一个树

如果只有一棵树，那么一次DFS就能找到；如果有多棵树，那么一次DFS后还有未访问的节点，这时候再DFS一次


### 克隆无向图

[Clone an Undirected Graph - GeeksforGeeks](https://www.geeksforgeeks.org/clone-an-undirected-graph/)


传入一个节点，克隆整个图，需要创建一个字典来记录所有已经创建过的节点

```python
from collections import deque

class GraphNode:
	def __init__(self, val=0, neighbors=[]):
		self.val = val
		self.neighbors = neighbors

def cloneGraph(src: GraphNode) -> GraphNode:
	# m 用来记录所有已经创建的节点
	m = {}
	q = deque()
	
	q.append(src)
	node = None

	# Make a clone Node
	node = GraphNode(src.val)

	# 记录初始节点
	m[src] = node
	while q:
		u = q.popleft()
		for neighbor in u.neighbors:
			# 检查该节点是否已被创建
			if neighbor not in m:
				# 没有的话需要创建
				node = GraphNode()
				node.val = neighbor.val
				m[neighbor] = node
				q.append(neighbor)

			# Add these neighbors to the cloned graph node
			m[u].neighbors.append(m[neighbor])

	return m[src]
```


### 图顶点涂色问题

[Introduction to Graph Coloring - GeeksforGeeks](https://www.geeksforgeeks.org/graph-coloring-applications/)

用m种颜色为图顶点涂色，要求相邻顶点不同色，采用回溯法，注意求最少颜色是一个NP完全问题

```python
def graph_coloring(graph, m):
    n = len(graph)
    colors = [-1] * n  # 初始涂色
    def issafe(idx, nc):
        for i in range(n):
            if graph[idx][i] == 1 and colors[i] == nc:
                return False
        return True

    def color(idx):
        if idx == n:
            return True
        res = False
        # 尝试m种颜色
        for i in range(m):
            if issafe(idx, i):
                colors[idx] = i
                if color(idx+1):
                    return True
                colors[idx] = -1
        return res
    
    res = color(0)
    if res:
        print(colors)
```


用贪心算法求解图顶点涂色问题，不能保证最小解

```python
def greedy_solve(adj, V):
    result = [-1] * V
    result[0] = 0 # 先涂第一个顶点

    available = [True] * V  # 可用的颜色

    for i in range(1, V):
        
        for n in adj[i]:
            if result[n] != -1:  # 已经涂过色的顶点
                available[result[n]] = False
        
        cc = 0
        while not available[cc]:
            cc += 1
        
        result[i] = cc

        # 重置可用的颜色
        for n in adj[i]:
            if result[n] != -1:  # 已经涂过色的顶点
                available[result[n]] = True
        
    print(result)
```


### TSP问题

[Travelling Salesman Problem using Dynamic Programming - GeeksforGeeks](https://www.geeksforgeeks.org/travelling-salesman-problem-using-dynamic-programming/#using-recursion-on-time-and-on-space)

TSP是NP-Hard问题，没有几何时间复杂度的解

```python
def tsp(cost):
    n = len(cost)
    def _tsp(mask, idx):
	    # 全部访问过了
        if mask == (1 << n) - 1:
            return cost[idx][0]  # 返回起点的距离
        ans = float("inf")
        for i in range(n):
            # 第 i 点未访问
            if (i != idx) and (mask & (1<<i)) == 0:
                ans = min(ans, cost[idx][i] + _tsp(mask | (1 << i), i))
        return ans
    res = _tsp(1, 0)   # 刚开始访问了第一个节点
    return res
```


最小生成树可以求一个近似解，先求出最小生成树，TSP的最小解绝不会小于最小生成树的权重之和


### K 中心问题

[Greedy Approximate Algorithm for K Centers Problem - GeeksforGeeks](https://www.geeksforgeeks.org/greedy-approximate-algorithm-for-k-centers-problem/)

在一个二维平面的n个点，找到k个中心，使得所有点到中心的距离的最大值最小。这是一个NP-Hard问题。

下面介绍一个近似算法

首先任意选择一个点作为中心，剩下的k-1个中心选择准则为：
1、假设 c1，c2，... 是已经选择的中心
2、第 i + 1个中心 p 应该距离这些已经选择的中心最远（使得 min(dist(p, c1), dist(p, c2), ...) 最大）

```python
def maxIndex(dist, n):
    mi = 0
    for i in range(n):
        if dist[i] > dist[mi]:
            mi = i
    return mi

def solve(n, weights, k):
    dist = [10**9] * n
    max = 0
    centers = []
    for i in range(k):
        centers.append(max)
        # 更新距离
        for j in range(n):
            dist[j] = min(dist[j], weights[max][j])
        # 求距离最大的点
        max = maxIndex(dist, n)
    
    return dist[max]
```

### 求有向图的欧拉回路

[Hierholzer's Algorithm for directed graph - GeeksforGeeks](https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/)

一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数,且该图是连通图。

一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。

```python
def solve(adj):
    n = len(adj)

    if n == 0:
        return []
    currPath = [0]
    circuit = []

    while len(currPath) > 0:
        currNode = currPath[-1]

        # 如果当前顶点还存在边
        if len(adj[currNode]) > 0:
            nextNode = adj[currNode].pop()
            currPath.append(nextNode)
        # 弹出当前的路径
        else:
            circuit.append(currPath.pop())

    circuit.reverse()
    return circuit
```


### 生成给定度的图

[Construct a graph from given degrees of all vertices - GeeksforGeeks](https://www.geeksforgeeks.org/construct-graph-given-degrees-vertices/)

给定图顶点的度，生成一个图

先创建一个邻接矩阵，外部循环起点，内部循环终点，判断是否能构建一条边

```python
def solve(degseq, n):

    mat = [[0] * n for i in range(n)]

    for i in range(n):
        for j in range(i+1, n):
            # 如果能构建一条边
            if degseq[i] > 0 and degseq[j] > 0:
                degseq[i] -= 1
                degseq[j] -= 1
                mat[i][j] = 1
                mat[j][i] = 1
```


### 判断有向图是否存在一个共同的终点


[Determine whether a universal sink exists in a directed graph - GeeksforGeeks](https://www.geeksforgeeks.org/determine-whether-universal-sink-exists-directed-graph/)


采用删除法，如果一条边 `adj[i][j]` 存在，则 i 不是终点，如果不存在，则 j 不是终点。

```python
def solve(V, adj):
    i, j = 0, 0

    def issink(i):
        for j in range(V):
            if adj[i][j] == 1:
                return False
            
            if adj[j][i] == 0 and j != i:
                return False
        return True
    
    while i < V and j < V:
        if adj[i][j] == 1:  # i 是起点
            i += 1 
        else:           # j 不是 i 的终点
            j += 1

    if i > V:
        return -1
    elif not issink(i):
        return -1
    else:
        return i
```


### 统计图中终点的数量

[Number of sink nodes in a graph - GeeksforGeeks](https://www.geeksforgeeks.org/number-sink-nodes-graph/)

初始化一个数组 A，遍历所有的边，对于 `v->u`，则设置 `A[v]=1`，当遍历完之后，统计 A 中 0 的个数。



## 贪心算法


### 背包问题

给定一组物品的价格和重量，一个最大重量的背包，求出能用背包装入的最大价值

允许可以任意拆分物品 [Fractional Knapsack Problem - GeeksforGeeks](https://www.geeksforgeeks.org/fractional-knapsack-problem/)

直接计算每个物品的单价（价格/重量），然后选择单价更高的物体装入就行。

```python
def fractionalKnapsack(W, prices, weights):
    pw = list(zip(prices, weights))
    pw.sort(key=lambda x: (x[0] / x[1]), reverse=True)

    value = 0
    now_weights = 0

    for price, weight in pw:
        if now_weights + weight <= W:
            value += price
            now_weights += weight
        else:
            value += price * (W - now_weights) / weight
            break
    return value
```

对于0-1背包问题，则需要采用动态规划的问题，对于第 i 个物品，背包重量为 j 时
如果背包能够装下：
`dp[i][j] = max(dp[i-1][j], profit[i] + dp[i-1][j-weights[i]])`

如果装不下：

`dp[i][j] = dp[i-1][j]`

```python
def solve_dp(profit, weight, N, W):
    N = len(profit)
    dp = [[0 for _ in range(W+1)] for _ in range(N+1)]

    for i in range(1, N+1):
        for j in range(1, W+1):
            if weight[i-1] <= j:
                dp[i][j] = max(dp[i-1][j], profit[i-1] + dp[i-1][j-weight[i-1]])
            else:
                dp[i][j] = dp[i-1][j]
    return dp[N][W]
```

动态规划完成后，如何根据表格找出装入的物品
[Printing Items in 0/1 Knapsack - GeeksforGeeks](https://www.geeksforgeeks.org/printing-items-01-knapsack/)

首先观察表格的最后一列，该列对应的是背包重量为 W 时的情况，反向遍历最后一列，可以发现，如果第 `i-1` 列和最后一列的值相等，就证明第 `i-1` 个物品没有被选取，否则被选取，然后再跳跃到对应的列

```python
for i in range(n, 0, -1):
	if res <= 0:
		break
	if res == K[i - 1][w]:
		continue
	else:
		# This item is included.
		print(wt[i - 1])
		 
		# Since this weight is included
		# its value is deducted
		res = res - val[i - 1]
		w = w - wt[i - 1]
```


如果一个物品可以选择多次，只需要将动态规划中的

`dp[i][j] = max(dp[i-1][j], profit[i] + dp[i-1][j-weights[i]])`

改为

`dp[i][j] = max(dp[i-1][j], profit[i] + dp[i][j-weights[i]], profit[i] + dp[i-1][j-weights[i]])` 即可

```python
if wt[i-1] <= j:
    dp[i][j] = max(dp[i-1][j], val[i-1] + dp[i][j-wt[i-1]], 
				    val[i-1] + dp[i-1][j-wt[i-1]])
```



### 活动选择问题

[Activity Selection Problem | Greedy Algo-1 - GeeksforGeeks](https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/)

对结束时间进行排序，始终选择结束时间最早的活动

```python
def solve(start, end):

    se = list(zip(start, end))
    se.sort(key=lambda x: x[1])

    finish = -1
    cnt = 0
    for s, e in se:
        if s > finish:  # 第一个结束的活动必定选择
            finish = e
            cnt += 1
    return cnt
```


### 到达数组末尾的最小跳跃次数

[Jump Game - Minimum Jumps to Reach End - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/)

数组的每一位表示能跳到多远的距离。

```python
def solve(arr):
    n = len(arr)

    if arr[0] == 0:
        return -1
    
    max_reach = 0
    curr_reach = 0
    jumps = 0
    for i in range(n):
        # 当前点能到达的最大处
        max_reach = max(max_reach, i + arr[i])

        if max_reach >= n - 1:
            return jumps + 1
        
        # 如果当前点和当前能到达的点相同，就更新当前能到达的点
        if i == curr_reach:
            # 如果当前点等于最大能到达的点，证明当前点已经为0
            if i == max_reach:
                return -1
            curr_reach = max_reach
            jumps += 1

    return -1
```


### 工作排序问题

[Job Sequencing Problem - GeeksforGeeks](https://www.geeksforgeeks.org/job-sequencing-problem/)

假设有一组工作、deadline 和利润，请问如何安排工作使得利润最大化，每个工作所需的时间为1。

划分一组时隙，每组时隙对应一个工作，将工作按照利润从大到小排好，遍历工作和deadline

```python
def JobSequencing(id, deadline, profit):
        n = len(id)
        ans = [0, 0]
        
        jobs = list(zip(profit, deadline))
        
        # 按照利润从大到小排序
        jobs.sort(reverse=True)
    
        # 时隙
        result = [-1] * n
        for i in range(n):
            start = min(n, jobs[i][1]) - 1   # 获取完成的时间
            for j in range(start, -1, -1):
                if result[j] == -1:
                    result[j] = i
                    break
    
        for i in range(n):
            if result[i] != -1:
                ans[1] += jobs[result[i]][0]
                ans[0] += 1
        return ans
```


还有另一种方法，使用最小堆保存利润最大的若干个工作

```python
def JobSequencing(id, deadline, profit):
	n = len(id)
	ans = [0, 0]

	jobs = list(zip(profit, deadline))

	# sort the jobs based on deadline in ascending order
	jobs.sort(key=lambda x: (x[1], -x[0]))

	# to maintain the scheduled jobs based on profit
	pq = []

	for job in jobs:
		# deadline大于目前的工作数
		if job[1] > len(pq):
			heapq.heappush(pq, job[0])
		# 该工作需要提前完成，如果利润更高就需要替换
		elif pq and pq[0] < job[0]:
			heapq.heappop(pq)
			heapq.heappush(pq, job[0])

	while pq:
		ans[1] += heapq.heappop(pq)
		ans[0] += 1

	return ans
```



### 分组和差距最小

[Divide 1 to n into two groups with minimum sum difference - GeeksforGeeks](https://www.geeksforgeeks.org/divide-1-n-two-groups-minimum-sum-difference/)

先计算1到n之和，只考虑总和的一半，反向遍历，只需要把一半和分到一组即可

```python
def findTwoGroups(n):
    sum = n * (n+1) / 2

    groupSum = sum / 2

    group1 = []
    group2 = []

    for i in range(n, 0, -1):
        if groupSum - i >= 0:
            group1.append(i)
            groupSum -= i
        else:
            group2.append(i)
    print(group1)
    print(group2)
```


### 矩阵切分为正方形的最小切割

[Paper Cut into Minimum Number of Squares - GeeksforGeeks](https://www.geeksforgeeks.org/paper-cut-minimum-number-squares/)

这个问题比较复杂，但是选最大的开始切分这种方法是错的


### 给定位数和位之和的最小数

[Find smallest number with given number of digits and sum of digits - GeeksforGeeks](https://www.geeksforgeeks.org/find-smallest-number-with-given-number-of-digits-and-digit-sum/)

对于给定的各位之和 `s`，首先需要减1，保证最高位为1，然后不断用s减9，将 9 放到低位。

```python
def smallestNumber(s, d):
	if s > 9 * d:
		return -1
		
	res = ""
	s -= 1
	
	for i in range(d-1, 0, -1):
		if s > 9:
			s -= 9
			res += "9"
		else:
			res = f"{s}" + res
			s = 0
	
	if s != 0:
		res = f"{s+1}" + res
	else:
		res = "1" + res
	return res
```


### 最小化最大高度差

[Minimize the maximum difference between the heights - GeeksforGeeks](https://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/)

给定一组高度，允许对每个元素增加或减少k，计算改变后的最小最大高度差异

先对数组排序，然后遍历 1 到 n，在 i 之前加 k，在 i 和 i 之后减 k

```python
def getMinDiff(arr, k):
    n = len(arr)
    arr.sort()

    # If we increase all heights by k or decrease all
    # heights by k, the result will be arr[n - 1] - arr[0]
    res = arr[n - 1] - arr[0]

    # For all indices i, increment arr[0...i-1] by k and
    # decrement arr[i...n-1] by k
    for i in range(1, len(arr)):
        # Impossible to decrement height of ith tower by k, 
        # continue to the next tower
        if arr[i] - k < 0:
            continue

        # Minimum height after modification
        minH = min(arr[0] + k, arr[i] - k)

        # Maximum height after modification
        maxH = max(arr[i - 1] + k, arr[n - 1] - k)

        # Store the minimum difference as result
        res = min(res, maxH - minH)
    
    return res
```



## 动态规划

一般如果一个问题要求最大化或者最小化特定数量或者是计数，或是存在重叠子问题，都可以通过动态规划来解决。

动态规划问题重要的是状态和转移，建立状态之间的关系



### 数的组合

给定三个数 `{1,3,5}`，求其和为7的所有组合（允许相同的组合重复出现，如 1 1 3 和 3 1 1 视为不同的组合）

对于和为7的所有组合的数量的计算方式为

1、在所有和为 6 的组合上加 1
2、在所有和为 4 的组合上加 3
3、在所有和为 2 的组合上加 5

即有 `dp[n]=dp[n-1]+dp[n-2]`

```python
def solve(s):
    dp = [0] * (s + 1)
    dp[0] = 1

    for i in range(1, s+1):
        if 1 <= i < 3:
            dp[i] = dp[i - 1]
        elif 3 <= i < 5:
            dp[i] = dp[i-1]+dp[i-3]
        else:
            dp[i] = dp[i-1]+dp[i-3]+dp[i-5]
    return dp[s]
```


如果只考虑不重复的情况，可以参考回溯问题的硬币之和问题


最小代价路径

[Min Cost Path - GeeksforGeeks](https://www.geeksforgeeks.org/min-cost-path-dp-6/)

自己的方法

```python
def solve_dp(cost):
    m = len(cost)
    n = len(cost[0])
    dirx = [1, 0, 1]
    diry = [0, 1, 1]
    def isSafe(x, y, m, n):
        return x <= m - 1 and y <= n - 1
    
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[m-1][n-1] = cost[m-1][n-1]
    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            if i == m - 1 and j == n-1:
                continue
            res = 1e3
            for k in range(3):
                nx = i + dirx[k]
                ny = j + diry[k]
                if isSafe(nx, ny, m, n):
                    res = min(res, cost[i][j]+dp[nx][ny])
            dp[i][j] = res
    return dp[0][0]
```


### 子集之和问题

[Dynamic Programming - Subset Sum Problem](https://www.geeksforgeeks.org/subset-sum-problem-dp-25/#using-recursion-o2n-time-and-on-space)

从一个集合中找到能够满足和为某个值的子集合。

使用回溯法，遍历集合，每次分为是否选择这个值作为子集合的元素

```python
def solve(arr, s):

    def _solve(arr, s, idx):

        if  s == 0:
            return True
        
        if idx >= len(arr) or s < 0:
            return False
        
        return _solve(arr, s - arr[idx], idx+1) or _solve(arr, s, idx+1)
    res = _solve(arr, s, 0)
    return res
```


动态规划，`dp[i][s]` 表示使用 `arr[0:i]` 能否找到一个子集和为 s，如果 s 为 0，那么必定可以。

```python
def solve_dp(arr, target):
    n = len(arr)
    dp = [[False for _ in range(target + 1)] for _ in range(n+1)]

    for i in range(n+1):
        dp[i][0] = True

    for idx in range(1, n+1):
        for s in range(1, target+1):
            if s >= arr[idx-1]:
                dp[idx][s] = dp[idx-1][s - arr[idx-1]] or dp[idx-1][s]
            else:
                dp[idx][s] = dp[idx-1][s]

    return dp[n][target]
```


### 编辑距离

[Edit Distance - GeeksforGeeks](https://www.geeksforgeeks.org/edit-distance-dp-5/)

一个字符串允许对其进行修改、插入和删除这三个操作，请问最少需要多少次操作使得两个字符串相等。

用两个指针 i 和 j 分别指向 s1 和 s2，从 0开始，不需要对两个字符串进行修改

```python
def solve(s1, s2):

    def _solve(s1: str, s2, i, j):
        
        if i == len(s1):
            return len(s2) - j
        
        if j == len(s2):
            return len(s1) - i
        
        if s1[i] == s2[j]:
            return _solve(s1, s2, i+1, j+1)
        else:
            # _solve(s1, s2, i, j+1) 表示s1增加一个元素 s2[j]
            # _solve(s1, s2, i+1, j) 表示s1删除一个元素 s1[i]
            # _solve(s1, s2, i+1, j+1) 表示替换s1 中的一个值
            return 1 + min(_solve(s1, s2, i, j+1), _solve(s1, s2, i+1, j), 
                           _solve(s1, s2, i+1, j+1))

    res = _solve(s1, s2, 0, 0)
    return res
```


动态规划，需要注意初始化边界条件

```python
def solve_dp(s1, s2):
    n1 = len(s1)
    n2 = len(s2)

    dp = [[0 for i in range(n2+1)] for _ in range(n1+1)]

    # 初始化边界条件
    for i in range(n1+1):
        dp[i][0] = i
    
    for j in range(n2+1):
        dp[0][j] = j

    for i in range(1, n1+1):
        for j in range(1, n2+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])
    return dp[n1][n2]
```

### 切木头问题

[Rod Cutting - GeeksforGeeks](https://www.geeksforgeeks.org/cutting-a-rod-dp-13/)

给定一个从1 开始索引的数组，数组的每一项代表该长度的木头可以卖出的价格，求如何切分使得利润最大，数组的长度即为木头的长度

自己的解法（即使用了memo也会超时）

```python
def solve(price):
    n = len(price)

    def _solve(price, s, idx):
        if s < idx:
            return 0
        
        res = max(price[idx-1] + _solve(price, s - idx, idx), _solve(price, s, idx+1))
        return res
    
    res = _solve(price, n, 1)
    return res
```

官方解法（将memo的大小降低到 O(n)）

在迭代函数中设置一个循环，这样可以将memo的大小降到 `O(n)`，减少内存访问

```python
def solve2(price):
    n = len(price)

    def _solve(price, s):
        if s == 0:
            return 0
        res = 0
        for j in range(1, s + 1):
            res = max(res, price[j-1] + _solve(price, s-j))
        return res
    
    res = _solve(price, n)
    return res
```

动态规划

```python
def cutRod(price):
	n = len(price)

	# dp[i] 表示木头长度为 i 时的利润 
	dp = [0] * (n+1)

	for i in range(1, n+1):
		res = 0
		for j in range(1, i+1):
			res = max(res, price[j-1] + dp[i - j])
		dp[i] = res
	return dp[n]
```


### 爬楼梯问题

[Climbing stairs to reach the top - GeeksforGeeks](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)

最基础的爬楼梯问题为 `s[n] = s[n-1]+s[n-2]`

带权重的爬楼问题 [Minimum cost to reach the top of the floor by climbing stairs - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-cost-to-reach-the-top-of-the-floor-by-climbing-stairs/)

`s[n] = cost[n] + min(s[n-1)+s[n-2])`

```python
def solve(cost):
    n = len(cost)
    dp = [0] * (n+2)
    dp[0] = 0
    dp[1] = cost[0]
    # dp[2] = cost[1]
    for i in range(2, n+1):
        dp[i] = cost[i-1] + min(dp[i-1], dp[i-2])
    # 获取爬到第n个楼梯和第n-1个楼梯
    return min(dp[n], dp[n-1])
```


### 硬币之和问题

[Coin Change - Count Ways to Make Sum - GeeksforGeeks](https://www.geeksforgeeks.org/coin-change-dp-7/)

```python
def count_dp(coins, sum):
    n1 = len(coins) + 1
    dp = [[0  for _ in range(sum + 1)] for _ in range(n1)]

    # sum 为 0 有一种方法（什么都不取）
    for i in range(n1):
        dp[i][0] = 1
    
    for i in range(1, n1):
        for j in range(1, sum+1):
	        # 不使用当前硬币的方法数
            dp[i][j] = dp[i-1][j]
            # 使用当前硬币的方法数
            if j - coins[i-1] >= 0:
                dp[i][j] += dp[i][j - coins[i-1]]
    
    return dp[len(coins)][sum]
```


### 最长公共子序列

[Longest Common Subsequence (LCS) - GeeksforGeeks](https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/)


一般来说如果递归用的是从后向前，那么动态规划便是从前到后。

```python
def lcs_dp(s1, s2):
    n1 = len(s1)
    n2 = len(s2)
    dp = [[0 for _ in range(n2+1)] for _ in range(n1 + 1)]

    for i in range(1, n1+1, 1):
        for j in range(1, n2+1, 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[n1][n2]
```


上面的dp还可以使用一个一维数组来替代，节约空间

```python
def lcs_dp2(s1, s2):
    n1 = len(s1)
    n2 = len(s2)
    dp = [0] * (n2 + 1)
	for i in range(1, n1+1):
        prev = dp[0]
        for j in range(1, n2+1):
            temp = dp[j]
            if s1[i-1] == s2[j-1]:
                dp[j] = 1 + prev
            else:
                dp[j] = max(dp[j-1], dp[j])
            prev = temp
    return dp[n2]
```


### 最大完美切分

[Maximize the number of segments of length x, y and z - GeeksforGeeks](https://www.geeksforgeeks.org/maximize-the-number-of-segments-of-length-p-q-and-r/)

给定一段绳子，将其切分为 x, y, z 的组合，不能有剩余。注意必须要切分为 x, y, z 这种形式，求切分的最大数量


```python
def segment(n, x, y, z):

    dp = [0] * (n + 1)

    for i in range(1, n+1):
        dp[i] = 0
        if i >= x and dp[i-x] != -1:
            dp[i] = max(dp[i], 1 + dp[i-x])
        
        if i >= y and dp[i-y] != -1:
            dp[i] = max(dp[i], 1 + dp[i-y])
        
        if i >= z and dp[i-z] != -1:
            dp[i] = max(dp[i], 1 + dp[i-z])
        
        # 如果该值不存在切分，就不要考虑这个值了（剩余部分不能再被切分）
        if dp[i] == 0:
            dp[i] = -1

    return dp[n]
```


### 包括N个值的BST的数量

[Number of Unique BST with N Keys - GeeksforGeeks](https://www.geeksforgeeks.org/number-of-unique-bst-with-a-given-key-dynamic-programming/)

一个BST有N个值，为 1到 n，请问有多少种可能性

假设以第 i 个值作为根节点，那么 1 到 i-1 为左子树，i + 1 到 n 为右子树，设左右子树的可能性分别为 `C(i-1)` 和 `C(n-i)`，则第 i 个值作为根节点时，可能性为 `C(i-1) * C(n-i)`，再进行求和即可

$$
C(n) = \sum_{1}^n C(i-1)*C(n-i)
$$

### 有效括号的数量

[Find the number of valid parentheses expressions of given length - GeeksforGeeks](https://www.geeksforgeeks.org/find-number-valid-parentheses-expressions-given-length/#using-recursion-o2-n-time-and-o1-space)

可以参考回溯问题中生成平衡括号问题的解法，只需要在符合条件时加1即可

有效括号问题可以看成是卡特兰数问题，左括号和右括号可以看成是出栈入栈，只有左括号大于右括号，才能加上右括号


### 卡特兰数

[Program for nth Catalan Number - GeeksforGeeks](https://www.geeksforgeeks.org/program-nth-catalan-number/)

下面介绍一下卡特兰数

第 n 个卡特兰数的定义为

$$
{H_n} = \left\{ \matrix{
  \sum\nolimits_{i = 1}^n {{H_{i - 1}}{H_{n - i}}\quad n \ge 2,n \in {N_ + }}  \hfill \cr 
  1\quad n = 0,1 \hfill \cr}  \right.
$$

这个递推关系的解为

$$
{H_n} = {{C_{2n}^n} \over {n + 1}}\quad n \ge 2,n \in {N_ + }
$$
还有两个常见公式

$$
{H_n} = {{{H_{n - 1}}\left( {4n - 2} \right)} \over {n + 1}}\quad {H_n} = \left( \matrix{
  2n \hfill \cr 
  n \hfill \cr}  \right) - \left( \matrix{
  2n \hfill \cr 
  n - 1 \hfill \cr}  \right)
$$


卡特兰数可以用于计算

1、合法括号匹配数

2、含有k个值的可能二叉搜索树

3、从 （0，0）走到 （n，n），可以向上走，向右走，但是向右走的次数不能少于向上走的次数，一共有多少种走法

4、多边形被分割为若干个三角形 [Number of ways of Triangulation for a Polygon - GeeksforGeeks](https://www.geeksforgeeks.org/number-of-ways-a-convex-polygon-of-n2-sides-can-split-into-triangles-by-connecting-vertices/)
（该问题相当于先画一条线，将大多边形分为两个小多边形，然后分别求这两个小多边形的分割次数）


假设有一个栈的进栈顺序为1，2，3，...，n，求有多少种出栈顺序

假设第一个出栈的数 k 将 1 - n 的序列分成两个序列，其中一个序列为 1 到 k-1，另一个序列为 k+1 到 n，假设 1 到 k - 1 有 C(k-1) 种可能性，k+1 到 n 有 C(n-k) 种可能性，则对于第一个出栈的数 k 有 C(k-1) * C(n-k) 种可能性。将所有的可能性相加可得

$$
C(n) = \sum_{1}^n C(k-1)*C(n-k)
$$

当 n 为 0 时，设置为1，当 n 为 1 时，自然只有1 种可能。




### 统计可能的解码序列

[Count Possible Decodings of a given Digit Sequence - GeeksforGeeks](https://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/)

在递归过程中，如果当前位不为 `0`，则问题变为从下一位开始有多少种可能

同时如果两位在10和26之间，同样也是一种可能

若当前位为 1 且下一位为 5，则可能的分组为 `{.., 1, ...}` 和 `{..., 15, ...}` 这两种

```python
def solve(digits):
    def _solve(digits, idx):
        if idx >= len(digits):
            return 1
        ways = 0
        # 如果当前点不为0，则当前点可以作为一种可能
        if digits[idx] != "0":
            ways = _solve(digits, idx+1)
        if idx + 1 < len(digits) and (digits[idx] == '1' and digits[idx+1] <= '9') \
        or (digits[idx] == '2' and digits[idx+1] <= '6'):
            ways += _solve(digits, idx+2)
        
        return ways
```

动态规划

```python
def solve_dp(digits):
    n = len(digits)
    dp = [0] * (n + 1)
    # 空字符串有一个合法的
    dp[n] = 1
    
    for i in range(n-1, -1, -1):
        if digits[i] != '0':
            dp[i] = dp[i+1]
        
        if i + 1 < n and (digits[i] == '1' and digits[i+1] <= '9') \
        or (digits[i] == '2' and digits[i+1] <= '6'):
            dp[i] += dp[i+2]
    return dp[0]
```


### k 次置换的数量

[Number of permutation with K inversions - GeeksforGeeks](https://www.geeksforgeeks.org/number-of-permutation-with-k-inversions/)


### 四个键按出最多的 A

[How to print maximum number of A's using given four keys - GeeksforGeeks](https://www.geeksforgeeks.org/how-to-print-maximum-number-of-a-using-given-four-keys/)

基本思路是先按A，此后只有按一次全选和复制，按多次粘贴这种操作，关键是找到从什么时候开始全部按粘贴

```python
def solve(n):
    if n <= 6:
        return n
    res = 0
    for i in range(n-3, 0, -1):
        # 按了 n - i - 1 次粘贴，之前按了 i 次 A
        cnt = (n - i - 1) * solve(i)
        res = max(res, cnt)
    return res
```


### 水溢出问题

[Program to find amount of water in a given glass - GeeksforGeeks](https://www.geeksforgeeks.org/find-water-in-a-glass/)

许多水杯堆成一个帕斯卡三角，向最上方的水杯倒入k单位的水，如果溢出只会向其左右两边溢出，求第R行第C列的杯子的水量

```python
def solve(k, r, c):

    dp = [[0 for i in range(r+1)] for _ in range(r+1)]
    # 初始情况下最上面的杯子装了k单位水
    dp[0][0] = k

    for i in range(r):  # 然后开始逐层溢出
        for j in range(i+1):
            # i,j 位置的杯子溢出的水的单位
            excess = max(0.0, dp[i][j] - 1.0)

            if excess > 0:
                dp[i][j] = 1.0
                dp[i+1][j] += excess / 2.0   # 左右两个杯子所接收的水的单位
                dp[i+1][j+1] += excess / 2.0
    return min(1.0, dp[r-1][c-1])
```



### 最大增长子序列

[Longest Increasing Subsequence (LIS) - GeeksforGeeks](https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/)

对于每一位元素，都检查之前的元素，如果比之前的元素`arr[j]`大，就取`1+arr[j]`

`dp[i]` 表示第 i 个点大于之前的点的数量

```python
def solve(arr):
    n = len(arr)
    dp = [1] * n
    dp[0] = 1
    maxv = 1
    for i in range(n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], 1+dp[j])
                maxv = max(dp[i], maxv)
    return maxv
```



### 最大可除子集

[Largest divisible subset in array - GeeksforGeeks](https://www.geeksforgeeks.org/largest-divisible-subset-array/)


### 带权重的工作规划

[Weighted Job Scheduling - GeeksforGeeks](https://www.geeksforgeeks.org/weighted-job-scheduling/)

递归解法如下，先对工作按照起始时间排序，重点是传入last来记录最后完成的时间

```python
def solve(jobs):
    def _solve(jobs, idx, last):
        if idx == len(jobs):
            return 0
        res = _solve(jobs, idx+1, last)
        if jobs[idx][0] >= last:
            res = max(res, jobs[idx][2] + _solve(jobs, idx+1, jobs[idx][1]))
        return res

    jobs.sort()
    ans = _solve(jobs, 0, -1)
```

在使用memo来减小时间复杂度时，需要注意如果将memo设置为二维矩阵，或耗费大量存储空间，考虑如下的实现方法，只在能选择工作时返回memo中存储的值

```python
def maxProfitRecur(jobs, ind, last, memo):
    if ind == len(jobs):
        return 0

    # if the job can be taken
    if jobs[ind][0] >= last:

        # if the value is not calculated
        if memo[ind] == -1:

            # take the job
            memo[ind] = jobs[ind][2] + \
                maxProfitRecur(jobs, ind + 1, jobs[ind][1], memo)

            # leave the job and find max
            memo[ind] = max(memo[ind],
                      maxProfitRecur(jobs, ind + 1, last, memo))

        return memo[ind]

    # if the job can't be taken
    return maxProfitRecur(jobs, ind + 1, last, memo)
    
def maxProfit(jobs):
    # Sort the jobs based on start time
    jobs.sort()
    memo = [-1] * len(jobs)
    return maxProfitRecur(jobs, 0, -1, memo)
```

动态规划的方法如下，将工作按照起始时间排序后，从后向前遍历，`dp[i]` 表示 `i` 至 `n-1` 范围内的最大利润，用一个指针 `j` 遍历 `i+1` 到 `n-1`，如果第 `j` 个工作的起始时间大于第 i 个工作的开始时间，就将 `dp[i] = profit[i]+dp[j]`

```python
def solve_dp(jobs):
    n = len(jobs)
    dp = [0] * n
    res = 0
    for i in range(n-1, -1, -1):
        dp[i] = jobs[i][2]
        for j in range(i+1, n):
            if jobs[j][0] >= jobs[i][1]:
                dp[i] = max(dp[i], dp[j] + jobs[i][2])
        res = max(res, dp[i])
    return res
```


上述方法还可以优化为使用二分查找搜索满足要求的工作 `j`


### 正则表达式匹配

[Regular Expression Matching - GeeksforGeeks](https://www.geeksforgeeks.org/implementing-regular-expression-matching/)


### 形成回文字符串的最小插入次数

[Minimum insertions to form a palindrome - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-insertions-to-form-a-palindrome-dp-28/)

采用递归解法

```python
def solve(s):
    def _solve(s, l, h):
        if l > h:
            return float("inf")
        if l == h:
            return 0
        if l == h - 1:
            return 0 if s[l] == s[h] else 1
        
        if s[l] == s[h]:
            return _solve(s, l+1, h-1)
        
        else:
            return min(_solve(s, l+1, h), _solve(s, l, h-1)) + 1
    
    res = _solve(s, 0, len(s)-1)
    return res
```

采用动态规划的解法

```python
def solve_dp(s):
    n = len(s)
    dp = [[n for i in range(n)] for _ in range(n)]
	# 初始化
    for i in range(n):
        dp[i][i] = 0
        if i + 1< n:
            dp[i][i+1] = 0 if s[i] == s[i+1] else 1
        if i - 1 >= 0:
            dp[i-1][i] = 0 if s[i-1] == s[i] else 1

    for i in range(n-1, -1, -1):
        for j in range(i+2, n):   # 长度从 2 开始
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1]
            else:
                dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1
    
    return dp[0][n-1]
```


### 鸡蛋滚落测试

[Egg Dropping Puzzle | DP-11 - GeeksforGeeks](https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/)

用n个鸡蛋测试k个台阶，求找到会摔碎的台阶的最小步骤数

当鸡蛋从台阶 x 上滚落时，会出现两种情况

1、会摔碎：用一个鸡蛋检查比 x 小的台阶
2、不会摔碎：用一个鸡蛋检查比 x 大的台阶

首先主要注意的是如果只有一颗鸡蛋，那么需要 k 个步骤才能检查出来

```python
def solve(n, k):
    def _solve(n, k):
        if k == 0 or k == 1:
            return k
        # 一个鸡蛋直接返回 k
        if n == 1:
            return k

        cnt = k
        # 从 1 到 k 个台阶开始尝试
        for i in range(1, k+1):
            cnt = min(cnt, 1 + max(_solve(n-1, i-1), _solve(n, k-i)))
        return cnt
    res = _solve(n, k,)
    return res
```

若有两个鸡蛋用于测试时，则有如下测法，将一个鸡蛋每隔 x 个台阶滚一次，如果碎了，就测试剩下的x-1个台阶，这样测试次数为 `k / x + x - 1`





### 回文子字符串计数

[Palindrome Substrings Count - GeeksforGeeks](https://www.geeksforgeeks.org/count-palindrome-sub-strings-string/)

统计所有长度大于1的回文子字符串，这里需要生成所有长度大于1的子字符串，在判断子字符串是否回文时可以采用memo的方法

```python
def solve(s):
    n = len(s)
    memo = [[False for _ in range(n)] for _ in range(n)]

    for i in range(n):
        memo[i][i] = True

    # 先初始化回文矩阵
    for i in range(n-1, -1, -1):
        for j in range(i+1, n):
            if s[i] == s[j]:
                if i + 1 <= j - 1:
                    memo[i][j] = memo[i+1][j-1]
                else:
                    memo[i][j] = True
            else:
                memo[i][j] = False

    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if memo[i][j]:
                cnt += 1
    return cnt
```


### 游戏的最优策略

[Optimal Strategy for a Game - GeeksforGeeks](https://www.geeksforgeeks.org/optimal-strategy-for-a-game-dp-31/)

一组不同面值的硬币，两名用户取硬币，每一回合只能取一次硬币，求先出手的玩家能获得的最大数量硬币

```python
def solve(arr):
    def _solve(arr, l, r):
        if l > r:
            return 0

        # 玩家选择最开始的硬币，对手会选择使我们利润最小的硬币
        cnt1 = arr[l] + min(_solve(arr, l+1, r-1), _solve(arr, l+2, r))
       
        # 玩家选择最后面的硬币
        cnt2 = arr[r] + min(_solve(arr, l, r-2), _solve(arr, l+1, r-1))

        return max(cnt1, cnt2)
    res = _solve(arr, 0, len(arr)-1)
    return res
```


### 画家分割问题

[The Painter's Partition Problem - GeeksforGeeks](https://www.geeksforgeeks.org/painters-partition-problem/)

该问题相当于求将数组顺序分成若干份，并求出每种分法中的最大值和最小值

```python
def minimizeTime(curr, n, arr, k):
    # Base cases
    if curr >= n:
        return 0
    # No painters left, infeasible case
    if k == 0:
        return float('inf')  
     # Current workload for this painter
    currSum = 0  
    
    # Result to store the minimum possible time
    res = float('inf')  

    # Divide the boards among painters starting from curr
    for i in range(curr, n):
        currSum += arr[i]

	    # Find the maximum time if we assign
	    # arr[curr..i] to this painter
        remTime = minimizeTime(i + 1, n, arr, k - 1)
        maxTime = max(currSum, remTime)

        # Update the result
        res = min(res, maxTime)

    return res
```



## 分治

将长数据分成两部分进行计算


### 最接近目标的子序列之和

[1755. 最接近目标值的子序列和 - 力扣（LeetCode）](https://leetcode.cn/problems/closest-subsequence-sum/)

在数组中求一个子序列，使其和与目标值的之间的差值最小，求差的绝对值最小值

该题可以用递归方法解决，但是当数组较长（n>=40）时，会超时，因此可以考虑将数组分为左右两部分，分别对左右两个部分计算子序列之和并保存下来，对左右子序列之和进行排序。后边分为两种做法

1、循环左半部分，然后对右半部分进行二分查找
2、用一个指针指向左半部分开始，用另一个指针指向右半部分结尾

计算子序列之和

```python
def fillsum(arr, idx, res, sums):
	if idx == len(arr):
		sums.append(res)
		return
	
	fillsum(arr, idx+1, res+arr[idx], sums)
	fillsum(arr, idx+1, res, sums)
```

第一种方法

```python
mid = len(nums) // 2
fillsum(nums[:mid], 0, 0, left)
fillsum(nums[mid:], 0, 0, right)
left.sort()
right.sort()

for i in range(len(left)):
	nt = goal - left[i]
	idx = bisect_left(right, nt)
	if idx == len(right):
		res = min(res, abs(nt - right[-1]))
	else:
		res = min(res, abs(nt - right[idx]))
	if idx != 0:
		res = min(res, abs(nt - right[idx-1]))
	if res == 0:
		break
```

第二种方法

```python
mid = len(nums) // 2
fillsum(nums[:mid], 0, 0, left)
fillsum(nums[mid:], 0, 0, right)
left.sort()
right.sort()
i = 0
j = len(right) - 1

while i < len(left) and j >= 0:
	tmp = left[i] + right[j]
	res = min(res, abs(tmp - goal))
	if res == 0:
		break
	if tmp > goal:
		j -= 1
	else:
		i += 1
```



### 天际线问题

[The Skyline Problem | Set-1 - GeeksforGeeks](https://www.geeksforgeeks.org/the-skyline-problem-using-divide-and-conquer-algorithm/)

采用类似归并算法思路，两两分组最终得到一个元素，该元素对应的两个天际线，分别为 (起点，高度) 和 (终点，0)，然后再合并


```python
def solve(arr):
    n = len(arr)

    def merge(sky1, sky2):
        i,j, h1, h2 = 0, 0, 0,0 
        n1, n2 = len(sky1), len(sky2)
        res = []
        while i < n1 and j < n2:
            if sky1[i][0] < sky2[j][0]:
                l1, h1 = sky1[i]
                maxh = max(h1, h2)
                res.append((l1, maxh))
                i += 1
            else:
                l2, h2 = sky2[j]
                maxh = max(h1, h2)
                res.append((l2, maxh))
                j += 1
        while i < n1:
            res.append(sky1[i])
            i+=1
        
        while j < n2:
            res.append(sky2[j])
            j += 1

        return res
    
    def _solve(arr, l, r):
        if l == r:
            return [(arr[l][0], arr[l][1]), (arr[l][2], 0)]
        
        mid = l + (r - l) // 2
        rl = _solve(arr, l,mid)
        rr = _solve(arr, mid+1, r)
        res = merge(rl, rr)
        return res
    res = _solve(arr, 0, n-1)
    fres = []
    lh = 0

    for i in range(len(res)):
        if res[i][1] != lh:
            fres.append(res[i])
        lh = res[i][1]
    print(fres)
```


### 最小页数分配


[Allocate Minimum Pages - GeeksforGeeks](https://www.geeksforgeeks.org/allocate-minimum-number-pages/)

将一组书，每个书对应一个页数，将这组书顺序分给k个学生，求最小的最大分配页数

这个问题和动态规划中的画家分割问题类似，下面介绍一种二分查找的方法，该方法直接通过给出最小页数，判断该最小页数是否满足条件来确定最后的解

判断条件为

1、如果当前页数大于最小页数，则剩下的书不够分给剩下的k-1个学生
2、如果当前页数小于最小页数，则剩下的书过多


```python
def solve(arr, k):

    def check(arr, k, mp):
        cnt = 1
        pageSum = 0

        for pages in arr:
            # 加上目前的书超过了最小页数，那么就把以及分好的pageSum分给下一个学生
            if pageSum + pages > mp:
                cnt += 1
                pageSum = pages
            else:
                pageSum += pages
        return cnt <= k
    
    low = max(arr)
    high = sum(arr)
    res = 0
    while low <= high:
        mid = low + (high - low) // 2
        if check(arr, k, mid):  # 如果书不够分
            res = mid
            high = mid - 1
        else:
            low = mid + 1
    return res
```


## 分支定界

用于找到数学优化问题的最优解


### 0-1 背包问题

[0/1 Knapsack using Branch and Bound - GeeksforGeeks](https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/)

如果重量不是整数，那就不能直接用动态规划，可以考虑使用分支定界方法

先对物品按照单位利润从大到小排序，每次考虑加入当前物品和不加入当前物品时的利润，通过贪婪算法计算出当前情况的上界，如果上界大于目前的利润，将该点放入队列中考虑之后的情况。

```python
def solve(W, arr):
    # arr[i] = (weight, profit)
    # W 重量
    def bound(u):
        if u[2] >= W:
            return 0
        profit_bound = u[1]  # 利润上界
        j = u[0] + 1
        total_weight = u[2]

        while j < n and total_weight + arr[j][0] <= W:
            total_weight += arr[j][0]
            profit_bound += arr[j][1]
            j += 1
        
        # 如果还有物品剩下来，计算下一个物品的分数贡献
        if j < n:
            profit_bound += int((W - total_weight) * arr[j][1] / arr[j][0])
        return profit_bound

    n = len(arr)
    
    arr = sorted(arr, key=lambda x: x[0] / x[1]) # 按照单位利润的倒数排列
    queue = deque()
    queue.append([-1, 0, 0])   # 放入一个空节点 (level, profit, weight)
    max_profit = 0
    while queue:
        cl, cp, cw = queue.popleft()
        if cl == -1:
            v = [0, 0, 0]   # 起始点
        elif cl == n - 1:   # 跳过最后一个点
            continue
        else:               # 下一个点
            v = [cl+1, cp, cw]
        
        # 选择当前物品
        v[2] += arr[cl][0]      # weight
        v[1] += arr[cl][1]      # profit

        if v[2] < W and v[1] > max_profit:
            max_profit = v[1]
        
        v_bound = bound(v)
        if v_bound > max_profit:
            queue.append(v)
        
        # 不选择当前物品
        v = [cl + 1, cp, cw]
        v_bound = bound(v)
        if v_bound > max_profit:
            queue.append(v)
    return max_profit
```


### 8 数码问题

[8 puzzle Problem - GeeksforGeeks](https://www.geeksforgeeks.org/8-puzzle-problem-using-branch-and-bound/)

将 8 个数和一个空白区域组成的一个 3×3 网格中移动数字，使其符合某个预定的状态

可以使用DFS或者BFS解决，以BFS为例，用一个队列保存当前状态，将空白区域向四个方向移动，得到四个状态（需要用一个矩阵保存已经访问过的状态）

DFS类似，用一个栈保存状态

这两种方法的时间复杂度和空间复杂度都为 `O(n!)`。

为了避免空间占用过大，可以使用分支定界方法，用一个cost表示当前状态和最终状态之间的差距，每次选择差距最小的状态

```python
row = [1, 0, -1, 0]
col = [0, -1, 0, 1]

def solve(initial, x, y, final):
    
    def isSafe(x, y):
        if x < 3 and x >= 0 and y < 3 and y >= 0:
            return True
        return False
    # 计算当前差距
    def cal_cost(state):
        cost = 0
        for i in range(3):
            for j in range(3):
                if state[i][j] != final[i][j]:
                    cost += 1
        return cost
    
    pq = []
    cost = cal_cost(initial)
    root = Node(initial, x, y, 0, None)
    root.cost = cost
    pq.append(root)

    while pq:
        min_node = min(pq, key=lambda x: x.cost)  # 选择差距最小的
        pq.remove(min_node)
        if min_node.cost == 0:  # 差距为0，代表满足要求
            print_path(min_node)
            return
        
        for i in range(4):
            new_x, new_y = x + row[i], y + col[i]
            if isSafe(new_x, new_y):
                new_mat = [row[:] for row in min_node.mat]
                new_mat[new_x][new_y], new_mat[x][y] = \
                    new_mat[x][y], new_mat[new_x][new_y]
                child = Node(new_mat, new_x, new_y, min_node.level+1, min_node)
                child.cost = cal_cost(new_mat)
                pq.append(child)
```


### 旅行商问题

[Traveling Salesman Problem using Branch And Bound - GeeksforGeeks](https://www.geeksforgeeks.org/traveling-salesman-problem-using-branch-and-bound-2/)


### 工作分配问题

[Job Assignment Problem using Branch And Bound - GeeksforGeeks](https://www.geeksforgeeks.org/job-assignment-problem-using-branch-and-bound/)

[算法分享，匈牙利算法（Hungarian Algorithm）详解（步骤、正确性分析、时间复杂度分析） - 知乎](https://zhuanlan.zhihu.com/p/677501913)
匈牙利算法流程

在每一行找到最小值，该行元素减去该最小值

在每一列找到最小值，该列元素减去该最小值

用最小的行和列覆盖所有的 0 元素，如果行和列的数量等于 n，则可以求解，否则需要在未覆盖的元素中找到最小值，未覆盖的元素减去这个最小值，重复该步骤，直到可以求解

算法的关键是如何找到最小的行和列来覆盖0元素
