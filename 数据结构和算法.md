
## 数的表示

### 数字可除性

判断一个数是否能被7整除

每个数都可以表示为 `10a+b` 的形式，已知 7a + 7b 能被7整除，那么只需要判断 `10a+b-7a-7b` 即 3a-6b 即 `a-2b` 能否被7整除。

```python
def isDivisibleBy7(num) :
     
    # If number is negative, make it positive
    if num < 0 :
        return isDivisibleBy7( -num )
 
    # Base cases
    if( num == 0 or num == 7 ) :
        return True
     
    if( num < 10 ) :
        return False
         
    # Recur for ( num / 10 - 2 * num % 10 ) 
    return isDivisibleBy7( num // 10 - 2 * ( num - num // 10 * 10 ) )
```



### 质数相关

如何判断一个数是不是质数，一种快速算法如下

依据为：所有数都可以表示为 `6k+i` 的形式，如果一个数不能被 2 或者 3 整除，那么如果是质数的话，必须满足 `6k+1` 或者 `6k+5` 这两种形式（其它形式都可以被 2 或者 3 整除），所以将这个数除 6k+1 或者 6k + 5 可以验证其是否是质数。

```python
import math

def isPrime(n):

    # Check if n is 1 or 0
    if n <= 1:
        return False

    # Check if n is 2 or 3
    if n == 2 or n == 3:
        return True

    # Check whether n is divisible by 2 or 3
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check from 5 to square root of n
    # Iterate i by (i+6)
    i = 5
    while i <= math.sqrt(n):
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6

    return True

if __name__ == "__main__":
  n = 11
  if(isPrime(n)): 
    print("true")
  else:
    print("false")
```


埃拉托色尼筛法：找到0-n之间所有的质数和合数：如果n是质数，那么`n*n+k*n` 都不是质数，

```python
def SieveOfEratosthenes(n):

    # Create a boolean array
    # "prime[0..n]" and initialize
    #  all entries it as true.
    # A value in prime[i] will
    # finally be false if i is
    # Not a prime, else true.
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

        # If prime[p] is not
        # changed, then it is a prime
        if (prime[p] == True):

            # Update all multiples of p
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

    # Print all prime numbers
    for p in range(2, n+1):
        if prime[p]:
            print(p)
```



## 矩阵计算


### 矩阵计算斐波那契数列

对于广义斐波那契数列 $g(n)=a*g(n-1)+b*g(n-2)+c$ ，使用迭代方法时间复杂度为 $O(n)$，使用矩阵计算可以将时间复杂度降为 $O(log_2n)$

矩阵计算可以表示成

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = \left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]\left[ \matrix{
  g(n - 1) \hfill \cr 
  g(n - 2) \hfill \cr 
  c \hfill \cr}  \right]
$$
这样$g(n)$ 可以这样计算

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = {\left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]^{n - 2}}\left[ \matrix{
  g(2) \hfill \cr 
  g(1) \hfill \cr 
  c \hfill \cr}  \right]
$$

等式右侧的幂次矩阵可以一次算两个，甚至可以先算好两次方，直接用也行

具体实现如下

```python
mat = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix
res = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix

def mul(self, res, mat, m):
	res1 = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix
	for i in range(3):
		for j in range(3):
			for k in range(3):
				res1[i][j] += (res[i][k]*mat[k][j]) # Multiplying matrices element-wise and summing
				res1[i][j] %= m # Taking modulo m to avoid overflow
	
	for i in range(3):
		for j in range(3):
			res[i][j] = res1[i][j] # Updating the resultant matrix

def mat_exp(self, n, m):
	while n>0:
		if n&1:  
			self.mul(self.res, self.mat, m) # Multiplying the result matrix with the current matrix
		self.mul(self.mat,self.mat,m) # Squaring the current matrix
		n //= 2 # Halving the power of the matrix
```


## 进制问题

### 小鼠和毒药问题

**原始**：假设有1000瓶药水，其中有一瓶是毒药，可以任意混合，请问需要多少只小鼠才能验出有毒的一瓶？（每只小鼠只喝一次药水）

1000瓶药水可以编号为0, 1, ..., 999，写成二进制为

0000000000
0000000001
...
1111100111

为了确定哪一瓶有毒，只需要每一位为1的药水混合起来（对于最低位，就是1，3，5，7等等），喂给一只小鼠，这样一共需要10只小鼠，哪一只小鼠死了，表示该位为1，否则不为1，这样便能确定毒药的位置，当然如果全部都不死，那么第一瓶就是毒药。

即小鼠数量等于 $ceil(\log_2N)$，$N$ 为药水数量。

**变体1**：假设可以测试两轮，4只小鼠可以检测多少瓶药水（只有一瓶有毒，每只小鼠一轮只喝一次）

分成两种情况

1、如果死的小鼠不能更换，那么每只小鼠有3种状态，第一轮死、第二轮死和不死。那么共能测试 $3^{4}$ 瓶药水，具体测试过程为：

先将药水编成3进制

0000
0001
0002
0010
0011
0012
...
2222

第一轮先将每一位有2的药水全部混合起来，喂给4只小鼠。如果有一只小鼠死了，代表这一位为2，那么把所有该位为2的药水拿出来做第二轮测试，由于第二轮测试中该位全部为2，相当于回到了原来的情况，不过位数少了一位，用剩下的3只测试就够了；如果第一轮测试没有小鼠死，那么去掉所有编码包含2的瓶子，这样只剩下了01编码的，回到了二进制，用剩下的4只小鼠测试即可


2、如果死的小鼠可以替换，那么相当于有8只小鼠，这样共可以测试 $2^8$ 瓶药水。另外一种思考方式为将药水按顺序每16个混合在一起做一轮测试，这样下一轮再测试16个。

**变体2**：如果有16瓶药水，有一瓶是毒药，请问需要多少只小鼠能找到14瓶不是毒药的药水

这个问题可以转换成找两瓶可能带毒药的，由于16瓶药水可以表示成 xxxx 的形式，所以只需要确定前面3位就能找到可能带毒药的；先相邻两位混合成共8瓶药水，用3只小鼠测试即可。




## 查找表

查找表是一个数组，一般事先计算好查找表，在后续使用时直接在查找表中索引即可，可以加速运算。

如计算DFT时，事先将旋转因子$W_N^{kn}$计算好，对于长度为 N 的DFT，查找表需要存储 N 个复数（$W_N^0$，$W_N^1$，...，$W_N^{N-1}$）


### 计算整数的二进制中1的个数

如 9 的二进制为 1001， 1的个数为2

简单的算法如下：

```python
def  countSetBits(n):
    count = 0
    while (n):
        count += n & 1
        n >>= 1
    return count
```

时间复杂度为 log(n)

使用查找表可以将时间复杂度降为1，查找表是一个256位的数组，存储0-255这256个数字中1的个数

```python
BitsSetTable256 = [0] * 256

# Function to initialise the lookup table 
def initialize():
	
	# To initially generate the 
	# table algorithmically 
	BitsSetTable256[0] = 0
	for i in range(256):
		# 如果最后一位为0，那么向右移动一位，1 的个数不变
		# 如果最后一位不为0，那么向右移动一位，1 的个数减1
		BitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2] 
```

有了查找表后，对于1个32位的整数 n，只需要将整数 n 的二进制分成四段（注意每一段需要移动到最后8位，并且屏蔽之前若干位），分别计算即可

```python
def countSetBits(n):
	return (BitsSetTable256[n & 0xff] +
			BitsSetTable256[(n >> 8) & 0xff] +
			BitsSetTable256[(n >> 16) & 0xff] +
			BitsSetTable256[n >> 24])
```


## 数组问题

数组中存储了数据（C/C++等）或者索引（Python，JS等），数组是连续地址，可以在常数时间完成随机访问


### 第k个最大和连续子序列

找到一个序列中的子序列，使其之和从大到小排在第k位

常规的做法是用 $O(n^2)$  的时间获得所有的子序列之和，然后再排序，时间复杂度为 $O(n^2logn^2)$

可以使用前缀和以及最小堆优化，先计算序列的前缀和保存在数组中，这样子序列之和直接用数组的两个值相减即可。

```python
# Python program to find the K-th largest sum
# of subarray
import heapq

# function to calculate Kth largest element
# in contiguous subarray sum


def kthLargestSum(arr, N, K):

    # array to store prefix sums
    sum = []
    sum.append(0)
    sum.append(arr[0])
    for i in range(2, N + 1):
        sum.append(sum[i - 1] + arr[i - 1])

    # priority_queue of min heap
    Q = []
    heapq.heapify(Q)

    # loop to calculate the contiguous subarray
    # sum position-wise
    for i in range(1, N + 1):

        # loop to traverse all positions that
        # form contiguous subarray
        for j in range(i, N + 1):
            x = sum[j] - sum[i - 1]   # x 为某一段序列之和

            # if queue has less than k elements,
            # then simply push it
            if len(Q) < K:
                heapq.heappush(Q, x)
            else:
                # it the min heap has equal to
                # k elements then just check
                # if the largest kth element is
                # smaller than x then insert
                # else its of no use
                if Q[0] < x:
                    heapq.heappop(Q)
                    heapq.heappush(Q, x)

    # the top element will be then kth
    # largest element
    return Q[0]
```


### 最小子序列之和大于某个值

找到一个子序列，使其和大于某一个值，并且要求这个子序列长度最小。该序列所有值大于等于0。

```python
def smallestSubWithSum(x, arr):

    i, j = 0, 0
    sum = 0
    ans = float('inf')

    while j < len(arr):

        # Expand window until sum > x 
        # or end of array reached
        while j < len(arr) and sum <= x:
            sum += arr[j]
            j += 1

        # If we reached end of array and sum 
        # still <= x, no valid subarray exists
        if j == len(arr) and sum <= x:
            break

        # Minimize window from start 
        # while maintaining sum > x
        while i < j and sum - arr[i] > x:
            sum -= arr[i]
            i += 1

        ans = min(ans, j - i)

        # Remove current start 
        # element and shift window
        sum -= arr[i]
        i += 1

    # Return 0 if no valid subarray
    # found, else return min length
    if ans == float('inf'):
        return 0
    return ans
```


### 找到数组中每一个元素右侧大于自己的数

[Surpasser Count of Each Element in Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-surpasser-count-of-each-element-in-array/)

给定一个包含不同元素的数组，找到数组中在右侧大于自己的数（Surpasser）（$i< j$ 并且 $a[i]<a[j]$），并统计数量。

使用合并排序的思路进行求解

在合并排序中，需要将数组连续二等分，连续分到最后，只有一个值。由于数组中包含的是不同的元素，可以用一个字典保存各个元素的Surpasser的数量。在合并的时候，只需要考虑左侧数组，因为左侧数组在原数组的位置在右侧数组之前，如果左侧数组中的元素小于右侧数组中的某个值，那么之后的全都小于。

```python
# Python program to find the surpasser count of each element
# using merge step of merge sort

def merge(arr, lo, mid, hi, m):
    n1 = mid - lo + 1
    n2 = hi - mid
    left = arr[lo:lo+n1]
    right = arr[mid+1:mid+1+n2]

    i = j = 0
    k = lo

    # Merging two halves
    while i < n1 and j < n2:
      
        # All elements in right[j..n2] are greater than left[i]
        # So add n2 - j, in surpasser count of left[i]
        if left[i] < right[j]:
            m[left[i]] += n2 - j
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1

    # Copy remaining elements of left[] if any
    while i < n1:
        arr[k] = left[i]
        i += 1
        k += 1

    # Copy remaining elements of right[] if any
    while j < n2:
        arr[k] = right[j]
        j += 1
        k += 1

def mergeSort(arr, lo, hi, m):
    if lo < hi:
        mid = lo + (hi - lo) // 2

        # Sort left and right half
        mergeSort(arr, lo, mid, m)
        mergeSort(arr, mid + 1, hi, m)

        # Merge them
        merge(arr, lo, mid, hi, m)

def findSurpasser(arr):
    n = len(arr)
    
    # Map to store surpasser counts
    m = {key: 0 for key in arr}

    # Duplicate array to perform merge Sort
    # so that original array is not modified
    dup = arr[:]
    
    mergeSort(dup, 0, n - 1, m)
    
    # Store surpasser counts in result array
    # in the same order as given array
    res = [m[arr[i]] for i in range(n)]
    
    return res
```


> 如果是统计右侧小于自己的数，可以改成从大到小排

> 如果数组中包含重复元素，那么还需要有一个指数数组，或者更简单的，将数组改成 (num,  i) 这种形式，如下所示

```python
for i, a in enumerate(arr):
	m[(a, i)] = 0
	dup.append((a, i))
```


### 统计数组中前k个经常出现的元素

[Top K Frequent Elements in an Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-k-numbers-occurrences-given-array/)
一般做法是先统计频次，再排序

一种更好的方法是先统计频次，再使用一个最大堆来存储前k个频次最大的元素

```python
def topKFrequent(arr, k):

    # Dictionary 'mp' implemented as frequency hash
    # table
    mp = Counter(arr)

    pq = []
    
    for key, value in mp.items():
        heapq.heappush(pq, (value, key))
        if len(pq) > k:
            heapq.heappop(pq)

    # store the result
    res = []
    
    while pq:
        res.append(heapq.heappop(pq)[1])

    res.reverse()
    return res
```

### 找到数据流中的中位数

给定一个数据流，如何找到中位数，假设有偶数个数，那么需要对中间两个进行平均。

使用堆实现，主要思路是维持两个堆，一个堆存储较小值，另一个堆存储较大值

注意python中只给出了最小堆的实现，最大堆可以通过每次传入数据时加上负号实现。

```python
import heapq

# Function to find the median of a stream of data
def getMedian(arr):
    
    # Max heap to store the smaller half of numbers
    leftMaxHeap = []
    
    # Min heap to store the greater half of numbers
    rightMinHeap = []
    
    res = []
  
    for num in arr:
        # Insert new element into max heap (negating for max behavior)
        heapq.heappush(leftMaxHeap, -num)
        
        # Move the top of max heap to min heap to maintain order
        temp = -heapq.heappop(leftMaxHeap)
        heapq.heappush(rightMinHeap, temp)
      
        # Balance heaps if min heap has more elements
        if len(rightMinHeap) > len(leftMaxHeap):
            temp = heapq.heappop(rightMinHeap)
            heapq.heappush(leftMaxHeap, -temp)
        
        # Compute median based on heap sizes
        if len(leftMaxHeap) != len(rightMinHeap):
            median = -leftMaxHeap[0]
        else:
            median = (-leftMaxHeap[0] + rightMinHeap[0]) / 2.0
        
        res.append(median)
    
    return res
```


### 给定范围内最常出现的整数

两个等长的数组分别给出左端点和右端点，求出这些范围内最常出现的整数

使用difference 数组求解：定义一个diff数组，`diff[left] += 1`，对应的 `diff[right+1] -=1`，这样diff中大于0的表示这里有多少个起点，小于0表示这里有多少个终点，求前缀和时最大值的位置即代表最常出现的数。

```python
MAX = 1000

def maximumOccurredElement(L, R, n):
 
    # Initialising all element of array to 0.
    arr = [0 for i in range(MAX)]
 
    # Adding +1 at Li index and subtracting 1 at Ri index.
    for i in range(0, n, 1):
        arr[L[i]] += 1
        arr[R[i] + 1] -= 1
 
    # Finding prefix sum and index
    # having maximum prefix sum.
    msum = arr[0]
    for i in range(1, MAX, 1):
        arr[i] += arr[i - 1]
        if (msum < arr[i]):
            msum = arr[i]
            ind = i
    return ind
```

该方法还能用于求是否存在重叠边界
[Check if any two intervals intersect in a given set - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-any-two-intervals-overlap-among-a-given-set-of-intervals/)

先求所有边界的最大值 N，初始化一个数组 `arr`，大小为N，对于每个间隔 `[a, b]`，`arr[a]+=1`，`arr[b+1]-=1`，然后求前缀和，如果前缀和中是否存在大于1的，如果有就是重叠

> 这种方法对于范围较大的数据而言，还是比较耗时的

### 买卖股票

[Stock Buy and Sell - At-most k Transactions Allowed - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-k-times/)


一个数组存储了每天的股票价格，问在给定的交易次数下，所获取的最大利润。该问题有如下三个变体：

1、如果只允许一次交易：最大利润为最大值减去最小值

```python
def maxProfit(prices):
    minSoFar = prices[0]
    res = 0

    # Update the minimum value seen so far 
    # if we see smaller
    for i in range(1, len(prices)):
        minSoFar = min(minSoFar, prices[i])
        
        # Update result if we get more profit                
        res = max(res, prices[i] - minSoFar)
    
    return res
```


2、只允许至多两次交易：

一种做法是直接迭代两次，两个循环的思路和一个循环的基本一致

```python
class Solution:
    
    def maxProfit1(self, idx, arr):
        minP = arr[idx]
        profit = 0
        for i in range(idx + 1, len(arr)):
            if minP < arr[i]:
                profit = max(profit, arr[i] - minP)
            else:
                minP = arr[i]
        return profit
    
    def maxProfit(self, arr):
        # code here
        
        minP = arr[0]
        profit = 0
        
        for i in range(1, len(arr)):
            if minP < arr[i]:
                profit = max(profit, arr[i] - minP + self.maxProfit1(i, arr))
            else:
                minP = arr[i]
        return profit
```

这样时间复杂度过高

另一种方法考虑到最多进行两次交易，因此可以分成两段，即从 0 到 i 进行一次交易，从 i 到 n-1进行一次交易

```python
def maxProfit(arr):
	profit = 0
	profits = [0] * len(arr)
	
	minP = arr[0]
	# 计算从 0 到 i 的利润最大值
	for i in range(1, len(arr)):
		if minP < arr[i]:
			profits[i] = max(profits[i-1], arr[i] - minP) 
			profit = max(profit, profits[i])
		else:
			minP = arr[i]
			profits[i] = profits[i - 1]
	
	maxP = arr[-1]
	# 计算从 n-1 到i的利润最大值
	for j in range(len(arr) - 2, -1, -1):
		if maxP > arr[j]:
			profit = max(profit, maxP - arr[j] + profits[j])  
		else:
			maxP = arr[j]
	
	return profit
```


3、至多k次交易

最一般的方法是使用回溯法（递归），在某一天，只能进行三项操作，分别为买，卖和什么都不做

```python
def _solve(arr, i, k, state):
    if i == len(arr) or k == 0:
        return 0
    profit = 0
    if state == "buy":
        profit = _solve(arr, i + 1, k, state)   # 什么都不做
        profit = max(profit, _solve(arr, i + 1, k, "sell") - arr[i])  
    elif state == "sell":
        profit = _solve(arr, i + 1, k, state)   # 什么都不做
        profit = max(profit, _solve(arr, i + 1, k - 1, "buy") + arr[i])
    return profit

def solve(arr, k):
    profit = _solve(arr, 0, k, "buy")
    print(profit)
```

这种方法时间复杂度过高，存在大量重复计算步骤。

可以通过一个矩阵保存所有情况下的利润，避免重复计算。

```python
def solveProfit(arr, i, k, state, memo):
    if i == len(arr) or k == 0:
        return 0
    profit = 0
    if memo[i][k][state] != -1:
        return memo[i][k][state]
    
    if state == 1:
        profit = solveProfit(arr, i+1, k, state, memo)
        profit = max(profit, solveProfit(arr, i+1, k, 0, memo) - arr[i])
    elif state == 0:
        profit = solveProfit(arr, i+1, k, state, memo)
        profit = max(profit, solveProfit(arr, i+1, k-1, 1, memo) + arr[i])
    
    memo[i][k][state] = max(memo[i][k][state], profit)
    return profit

class Solution:
    
    def maxProfit(self, arr, k):
        # code here
        
        n = len(arr)
        memo = [[[-1]*2 for _ in range(k + 1)]
            for _ in range(n)]
        profit = solveProfit(arr, 0, k, 1, memo)
        return profit
```


另外还有动态规划的方法，这样可以不使用递归

参考上面的递归过程，可以得出动态递归方程为（从后向前）：

```
Buy: dp[i][k][1] = max(dp[i+1][k][1], dp[i+1][k][0] - prices[i])

Sell: dp[i][k][0] = max(dp[i+1][k][0], dp[i+1][k-1][1] + prices[i])
```

这里的dp指的是在第`i`天，有`k`次交易机会，状态为 1（可以买）或 0（可以卖）会得到的收益


### 在一个可以循环移位的序列中找到最大和子序列

首先在一个序列中找到最大和子序列的算法如下

```python
def findMaxSum(arr):
    n = len(arr)
    cur_sum = 0
    max_sum = -1e5
    for i in range(n):
        cur_sum += arr[i]
        max_sum = max(max_sum, cur_sum)
        if cur_sum < 0:
            cur_sum = 0
    return max_sum
```

其思路是求前缀和，如果前缀和小于0，就将前缀和置为0（相当于重新开始一个子序列），重新开始求，前缀和的最大值就是最大和子序列。

对于本问题，由于序列可以循环移位，如果将所有移位的情形全部列举，时间复杂度过高。可以换一种思路，对于循环后的子序列的最大和子序列，其实相当于在原本的子序列中求最小和子序列，求完最小和之后用总和减去最小和即为最大和

```python
def circularSubarraySum(arr):
    ##Your code here
    n = len(arr)
    max_sum1 = findMaxSum(arr)
    
    s_sum = 0
    for i in range(n):
        s_sum += arr[i]
        arr[i] = -arr[i]
    
    min_sum = findMaxSum(arr)
    max_sum2 = s_sum + min_sum
    
    return max(max_sum1, max_sum2)
```




## 哈希问题

哈希最大的特点是可以实现常数时间搜索、插入和删除，主要用于实现不相等的元素，如键值对。

### 子集问题

问一个集合 m 是否包含了另一个集合 n

1、最简单的是直接暴力搜索
2、先排序再搜索（使用自带的高效排序方法）
3、使用哈希

实现方式

```python
def isSubset(a, b):

    # Create a hash set and insert all elements of arr1
    hash_set = set(a)

    # Check each element of arr2 in the hash set
    for num in b:
        if num not in hash_set:
            return False

    # If all elements of arr2 are found in the hash set
    return True
```


### 两数之和

在一个序列找到两个数和为目标值

一种常规做法是先排序，再用两个指针进行索引

哈希算法可以在一次迭代中找到：先按顺序选择一个值，然后看目标值减去这个值后的结果是否在集合里即可

为了找出所有的pair使得两数之和为目标值，还需要一个字典来记录序列中每个值出现的次数

```python
def countPairs(arr, target):
    freq = {}
    cnt = 0

    for i in range(len(arr)):
        
        # 仅考虑之前点和当前点是否能组成成对关系
        if (target - arr[i]) in freq:
            cnt += freq[target - arr[i]] 
        
        # 统计当前点及其之前点的频数
        freq[arr[i]] = freq.get(arr[i], 0) + 1 
    return cnt
```

这里的频率更新需要放在计数之后，放在前面则会导致如果 `arr[i]`和 `target-arr[i]` 相等会导致同一个位置相加。




### 三数之和

在一个序列找到三个数之和为目标值

先在外部循环确定好一个值，然后在内部循环时按照二数之和求

```python
def countTriplets(arr, target):
    cnt = 0
    n = len(arr)
    
    for i in range(n-2):
    # 先确定好 arr[i]
    # 内部循环按照二数之和求解
        freq = {}
        for j in range(i+1, n):
            if target - arr[i] - arr[j] in freq:
                cnt += freq[target - arr[i] - arr[j]]
            freq[arr[j]] = freq.get(arr[j], 0) + 1

    return cnt
```


为了节省空间，还可以先排序，先在外侧循环确定第一个数，再使用两个指针确定第2个和第3个数

```python
def threeSum(arr, target):
	n = len(arr)
	arr.sort()
	sols = []
	for i in range(n):
		# arr[i-1] 之前已经找过了，避免重复
		if i > 0 and arr[i] == arr[i-1]:
			continue
		
		l = i + 1  # 第二个数
		r = n - 1 # 第三个数
		
		while l < r:
			s = arr[i] + arr[l] + arr[r]
			if s == target:
				sols.append([arr[i], arr[l], arr[r]])
				l += 1
				r -= 1
				
				# 避免重复
				while l < r and arr[l] == arr[l-1]:
					l += 1
				
				while r > l and arr[r] == arr[r+1]:
					r -= 1
			
			elif s < target:
				l += 1
			else:
				r -= 1
			
	return sols
```


### 四数之和

对于四数之和，可以采用上面的思路，先确定两个值，再在内部循环时按照二数之和求解

还有另外一种思路，只在外部循环中确定第3个数的值，在频数中保存前两个数之和，然后循环第四个数

```python
def countSum(arr, target):
	#code here
	freq = {}
	n = len(arr)
	cnt = 0
	# 确定第三个数的值
	for i in range(n-1):
		# 这是第四个数
		for j in range(i+1, n):
			temp = arr[i] + arr[j]   # 三四两个数之和
			if target - temp in freq:
				cnt += freq[target - temp]
		
		# 此处更新前两个数之和，再遍历下一个i之前，需要更新i之前的可能对之和
		for j in range(i):
			temp = arr[i] + arr[j]
			freq[temp] = freq.get(temp, 0) + 1
	return cnt
```

如果只需要判断四数之和是否存在，还有另外一种思路

[4 Sum - Check if a Quadruple with given Sum Exists in an Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-four-numbers-with-sum-equal-to-given-sum/)

先计算前两个数字之和，将其作为键保存在字典里，对应的值为两个数字的坐标索引。再计算后两个数字之和，看目标减去这两个数字之和的结果是否位于字典里。

```python
def check4Sum(arr, target):
    n = len(arr)

    # Store sums of all pairs in a hash map
    mp = {}
    for i in range(n - 1):
        for j in range(i + 1, n):
            mp[arr[i] + arr[j]] = (i, j)

    # Traverse through all pairs and search for 
    # target - (current pair sum)
    for i in range(n - 1):
        for j in range(i + 1, n):
            sum_val = arr[i] + arr[j]

            # If target - sum is present in the hash map
            if target - sum_val in mp:
                p = mp[target - sum_val]

                # Check that all elements are different array elements 
                if p[0] != i and p[0] != j and p[1] != i and p[1] != j:
                    return True

    return False
```




### 最长子序列之和被K整除

对于一个序列，找到其中的一个最长子序列，使其之和能被 K 整除

使用一个hash（实际上是字典）保存前缀和及其对应位置

```python
# Python Code to find longest Subarray With Sum Divisible
# By K using Prefix Sum and Hash map

def longestSubarrayDivK(arr, k):
    n = len(arr)
    res = 0
    prefIdx = {}
    sum = 0

    # Iterate over all ending points
    for i in range(n):

        # prefix sum mod k 
        sum = (sum + arr[i]) % k

        # If sum == 0, then update result with the
        # length of subarray arr[0...i]
        if sum == 0:
            res = i + 1

        # Update max length for repeating sum
        elif sum in prefIdx:
            res = max(res, i - prefIdx[sum])

        # Store the first occurrence of sum
        else:
            prefIdx[sum] = i

    return res
```

存储所有前缀和出现的位置，这样如何再次出现这个前缀和，就证明这两个前缀和中间的序列之和能被 K 整除。


### 最长子序列之和为 K

与上一个题目类似，使用一个字典保存前缀和，然后判断当前和减去目标值的结果是否在前缀和字典中。

```python
def subarraySum(arr, target):
	# code here
	n = len(arr)
	prefixs = {}
	s = 0
	for i in range(n):
		s += arr[i]
		
		if s == target:
			return [1, i+1]
		
		if s - target in prefixs:
			return [prefixs[s - target]+1, i+1]
		
		prefixs[s] = i+1
	return [-1]
```


### 找到所有的序列对(a,b)使得 a%b = k

首先进行如下分析

$$
\eqalign{
  & a\% b = k  \cr 
  & a = n*b + k  \cr 
  & a - k = n*b \cr} 
$$
因此只需要找到 a-k 的因子即可，因子分解的算法如下

```python
def findDivisors(n):
    v = []

    # Vector is used to store the divisors
    for i in range(1, mt.floor(n**(.5)) + 1):
        if (n % i == 0):
            
            # If n is a square number, push only one occurrence
            if (n / i == i):
                v.append(i)
            else:
                v.append(i)
                v.append(n // i)
    return v
```

注意不是所有的因子都可以，需要测试一下。

```python
def printPairs(arr, k):
	n = len(arr)
	ans = 0
	occ = {}

	# creating a hashmap to store occurrence of array elements
	for num in arr:
		occ[num] = True

	isPairFound = False

	# iterating through the array elements
	for num in arr:
		# if k is in the array and k is smaller than num
		if k in occ and k < num:
			ans += 1
			isPairFound = True

		# if num is greater than or equal to k
		if num >= k:
			divisors = findDivisors(num - k)
			for divisor in divisors:
				# if num modulo divisor is equal to k, num is not equal to divisor
				# and divisor exists in the hashmap
				if num % divisor == k and num != divisor and divisor in occ:
					ans += 1
					isPairFound = True

	return ans
```


### 找到包含所有不重复元素的子序列

对于一个序列，其中一些元素是重复的，找到包含所有不重复元素的子序列

一般的做法是，通过两个循环，外部循环遍历序列左端，内部序列遍历序列的右端，判断是否存在所有的不重复元素

利用滑动窗口解决这一问题

只使用一个循环来遍历序列左端，通过一个字典来记录窗口内所有元素的出现频次，通过一个遍历记录窗口内不重复元素的数量。

如果窗口大小等于不重复元素数量，那么右端所有的子序列都包含了所有不重复元素

```python
def countDistinctSubarray(self,arr, n): 
	#code here.
	uset = set(arr)
	k = len(uset)  # 不重复元素的数量
	window = 0  # 记录窗口内不重复元素的数量
	vid = {}  # 记录窗口内各个值出现频次
	right = 0
	cnt = 0
	for left in range(n):
		while right < n and window < k:
			vid[arr[right]] = vid.get(arr[right], 0) + 1
			
			# 窗口内出现了新元素
			if vid[arr[right]] == 1:
				window += 1
			right += 1

		if window == k:
			cnt += n - right + 1

		# 窗口左侧将要缩小，失去最左侧元素
		vid[arr[left]] -= 1
		
		# 窗口将要失去一个新元素
		if vid[arr[left]] == 0:
			window -= 1
	return cnt
```

### 多数元素大于K的最长子序列

[Longest Subarray having Majority Elements Greater Than K - GeeksforGeeks](https://www.geeksforgeeks.org/length-of-longest-subarray-in-which-elements-greater-than-k-are-more-than-elements-not-greater-than-k/?ref=rp)

给定一个序列，在这个序列中找到一个最长子序列，要求子序列中的多数元素大于k。

建立一个辅助序列，原序列中大于k的元素记为1，否则记为-1，并且计算这个辅助序列的前缀和，前缀和的范围为 `[-n,n]`。对于序列 `arr[0:i]` 的前缀和 s，我们需要找到在 `i` 之前最左侧的比 s 还小的前缀和，这里如果每次都去求一次最小的前缀和显然太麻烦了，因此可以创建一个数组 `prefidx` 记录每个前缀和首次出现的位置，并且每个前缀和出现的位置都取前面最小的，这样便可以直接通过 `prefidx[s-1]` 的位置找到前面最小的。

```python
def longestSubarray(arr, k):
	# Code Here
	n = len(arr)
	preidx = {}
	s = 0
	for i in range(n):
		if arr[i] > k:
			s += 1
		else:
			s -= 1
		if s not in preidx:
			preidx[s] = i
	
	if -n in preidx:
		return 0
	
	preidx[-n] = n

	# 记录每个小于等于前缀和 i 的前缀和出现的最早的位置
	for i in range(-n+1, n+1):
		if i not in preidx:
			preidx[i] = preidx[i-1]
		else:
			preidx[i] = min(preidx[i], preidx[i - 1])
	
	s = 0
	res = 0
	for i in range(n):
		if arr[i] > k:
			s += 1
		else:
			s -= 1
		if s > 0:
			res = i + 1
		else:
			res = max(res, i - preidx[s - 1])
	return res
```


### 找到包含K个不同元素的最小序列

[Smallest subarray with k distinct numbers - GeeksforGeeks](https://www.geeksforgeeks.org/smallest-subarray-k-distinct-numbers/)

给定一个序列，找到一个包含K个不同元素的最小序列，使用滑动窗口解决这一问题

```python
from collections import defaultdict

def minRange(arr, n, k): 

	# Initially left and right side is -1 
	# and -1, number of distinct elements 
	# are zero and range is n. 
	l, r = 0, n 
	i = 0
	j = -1 # Initialize right side 
	
	hm = defaultdict(lambda:0) 
	while i < n: 
	
		while j < n: 
		
			# increment right side. 
			j += 1

			# if number of distinct elements less than k. 
			if len(hm) < k and j < n:
				hm[arr[j]] += 1

			# if distinct elements are equal to k 
			# and length is less than previous length. 
			if len(hm) == k and ((r - l) >= (j - i)):
				l, r = i, j 
				break

		# if number of distinct elements less 
		# than k, then break. 
		if len(hm) < k:
			break

		# if distinct elements equals to k then 
		# try to increment left side. 
		while len(hm) == k: 

			if hm[arr[i]] == 1: 
				del(hm[arr[i]]) 
			else:
				hm[arr[i]] -= 1

			# increment left side. 
			i += 1

			# it is same as explained in above loop. 
			if len(hm) == k and (r - l) >= (j - i): 
			
				l, r = i, j 
		
		if hm[arr[i]] == 1: 
			del(hm[arr[i]]) 
		else:
			hm[arr[i]] -= 1
			
		i += 1

	if l == 0 and r == n:
		print("Invalid k") 
	else:
		print(l, r) 

# Driver code for above function. 
if __name__ == "__main__": 

	arr = [1, 1, 2, 2, 3, 3, 4, 5] 
	n = len(arr) 
	k = 3
	minRange(arr, n, k) 
```


### 分数简化显示

[Fraction to Recurring Decimal - GeeksforGeeks](https://www.geeksforgeeks.org/represent-the-fraction-of-two-numbers-in-the-string-format/)

考虑两个数 a 和 b，`rem=a%b` 是余数，我们用一个字典记录rem首次出现时的结果字符串长度，如果rem能再次出现，那么结果字符串就是首次出现之前的字符串加上括号加之后的字符串

```python
# Python Program to convert fraction to string

def calculateFraction(a, b):
  
    # If the numerator is zero, answer is "0"
    if a == 0:
        return "0"
        
    res = "-" if (a < 0) ^ (b < 0) else ""

    a = abs(a)
    b = abs(b)

    # Calculate and Append the part before decimal point
    res += str(a // b)

    rem = a % b

    # If completely divisible, return res
    if rem == 0:
        return res

    res += "."
    mp = {}

    while rem > 0:
      
        # If this remainder is already seen,
        # then there exists a repeating fraction.
        if rem in mp:
            res = res[:mp[rem]] + "(" + res[mp[rem]:] + ")"
            break
        
        # If the remainder is seen for the first time,
        # store its index
        mp[rem] = len(res)

        rem = rem * 10
        # Calculate quotient, append it to result and
        # calculate next remainder
        res += str(rem // b)
        rem = rem % b

    return res
```


### 最长双调序列

[Longest Bitonic Subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/)

在一个序列中找到最长的双调序列，双调序列指严格的先增加后减小

如果严格增加1或减小1，有更简单的解决方法

[Length of longest strict bitonic subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/length-longest-strict-bitonic-subsequence/)


### 找到相同的子树

[Find All Duplicate Subtrees - GeeksforGeeks](https://www.geeksforgeeks.org/find-duplicate-subtrees/)

给定一个树，找到树中相同的子树（包括结构和值）

采用中序遍历，将每个节点的遍历结果变成字符串保存在字典中，看是否有相同的字符串。

```python
def inorder(node, m, res):
	if not node:
		return ""
	_str = "("
	_str += inorder(node.left, m, res)
	_str += str(node.data)
	_str += inorder(node.right, m, res)
	_str += ")"
	
	if _str in m and m[_str] == 1:
		res.append(node)
	
	if _str in m:
		m[_str] += 1
	else:
		m[_str] = 1
	return _str

def printAllDups(root):
	m = {}
	res = []
	inorder(root, m, res)
	return res
```


### 找到角点均为1的矩阵

[Find if there is a rectangle in binary matrix with corners as 1 - GeeksforGeeks](https://www.geeksforgeeks.org/find-rectangle-binary-matrix-corners-1/)



## 搜索问题

搜索分为线性搜索，二分搜索和双指针技术

线性搜索主要用于未排序的列表、小数据、链表等。线性搜索往往需要在每一次循环中进行一次条件判断，可以在列表的末尾添加目标值，这样直接用while

```python
def sentinelSearch(arr, n, key):

    # Last element of the array
    last = arr[n - 1]

    # Element to be searched is
    # placed at the last index
    arr[n - 1] = key
    i = 0

    while (arr[i] != key):
        i += 1

    # Put the last element back
    arr[n - 1] = last

    if ((i < n - 1) or (arr[n - 1] == key)):
        print(key, "is present at index", i)
    else:
        print("Element Not found")
```

二分搜索实现如下，需要数据排好序，或者有一定的规律

```python
def binarySearch(arr, low, high, x):

    while low <= high:

        mid = low + (high - low) // 2

        # Check if x is present at mid
        if arr[mid] == x:
            return mid

        # If x is greater, ignore left half
        elif arr[mid] < x:
            low = mid + 1

        # If x is smaller, ignore right half
        else:
            high = mid - 1

    # If we reach here, then the element
    # was not present
    return -1
```

>如果是一个无限的有序数组，可以采用自定义边界的方法，如
>第一轮搜索 [0, 1]
>第二轮搜索 [1, 2]
>第三轮搜索 [2, 4]
>第四轮搜索 [4, 8]

双指针技术用两个指针同时索引，一般一个位于开始，另一个位于末尾，并且对于数据有一定的排序要求。

二分搜索的实现：

C++

```cpp
// C++ code to show how to use the binary_search()
// for searching an element in the given range
#include <bits/stdc++.h>
using namespace std;

// Function for check an element whether it
// is present or not
void isPresent(vector<int> &arr, int val) {
  
    // using binary_search to check if val exists
    if (binary_search(arr.begin(), arr.end(), val))
        cout << val << " exists in vector";
    else
        cout << val << " does not exist";

    cout << endl;
}

int main() {
    vector<int> arr = {10, 15, 20, 25, 30, 35};

    int val1 = 15;
    int val2 = 23;

    isPresent(arr, val1);
    isPresent(arr, val2);

    return 0;
}
```

Python 的bisect包提供了二分搜索并插入

```python
# Python code to demonstrate the working of
# bisect(), bisect_left() and bisect_right()

# importing "bisect" for bisection operations
import bisect

# initializing list
li = [1, 3, 4, 4, 4, 6, 7]

# using bisect() to find index to insert new element
# returns 5 ( right most possible index )
print ("Rightmost index to insert, so list remains sorted is : ",
	end="")
print (bisect.bisect(li, 4))

# using bisect_left() to find index to insert new element
# returns 2 ( left most possible index )
print ("Leftmost index to insert, so list remains sorted is : ", 
	end="")
print (bisect.bisect_left(li, 4))

# using bisect_right() to find index to insert new element
# returns 4 ( right most possible index )
print ("Rightmost index to insert, so list remains sorted is : ",
	end="")
print (bisect.bisect_right(li, 4, 0, 4))
```


### 三分搜索

```python
def ternarySearch(l, r, key, ar):
    while r >= l:
        
        # Find mid1 and mid2
        mid1 = l + (r-l) // 3
        mid2 = r - (r-l) // 3

        # Check if key is at any mid
        if key == ar[mid1]:
            return mid1
        if key == ar[mid2]:
            return mid2

        # Since key is not present at mid, 
        # Check in which region it is present
        # Then repeat the search operation in that region
        if key < ar[mid1]:
            # key lies between l and mid1
            r = mid1 - 1
        elif key > ar[mid2]:
            # key lies between mid2 and r
            l = mid2 + 1
        else:
            # key lies between mid1 and mid2
            l = mid1 + 1
            r = mid2 - 1

    # key not found
    return -1
```


### 在未排序的数组中找到第K个最小的数

1、先排序再找，时间复杂度为 nlog(n)，空间复杂度为 1
2、用最大堆保存K个数，时间复杂度为 nlog(K)，空间复杂度为 K
3、快速选择算法，虽然最差情况下时间复杂度为 $n^2$，但是实践使用时是快的。

快速选择算法基于快速排序算法，partition的部分一致，只是在后续搜索时有差别，当找到pivot的位置时，比较该位置左侧是否包含了k-1个数，如果包含了，那么pivot就是需要的数，如果左侧大于k-1个数，就在左侧找，否则在右侧找。

```python
def kthSmallest(arr, l, r, k):

    # if k is smaller than number of
    # elements in array
    if (k > 0 and k <= r - l + 1):

        # Partition the array around last
        # element and get position of pivot
        # element in sorted array
        index = partition(arr, l, r)

        # if position is same as k
        if (index - l == k - 1):
            return arr[index]

        # If position is more, recur 
        # for left subarray 
        if (index - l > k - 1):
            return kthSmallest(arr, l, index - 1, k)

        # Else recur for right subarray 
        return kthSmallest(arr, index + 1, r, 
                            k - index + l - 1)
    print("Index out of bound")
```

### 在循环移位后的排序数组中搜索

对于一个排好序的数组，如果进行了部分循环移位，在这种数组进行搜索

1、使用两次二分搜索，第一次搜索最小值的位置，再根据最小值的位置进行二分搜索
2、在上面搜索最小值时，已经用了这样的原理，即mid左侧或者右侧的数组必定有一侧是排好序的，如对于左侧，只要 `arr[low]<arr[mid]` 那么就是排好序的，如果key落在`arr[low]` 和 `arr[high]` 这个范围之内，就在左侧找，反之就在右侧找。 


### 在三个排好序的数组中找到最相近的数

有三个已经排好序的数组，现在要找到三个数组中最相近的三个数

使用三个指针分别索引这三个数组，每次会索引到三个数，求出这三个数中的最大值和最小值，然后计算最大值和最小值之间的差值，每次循环时只更新最小值对应的数组索引。

```python
def findCloset(A, B, C, p, q, r):
    diff = 1e9
    res_i = 0
    res_j = 0
    res_k = 0
    # Traverse Array
    i = 0
    j = 0
    k = 0
    while(i < p and j < q and k < r):
        # Find minimum and maximum of current three elements
        minimum = min(A[i], min(B[j], C[k]))
        maximum = max(A[i], max(B[j], C[k]));
 
        # Update result if current diff is
        # less than the min diff so far
        if maximum-minimum < diff:
            res_i = i
            res_j = j
            res_k = k
            diff = maximum - minimum;

        if diff == 0:
            break
            
        # Increment index of array with smallest value
        if A[i] == minimum:
            i = i+1
        elif B[j] == minimum:
            j = j+1
        else:
            k = k+1
```


### 求两个相同大小的有序数组合并后的中位数

https://www.geeksforgeeks.org/median-of-two-sorted-arrays

一种方法是使用归并排序中的归并方法

另一种方法是使用二分搜索

这里的二分搜索需要利用到中位数的一个性质，对于一个长度为 2n 的数组，中位数之前需要有n-1个数，因此如果确定了一个数组的mid，另一种数组的mid可以设置为 n-mid，这里的mid并不指一个元素，而是两个元素之间的边界，mid两边的元素分为记为`l`和`r`，只要满足两个数组的 `l` 和 `r` 相互交叉即可。

```python
def getMedian(a, b):
    n = len(a)
    
    # We can take [0...n] number of elements from a[]
    low, high = 0, n
    
    while low <= high:
      
        # Take mid1 elements from a
        mid1 = low + (high - low) // 2
        
        # Take mid2 elements from b
        mid2 = n - mid1
        
        # Find elements to the left and right of partition in a
        l1 = float('-inf') if mid1 == 0 else a[mid1 - 1]
        r1 = float('inf') if mid1 == n else a[mid1]
        
        # Find elements to the left and right of partition in b
        l2 = float('-inf') if mid2 == 0 else b[mid2 - 1]
        r2 = float('inf') if mid2 == n else b[mid2]
        
        # If it is a valid partition
        if l1 <= r2 and l2 <= r1:
            return (max(l1, l2) + min(r1, r2)) / 2.0
        
        # If we need to take fewer elements from a
        if l1 > r2:
            high = mid1 - 1
            
        # If we need to take more elements from a
        else:
            low = mid1 + 1
    
    return 0
```


### 在一个几乎排好序的数组中搜索

已有一个几乎排好序的数组，`arr[i]` 只会和 `arr[i-1]` 或者 `arr[i+1]` 交换位置

可以使用二分查找，不过需要考虑 mid, mid - 1 和 mid + 1三个位置，在判断mid-1和mid+1时，还需要注意不能让其超出`l`和 `r`

```python
def binarySearch(arr, l, r, x):

    if (r >= l):

        mid = int(l + (r - l) / 2)

        # If the element is present at one
        # of the middle 3 positions
        if (arr[mid] == x):
            return mid
        if (mid > l and arr[mid - 1] == x):
            return (mid - 1)
        if (mid < r and arr[mid + 1] == x):
            return (mid + 1)

        # If element is smaller than mid, then
        # it can only be present in left subarray
        if (arr[mid] > x):
            return binarySearch(arr, l, mid - 2, x)

        # Else the element can only
        # be present in right subarray
        return binarySearch(arr, mid + 2, r, x)

    # We reach here when element
    # is not present in array
    return -1
```


## 排序问题


对于链表，归并排序往往比较好


### 排序方法


#### 选择排序

从未排序的数组中找到最小（或最大）的元素放在开始，时间复杂度为 $O(n^2)$，内存占用率很低

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):

        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                # Update min_idx if a smaller element is found
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```


#### 冒泡排序

两次遍历，内部遍历时，如果当前值大于下一个值就交换位置

```python
def bubbleSort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        swapped = False

        # Last i elements are already in place
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if (swapped == False):
            break
```


#### 插入排序

从数组的第二个元素开始，找到其在前面应该所处的位置。

```python
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        # Move elements of arr[0..i-1], that are
        # greater than key, to one position ahead
        # of their current position
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
```


#### 堆排序

将数组看成是完全二叉树，对于一个长度为n的数组，根节点位于0，i 节点的左节点位于2i+1，右节点位于2i+2。

然后创建一个最大堆：保证父节点比子节点大，如果子节点比父节点大，就交换子节点和父节点。

将最大的元素与未排序的数组最后一位交换，然后继续创建最大堆

下面是实现

```python
def heapify(arr, n, i):
    largest = i     # 根节点
    l = 2 * i + 1   # 左子节点
    r = 2 * i + 2   # 右子节点

    if l < n and arr[l] > arr[largest]:
        largest = l
    
    if r < n and arr[r] > arr[largest]:
        largest = r
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)   # 继续排列下面的节点

def heapSort(arr):
    n = len(arr)
    # 从最下层开始
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
```



#### 快速排序

对于一个序列，先选定一个值作为pivot，将数组排列成pivot右侧的值都大于等于pivot，左侧的值都小于等于pivot。

具体排列方法如下

首先选定一个pivot，一般选定子数组的左端，该位置记为index，另外分别从子数组的左端（记为left）和右端（记为right）向中间进发，先从右端开始。

从右端开始遍历，如果`arr[right]` 比pivot大，继续遍历，如果`arr[right]`小于 pivot，令`arr[index]` 等于`arr[right]`，然后将right这个位置记为新的index。

右端暂时遍历完后，从左端开始遍历，同样的如果`arr[left]` 大于pivot，令 `arr[index]` 等于 `arr[left]`，然后将left这个位置记为新的index。

如此循环下去，直到left大于right，循环结束之后，令`arr[index]`等于pivot。

```python
def partition(arr, l, r):

    i = l
    j = r

    pivit = arr[l]
    index = l
    while i < j:
        while j > i:
            if arr[j] < pivit:
                arr[index] = arr[j]
                index = j
                break
            j -= 1
        
        while j > i:
            if arr[i] > pivit:
                arr[index] = arr[i]
                index = i
                break
            i += 1
    arr[index] = pivit
    return index

def quickSort(arr, l, r):
    if l < r and l >= 0:

        idx = partition(arr, l, r)

        quickSort(arr, l, idx-1)
        quickSort(arr, idx+1, r)
    
arr = [ 1, 3, 2, 0, 8 ]
n = len(arr)
quickSort(arr, 0, n-1)
```

对于已经排好序的数组，会出现时间复杂度为 $O(n^2)$ 的情况，为了避免这种情况，可以随机选择pivot，并将其移到数组最左端

```python
index = random.randint(l, r)
pivit = arr[index]
arr[index], arr[l] = arr[l], arr[index]
index = l 
```

对于数组包含大量重复元素的情况，可以在进行递归前进行判断（需要partition函数返回pivot）

```python
idx, pivit = partition(arr, l, r)
li = idx - 1
ri = idx + 1

while li > l and arr[li] == pivit:
	li -= 1
while ri < r and arr[ri] == pivit:
	ri += 1

quickSort(arr, l, li)
quickSort(arr, ri, r)
```

partition 函数的另外一种写法

```python
def partition(arr, l, r):
    x = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= x:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            
    arr[i], arr[r] = arr[r], arr[i]
    return i
```


#### 基数排序

基数排序是一种非比较的排序方法，对每一位进行排序，先对低位排序，然后收集起来（即计数排序），再按照高位排序，直至最高位

```python
def countingSort(arr, exp1):

    n = len(arr)
    # The output array elements that will have sorted arr
    output = [0] * (n)

    # initialize count array as 0
    count = [0] * (10)

    # Store count of occurrences in count[]
    for i in range(0, n):
        index = arr[i] // exp1
        count[index % 10] += 1

    # Change count[i] so that count[i] now contains actual
    # position of this digit in output array
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    i = n - 1
    while i >= 0:
        index = arr[i] // exp1
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    # Copying the output array to arr[],
    # so that arr now contains sorted numbers
    i = 0
    for i in range(0, len(arr)):
        arr[i] = output[i]

# Method to do Radix Sort

def radixSort(arr):

    # Find the maximum number to know number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead
    # of passing digit number, exp is passed. exp is 10^i
    # where i is current digit number
    exp = 1
    while max1 / exp >= 1:
        countingSort(arr, exp)
        exp *= 10
```

>基数排序可以用于解决计数排序面对数字范围过大时的问题



#### 桶排序

比较适用于分布均匀的数组，将数组分在若干个桶内，对于每个桶内的数据进行排序，再将桶内的数据排在一起。


### 两种类型数组排序

用两个指针，分别指向开始和末尾，如果左侧为0，就增加左指针，右侧为1，就减小右指针。然后交换左右指针对应的位置。

```python
def segregate0and1(arr):
    lo, hi = 0, len(arr) - 1
    while lo < hi:
        while arr[lo] == 0 and lo < hi:
            lo += 1
        while arr[hi] == 1 and lo < hi:
            hi -= 1
        if lo < hi:
            arr[lo], arr[hi] = arr[hi], arr[lo]
            lo += 1
            hi -= 1
```

或者另一种方法，见下面分割奇偶数

```python
def segregateevenandodd(arr):
    l = 0
    r = len(arr) - 1

    while l < r:
        if arr[l] & 1 == 0:
            l += 1
        else:
            arr[l], arr[r] = arr[r], arr[l]
            r -= 1
    m = e + 1 if (arr[e] & 1) == 0 else e  # m 位置为偶数
```

### 将数组排序为波形

给定一个未排序的数组，将其排序为 `arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4]` 这种情况

一种简单的算法为先排序，再交换相邻位置的元素

另一种算法：只需要考虑偶数位的元素，使其大于相邻的奇数位元素即可。

```python
def sortInWave(arr, n):

    # Traverse all even elements
    for i in range(0, n , 2):

        # If current even element is smaller than previous
        if (i > 0 and arr[i] < arr[i-1]):
            arr[i], arr[i-1] = arr[i-1], arr[i]

        # If current even element is smaller than next
        if (i < n-1 and arr[i] < arr[i+1]):
            arr[i], arr[i+1] = arr[i+1], arr[i]
```


### 排序多个机器上的数组

[Sort numbers stored on different machines - GeeksforGeeks](https://www.geeksforgeeks.org/sort-numbers-stored-on-different-machines/)

给定N个数组，每个机器保存了一些已经排好序的数组，但是数组长度不固定，现在需要排序所有机器中的数组。

每个机器上的数据流可以看成一个链表，可以使用一个最小堆来实现。

首先用一个容量为 N 的最小堆来存储N个机器上的链表头，从最小堆中取出最小值，将最小堆的头更新为最小值对应的链表中的下一个值，如果该链表已经空了，最小堆中的最后一个链表头移动过去。重复上述步骤直到最小堆为空。

```python
def extract_min(min_heap: MinHeap):
    if is_empty(min_heap):
        return None
    temp = min_heap.array[0][0]
    if temp.next is not None:
        min_heap.array[0] = (temp.next, min_heap.array[0][1])
    else:
        min_heap.array[0] = min_heap.array[min_heap.count - 1]
        min_heap.count -= 1
    
    min_heapify(min_heap, 0)
    return temp
```

使用python自带的heapq实现

```python
import heapq

class ListNode:
    def __init__(self, data, next = None):
        self.data = data
        self.next = next

def push(head, ndata):
    new_node = ListNode(ndata)
    new_node.next = head
    head = new_node
    return head

def merge_lists(lists):
    min_heap = []
    for li in lists:
        heapq.heappush(min_heap, (li.data, li))
    return min_heap

def external_sort(array, n):
     # Create a min heap of size equal to number of machines
    min_heap = merge_lists(array)

    while min_heap:
        data, node = heapq.heappop(min_heap)
        print(data, end=" ")
        if node.next != None:
            heapq.heappush(min_heap, (node.next.data, node.next))

if __name__ == '__main__':
    N = 3  # Number of machines
    array = [None] * N

    # an array of pointers storing the head nodes of the linked lists
    array[0] = None
    array[0] = push(array[0], 50)
    array[0] = push(array[0], 40)
    array[0] = push(array[0], 30)

    # Create a Linked List 35->45 for second machine
    array[1] = None
    array[1] = push(array[1], 45)
    array[1] = push(array[1], 35)

    # Create Linked List 10->60->70->80 for third machine

    array[2] = None
    array[2] = push(array[2], 100)
    array[2] = push(array[2], 80)
    array[2] = push(array[2], 70)
    array[2] = push(array[2], 60)
    array[2] = push(array[2], 10)

    external_sort(array, N)
```


### 按照二进制中1的数量排序


一种简单的方法是调用库函数

```python
def countBits(a):
    count = 0
    while (a):
        if (a & 1 ):
            count += 1
        a = a>>1
    return count

arr.sort(key= countBits, reverse=True)
```

还有利用计数排序的方法，即对于数组中的每个元素计算1的个数，然后按照1的个数出现次数包括每个元素。

### 让数组各元素均不同的最小增加量

给定一个数组，希望通过给一些元素加1，来使所有元素都不同

一种简单的方法是先排序，再比较前一个元素和后一个元素，始终保持后一个元素比前一个元素大1。

```python
def minIncrements(arr): 
	# Code here
	cnt = 0
	
	arr.sort()
	n = len(arr)
	
	for i in range(1, n):
		if arr[i] <= arr[i-1]:
			cnt += (arr[i-1] - arr[i]) + 1
			arr[i] = arr[i-1] + 1
	return cnt
```


另一种方法是使用一个频率数组记录原数组中所有元素的出现次数，然后只需要让所有元素的出现次数小于等于1即可。

```python
def minIncrements(arr): 
	# Code here
	max_value = max(arr) + 1
	
	freq = [0] * max_value
	
	for i in range(len(arr)):
		freq[arr[i]] += 1
	
	cnt = 0
	
	for i in range(max_value-1):
		if freq[i] > 1:
			cnt += freq[i] - 1
			freq[i+1] += freq[i] - 1
	
	while freq[max_value-1] > 1:
		cnt += freq[max_value-1] - 1
		freq[max_value-1] -= 1
	
	return cnt
```

### 火车到达的最少平台问题

https://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station

假设有若干列火车到达某个站点，到达时间为 arr，离站时间为dep，请问该站点最少需要多少个平台

一种方法是先分别对到达时间和离站时间进行排序，然后统计在每辆车来之前有多少辆车走即可

```python
def minimumPlatform(arr,dep):
	n = len(arr)
	arr.sort()
	dep.sort()
	min_plat = 0
	plat = 0
	j = 0
	for i in range(n):
		while j < n and dep[j] < arr[i]:
			j += 1
			plat -= 1   # 一辆车在本辆车来之前离站
		plat += 1   # 一辆车来了
		min_plat = max(min_plat, plat)
	return min_plat
```

另一种方法是将其转为有多少个区间重叠的问题，参考数组问题中给定范围内最常出现的整数解法。


### 距离最近的坐标点

[Closest Pair of Points using Divide and Conquer algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/)

分治算法：先按照x轴坐标对点进行排序，然后根据x轴坐标选择一个中间点，将数组分成两个部分，重复这个步骤，将数组分成大小小于3的子数组，在这些子数组中使用暴力解法求最小距离，得到左半边和右半边的最小距离 d，然后选择x轴距离中点小于d的点，再按照y轴排序，在这些点中使用暴力解法求出最小距离。

```python
import math

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
def dist(p1: Point, p2: Point):
    return math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)

def bruteForce(P, n):
    min_dist = float("inf")
    for i in range(n):
        for j in range(i+1, n):
            d = dist(P[i], P[j])
            min_dist = min(min_dist, d)
    return min_dist

def compX(item):
    return item.x

def compY(item):
    return item.y

def stripClosest(arr, n, d):
    min_dist = d
    arr = sorted(arr, key=compY)

    for i in range(n):
        for j in range(i + 1, n):
            # 减少可能的迭代次数
            if arr[j].y - arr[i].y > min_dist:
                break
            if dist(arr[i], arr[j]) < min_dist:
                min_dist = dist(arr[i], arr[j])
    return min_dist

def divide(arr, n):
    if n <= 3:
        return bruteForce(arr, n)
    
    mid = n // 2
    dl = divide(arr[:mid], mid)
    dr = divide(arr[mid:], n - mid)

    d = min(dl, dr)

    stripes = []
    for i in range(n):
        if abs(arr[i].x - arr[mid].x) < d:
            stripes.append(arr[i])
    return min(d, stripClosest(stripes, len(stripes), d))
    
P = [Point(x=2, y=3), Point(x=12, y=30),
         Point(x=40, y=50), Point(x=5, y=1), Point(x=12, y=10), Point(x=3, y=4)]
n = len(P)
P = sorted(P, key=compX)
print(divide(P, n))
```

### 计算交换次数

[Count Inversions of an Array - GeeksforGeeks](https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/)
[Minimum swaps to sort an array - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/)

给定一个未排序的数组，计算将其排好序所需的交换次数





#### 归并排序

可以使用归并排序来解决这一问题，参考数组问题中找到数组中每一个元素右侧大于自己的数

如果左侧序列中的某个数 `left[i]` 大于右侧序列中的某个数 `right[j]`，那么 `right[j]` 要和 `left[i]` 右侧和自身所有的数交换，交换次数为 n-i

```python
class Solution:
    def merge(self, arr, low, mid, high):
        res = 0
        left = arr[low: mid+1]
        right = arr[mid+1:high+1]
        n1 = len(left)
        n2 = len(right)
        
        i, j = 0, 0
        k = low
        while i < n1 and j < n2:
            if left[i] <= right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                res += n1 - i    # 唯一需要注意的地方，如果
                j += 1
            k += 1
        
        while i < n1:
            arr[k] = left[i]
            i += 1
            k += 1
        while j < n2:
            arr[k] = right[j]
            j += 1
            k += 1
        return res
    
    def mergeSort(self, arr, low, high):
        res = 0
        if low < high:
            mid = low + (high - low) // 2
            res += self.mergeSort(arr, low, mid)
            res += self.mergeSort(arr, mid+1, high) 
            res += self.merge(arr, low, mid, high)
        return res
        
    def inversionCount(self, arr):
        # Your Code Here
        n = len(arr)
        res = self.mergeSort(arr, 0, n-1)
        return res
```


#### 哈希方法（适用于不同的元素）

先使用自带的排序方法对数组进行排序，记录原数组的元素位置，将排好序的数组与原数组比较，如果不一致，进行交换

```python
def minSwaps(arr):
    
    # Temporary array to store elements in sorted order
    temp = sorted(arr)
    
    # Hashing elements with their correct positions
    pos = {}
    for i in range(len(arr)):
        pos[arr[i]] = i
    
    swaps = 0
    for i in range(len(arr)):
        if temp[i] != arr[i]:
            
            # Index of the element that should be at index i.
            ind = pos[temp[i]]
            arr[i], arr[ind] = arr[ind], arr[i]

            # Update the indices in the dictionary
            pos[arr[i]] = i
            pos[arr[ind]] = ind

            swaps += 1
    return swaps
```


#### 环检测

一个未排序的元素处于一个环中，找出这个环，环的大小减一就是这个环内元素需要交换的次数

```python
def minSwaps(arr):
    n = len(arr)
        
    # Array to Keep track of those elements
    # who already been included in the cycle.
    vis = [False] * n
    
    # Hashing elements with their original positions
    pos = {}
    for i in range(len(arr)):
        pos[arr[i]] = i
        
    arr.sort()

    swaps = 0
    for i in range(n):

        # Already a part of another cycle Or
        # in its correct position
        if vis[i] or pos[arr[i]] == i:
            continue

        j, cycleSize = i, 0

        # We make a cycle until it comes
        # back to first element again.
        while not vis[j]:
            vis[j] = True

            # move to next element of the cycle
            j = pos[arr[j]]
            cycleSize += 1

        # Update answer by adding current cycle.
        if cycleSize > 0:
            swaps += (cycleSize - 1)
    return swaps
```



### 排序多个有序链表

1、将K个有序链表，以类似归并排序中的分割方法，分割成单个，然后两两merge

2、使用最小堆，可以参考排序多个机器上的数组问题中的解法，维持一个大小为K的最小堆，将K个有序链表的头节点塞入最小堆中，每次弹出最小的头节点，并将最小头节点对应的链表中的下一个元素再塞入最小堆中。

```python
def mergeKLists(arr):
    pq = []
    
    # Insert the head nodes of k lists 
    for i in range(0, len(arr)):
        head = arr[i]
        if head is not None:
            heapq.heappush(pq, (head.data, i, head))
    
    # Initialize a dummy head
    dummy = Node(-1)
    tail = dummy

    while pq:
        
        # Pop the min node
        _, index, top = heapq.heappop(pq)
        
        # Append the node into list
        tail.next = top
        tail = top
        
        # If top node has next node,
        # add it to the heap.
        if top.next is not None:
            heapq.heappush(pq, (top.next.data, index, top.next))

    return dummy.next
```


### 找到最小长度的未排序序列

[Find the Minimum length Unsorted Subarray, sorting which makes the complete array sorted - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/)

最简单的方法是先对序列排序，然后将排好序的数组和未排序的数组做对比，找到第一个和最后一个两者不相等的点。

一种时间复杂度为 $O(n)$ 的方法，考虑到如下情况

1、对于第`i`个元素，如果前面 i-1 个元素中存在比这个元素大的值，那么该元素是乱序的
2、从开始索引，从遇到逆序开始时，记录见到的最小值
3、第二步记录的最小值是整个乱序子序列的最小值，需要将其排到合适的地方

```python
def solve(arr):
    n = len(arr)
    
    has_meet_max = arr[0]
    unsort_min = float("inf")
    unsort_begin = 0
    unsort_end = 0 

    for i in range(1, n):
        has_meet_max = max(has_meet_max, arr[i-1]) # 前面 i - 1个数字的最大值
        
        if has_meet_max > arr[i]: # 如果前面 i-1 个元素中存在大于当前元素的元素，那么证明该元素是乱的
            unsort_end = i
        if arr[i] < arr[i-1]:   # 如果出现逆序，找出逆序数组中最小的元素 
            if unsort_min > arr[i]:
                unsort_min = arr[i]
                unsort_begin = i

    if unsort_begin > 0:     # 保证逆序数组中最小元素大于未排序数组左侧的元素
        while unsort_begin > 0 and arr[unsort_begin - 1] > unsort_min:
            unsort_begin -= 1

    print(f"{unsort_begin}, {unsort_end}")
```


另外一种更容易理解的方法：考虑到如下的情况
1、从左到右，找到第一个逆序的地方 `l`，从右到左，找到第一个逆序的地方 `r`
2、`[l, r]` 是一个可能的逆序子序列，从中找出最小值和最大值
3、在 `[0, l-1]` 中找到比最小值还小的地方，在 `[r+1,n-1]` 中找到比最大值还大的地方

```python
def printUnsorted(arr, n):
    e = n-1
	# 从左到右，找到逆序的地方
    for s in range(0,n-1):
        if arr[s] > arr[s+1]:
            break
        
    if s == n-1:
        print ("The complete array is sorted")
        exit()

    # 从右到左，找到逆序的地方
    e= n-1
    while e > 0:
        if arr[e] < arr[e-1]:
            break
        e -= 1

    # 找到逆序序列中的最大值和最小值
    max = arr[s]
    min = arr[s]
    for i in range(s+1,e+1):
        if arr[i] > max:
            max = arr[i]
        if arr[i] < min:
            min = arr[i]
            
    # 找到 [0, s-1] 中比最小值还小的地方
    for i in range(s):
        if arr[i] > min:
            s = i
            break

    # 找到 [e+1, n-1] 中比最大值还大的地方
    i = n-1
    while i >= e+1:
        if arr[i] < max:
            e = i
            break
        i -= 1
```


### K-排序问题

https://www.geeksforgeeks.org/nearly-sorted-algorithm

对于一个几乎排好序的序列，即每个元素位于和其应处位置的距离小于等于k的位置

可以使用堆排序，维持一个大小为k的堆，将前k个元素放进堆里，如果第k+1个元素小于堆顶元素，那么将其放到第一个位置，否则将堆顶元素弹出，并放入第一个位置，再将第k+1个元素塞进去

因为每个元素最多位于正确位置距离为k的位置，因此第k+2个元素不可能会比第1个元素还小，否则距离就是k+1了。

```python
def nearlySorted(self, arr, k):
	#code
	n = len(arr)
	min_heap = []
	if k == 0:
		return
	
	for i in range(k):
		heapq.heappush(min_heap, arr[i])
	
	for i in range(k, n):
		if arr[i] < min_heap[0]:
			arr[i - k] = arr[i]
		else:
			item = heapq.heappop(min_heap)
			arr[i - k] = item
			heapq.heappush(min_heap, arr[i])
	
	for i in range(n-k, n):
		item = heapq.heappop(min_heap)
		arr[i] = item
```


### 在线性时间排序固定范围内的数据

如果想要在线性时间排序范围为 0 到 $n^2-1$ 的数据，可以使用基数排序，将基数设置为 n 即可实现

```python
def sort(arr, n) :
    
    # Do counting sort for first digit in base n. 
    # Note that instead of passing digit number,
    # exp (n^0 = 1) is passed. 
    countSort(arr, n, 1) 
    # Do counting sort for second digit in base n. 
    # Note that instead of passing digit number, 
    # exp (n^1 = n) is passed. 
    countSort(arr, n, n)
```

### 让两个包含相同元素的数组相等所需的最小交换次数


[Minimum swaps to make two arrays consisting unique elements identical - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-to-make-two-array-identical/)

假设有两个数组包含了相同的元素，并且这些元素各不相同，但是顺序不同，请问如何计算让这两个数组排列顺序相同的最小交换次数。

因为只需要计算最小交换次数，因此只需要获取第二个数组的元素在第一个数组中的索引，最后该问题转换为了排序时计算交换次数。

如 `arrA = {3, 6, 4, 8}`，`arrB = {4, 6, 8, 3}`，arrB 中的元素在 arrA 中的索引为 `[2, 1, 3, 0]`，接着对索引排序即可。



### 无需额外空间融合两个有序列表

https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space

使用两个指针分别指向一个列表的结尾和另一个列表的开始，如果`a[i]>b[j]`，就交换，并移动到下一位，否则让一个指针继续前进，直至停止迭代。


```python
def mergeArrays(a, b):
	n1 = len(a)
	n2 = len(b)
	i = n1 - 1
	j = 0
	
	while i >= 0 and j < n2:
		if a[i] > b[j]:
			a[i], b[j] = b[j], a[i]
			i -= 1
			j += 1
		else:
			i -= 1
	a.sort()
	b.sort()
```


### 包含连续数的最小子集数

[Partition into minimum subsets of consecutive numbers - GeeksforGeeks](https://www.geeksforgeeks.org/count-minimum-number-subsets-subsequences-consecutive-numbers/)

注意只有一个数也算是连续数，因此，在排好序的数组中只需要 `arr[n] != arr[n-1]+1`，那么就代表有一个最小子集包含了连续数。

还可以用哈希，将数组转成一个集合，对于数组中的每个数X，如果 X-1不在集合中就代表有一个子集

### 将所有小于k的数排在一起的最小交换数


[Minimum swaps required to bring all elements less than or equal to k together - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-required-bring-elements-less-equal-k-together/)

首先统计所有小于k的数的个数 s，然后创建一个滑动窗口，大小为 s，统计这个窗口内大于等于k的元素的个数，最小交换数取这些窗口内大于等于k的元素个数的最小值即可。

上述结论基于这样的思考，如果想让所有小于k的元素排在一起，即排在一个滑动窗口内。这样的话，只需要将滑动窗口内大于等于k的元素交换出去即可。

```python
def minSwap (arr, k) : 
	n = len(arr)
	ws = 0
	for i in range(n):
		if arr[i] <= k:
			ws += 1
	
	if ws == 0:
		return 0
		
	bad = 0
	
	# 计算初始窗口中大于k的数量
	for i in range(ws):
		if arr[i] > k:
			bad += 1
	
	res = bad
	
	for i in range(ws, n):
		if arr[i - ws] > k:
			bad -= 1
		
		if arr[i] > k:
			bad += 1
		
		res = min(res, bad)
	return res
```


### 二叉树转为二叉搜索树的最小交换次数

[Minimum swap required to convert binary tree to binary search tree - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swap-required-convert-binary-tree-binary-search-tree/)

先进行中序遍历（in-order），将得到的数组排列出来，再计算将该数组排序所需的次数



### 计算文本中某个模式的出现次数


[Count distinct occurrences as a subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/count-distinct-occurrences-as-a-subsequence/)

给定一个文本，计算某个模式的出现次数，如

txt = banana, pat = ban，ban 在 banana 中的出现次数为3次，分别为 `[ban]`、`[ba n]` 和 `[b an]`

#### 自己写的解法


使用一个栈保存已经匹配好的字符，匹配到文本的末尾后就弹出栈中保存的字符，继续进行匹配。

```python
def patCount(txt, pat):
    n1 = len(txt)
    n2 = len(pat)

    stack = []    # 储存当前已经匹配好的字符
    
    i, j = 0, 0   # i 和 j分别是 txt 和 pat的索引，其中j是pat中目前需要匹配的字符索引
    cnt = 0
    while True:
        if i < n1:      # 如果没有索引到 txt 的末尾
            if txt[i] != pat[j]:   # 如果不相等，就向后索引
                i += 1
                continue
            if j == n2 - 1:        # 已经完成了一次匹配，继续尝试向后匹配更多的字符
                cnt += 1
                i += 1
                j = n2 - 1
            else: 
                stack.append(i+1)  # 储存字符的位置
                j += 1
                i += 1
        else:
            if len(stack) == 0:    # 已经匹配到末尾了，如果栈为空，证明已经没有可以匹配到的字符了
                break
            else:
                i = stack.pop()    # 弹出栈中的一个元素，进行下一次循环，匹配第j个元素
                j = len(stack)
    return cnt
```

#### 回溯法

对于两个字符串 txt 和 pat，从前到后，如果`txt[i+1]=pat[j+1]`，那么考虑`i+1` 之后的txt和 `j+1` 之后pat 以及 `i+1` 之后的txt和`j` 之后的pat

```python
def count(txt, pat, i, j, n1, n2):
    if j == n2 - 1:
        return 1
    if i == n1 - 1:
        return 0
    
    if txt[i+1] == pat[j+1]:
        return count(txt, pat, i + 1, j+1, n1, n2) + count(txt, pat, i + 1, j, n1, n2)
    
    return count(txt, pat, i+1, j, n1, n2)

count(txt, pat, -1, -1, n1, n2)   # 注意从-1开始
```

反过来，从后向前

```python
def subCountRec(i, j, txt, pat):
    if j == 0:    # 如果pat已经匹配完毕
        return 1

    if i == 0:    # 如果 txt 已经匹配完了 
        return 0

    if txt[i - 1] == pat[j - 1]:
        return subCountRec(i - 1, j - 1, txt, pat) \
          + subCountRec(i - 1, j, txt, pat)

    return subCountRec(i - 1, j, txt, pat)
subCountRec(0, 0, txt, pat)
```


这样做复杂度过高，可以使用一个矩阵保存已经计算过的情况。

```python
def countSubsequences(i, j, pat, txt, memo):
    if i == 0:
        return 1 
    if j == 0:
        return 0 

    # If already computed, return the result
    if memo[i][j] != -1:
        return memo[i][j]

    # If last characters don't match
    if pat[i - 1] != txt[j - 1]:
        memo[i][j] = countSubsequences(i, j - 1, pat, txt, memo)
    else:
      
        # Both characters match
        memo[i][j] = (countSubsequences(i, j - 1, pat, txt, memo)
                      + countSubsequences(i - 1, j - 1, pat, txt, memo))

    return memo[i][j]
  
def findSubsequencecount(txt, pat):
    m, n = len(pat), len(txt)

    # pat can't appear as a subsequence in txt
    if m > n:
        return 0

    # Create a memoization table
    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]

    return countSubsequences(m, n, pat, txt, memo)
```


#### 动态规划

```python
def find_subsequence_count(txt, pat):
    m = len(pat)
    n = len(txt)

    # pat can't appear as a subsequence
    # in txt
    if m > n:
        return 0

    # Create a 2D list initialized with 0
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Initializing first row with all 1s. An empty string
    # is a subsequence of all.
    for j in range(n + 1):
        dp[0][j] = 1

    # Fill mat[][] in bottom-up manner
    for i in range(1, m + 1):
        for j in range(1, n + 1):
          
            # If last characters don't match, then value
            # is the same as the value without the last character in txt.
            if pat[i - 1] != txt[j - 1]:
                dp[i][j] = dp[i][j - 1]
            else:
              
                # Value is obtained considering two cases:
                # a) All substrings without last character in txt
                # b) All substrings without last characters in both.
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1])

    return dp[m][n]
```




## 双指针

双指针一般用于已经排好序的数组中

### 三元组两个之和为第三个值

给定一个数组，找到一个三元组，其中两个值之和等于第三个值。

可以使用双指针来解决这一问题，对数组先排序，先确定第三个值，用双指针指向前两个值进行搜索

```python
def findTriplet(arr):
	arr.sort()
	n = len(arr)
	for i in range(2, n):   # i 指向第三个值
		l, r = 0, i - 1     # l, r 指向前两个值
		
		while l < r:
			target = arr[l] + arr[r]
			if target == arr[i]:
				return True
			elif target > arr[i]:
				r -= 1
			else:
				l += 1
		
	return False
```


### 雨水收集问题

[Trapping Rain Water Problem - Tutorial with Illustrations - GeeksforGeeks](https://www.geeksforgeeks.org/trapping-rain-water/)



#### 自己的算法

先找到最大值，然后从两边向最大值靠拢计算能收集的雨水。从左到右，如果遇到右侧大于等于左侧的就计算一个能存储的雨水量。

如果用前缀和代替这里的求和过程，时间复杂度就能降为 $O(n)$

```python
def findMaxWater(self, arr):
        max_units = 0
        now_units = 0
        
        si = 0
        while arr[si] == 0:
            si += 1
        
        for i in range(si + 1, len(arr)):
            if arr[i] >= arr[si]:
                now_units = (i - si - 1) * arr[si] - sum(arr[si+1: i])
                si = i
                max_units += now_units
        return max_units
        
    def maxWater(self, arr):
        # code here
        max_units = 0
        max_height = max(arr)
        max_height_index = arr.index(max_height)
        
        left_arr = arr[:max_height_index+1]
        right_arr = arr[max_height_index:][::-1]
        
        left_units = 0
        right_units = 0
        
        if len(left_arr) > 1:
            left_units = self.findMaxWater(left_arr)
        
        if len(right_arr) > 1:
            right_units = self.findMaxWater(right_arr)
        return left_units + right_units
```


#### 官方解法

找到每个点左边和右边的最大值，然后取较小的一个，减去该点的值即为该点的水量。使用两个数组分别存储每个点左侧和右侧的最大值，可以降低时间复杂度

```python
def maxWater(arr):
    n = len(arr)

    # Left[i] contains height of tallest bar to the
    # left of i'th bar including itself
    left = [0] * n

    # Right[i] contains height of tallest bar to
    # the right of i'th bar including itself
    right = [0] * n

    res = 0

    # Fill left array
    left[0] = arr[0]
    for i in range(1, n):
        left[i] = max(left[i - 1], arr[i])

    # Fill right array
    right[n - 1] = arr[n - 1]
    for i in range(n - 2, -1, -1):
        right[i] = max(right[i + 1], arr[i])

    # Calculate the accumulated water element by element
    for i in range(1, n - 1):
        minOf2 = min(left[i - 1], right[i + 1])
        if minOf2 > arr[i]:
            res += minOf2 - arr[i]

    return res
```


#### 双指针优化空间


考虑到如果我们知道 `arr[left]` 的左边最大值，和`arr[right]` 的右边最大值，左边最大值小于右边最大值，可以确定 `arr[left]`（因为`arr[left]` 的右侧最大值肯定大于左侧最大值），否则可以确定 `arr[right]`。

```python
def maxWater(arr):
    left = 1
    right = len(arr) - 2

    # lMax : Maximum in subarray arr[0..left-1]
    # rMax : Maximum in subarray arr[right+1..n-1]
    lMax = arr[left - 1]
    rMax = arr[right + 1]

    res = 0
    while left <= right:
      
        # If rMax is smaller, then we can decide the 
        # amount of water for arr[right]
        if rMax <= lMax:
          
            # Add the water for arr[right]
            res += max(0, rMax - arr[right])

            # Update right max
            rMax = max(rMax, arr[right])

            # Update right pointer as we have decided 
            # the amount of water for this
            right -= 1
        else: 
          
            # Add the water for arr[left]
            res += max(0, lMax - arr[left])

            # Update left max
            lMax = max(lMax, arr[left])

            # Update left pointer as we have decided 
            # the amount of water for this
            left += 1
    return res
```


#### 使用栈

```python
# Function to return the maximum water that can be stored
def maxWater(arr):
    st = []
    res = 0

    for i in range(len(arr)):
       
        # Pop all items smaller than arr[i]
        while st and arr[st[-1]] < arr[i]:
            pop_height = arr[st.pop()]

            if not st:
                break

            # arr[i] is the next greater for the removed item
            # and new stack top is the previous greater 
            distance = i - st[-1] - 1

            # Take the minimum of two heights (next and prev greater)
            water = min(arr[st[-1]], arr[i])

            # Find the amount of water
            water -= pop_height

            res += distance * water
        st.append(i)

    return res
```


## 滑动窗口

一般用于找到满足特定要求的子序列，找到包含不同字符的最长子字符串等问题。可以分为定长和不定长。


### 子序列和为K

在一个序列中找到一个子序列，其和为K。该问题可以通过前缀和求解，下面给出使用滑动窗口的解法

先设置窗口的左右点均为0，处于同一个点，先滑动右窗口，再滑动左窗口。

```python
def subarraySum(arr, target):
        
	l, r = 0, 0
	n = len(arr)
	
	s = 0
	
	while l <= r and r < n:
		while s < target and r < n:
			s += arr[r]
			r += 1
		
		if s == target:
			return [l+1, r]
		if s < target:
			return [-1]
		
		while s > target and l < r:
			s -= arr[l]
			l += 1
			
		if s == target:
			return [l+1, r]
	
	return [-1]
```


### 固定大小的子序列中的最大值

找到一个序列中每个固定长度的子序列的最大值。使用一个有序列表作为窗口

```python
from sortedcontainers import SortedList

def maxSlidingWindow(arr, k):
    ans = []
    window = SortedList()

    # Initialize the window with the first k elements
    for i in range(k):
        window.add((-arr[i], i))  # Use negative value for max-heap behavior

    # The maximum element in the first window
    ans.append(-window[0][0])

    # Process the remaining elements
    for i in range(k, len(arr)):
        window.add((-arr[i], i))
        # Remove the element that is out of the window
        if i - k >= 0:
            window.remove((-arr[i - k], i - k))
        # The maximum element in the current window
        ans.append(-window[0][0])

    return ans
```

也可以用一个最大堆保存

```python
import heapq

def max_sliding_window(arr, k):
    ans = []
    heap = []

    # Initialize the heap with the first k elements
    for i in range(k):
        heapq.heappush(heap, (-arr[i], i))

    # The maximum element in the first window
    ans.append(-heap[0][0])

    # Process the remaining elements
    for i in range(k, len(arr)):
        heapq.heappush(heap, (-arr[i], i))

        # Remove elements that are outside the current window
        while heap[0][1] <= i - k:
            heapq.heappop(heap)

        # The maximum element in the current window
        ans.append(-heap[0][0])

    return ans
```


### 长度为K的子序列中的首个负数

[First negative integer in every window of size k - GeeksforGeeks](https://www.geeksforgeeks.org/first-negative-integer-every-window-size-k/)

使用一个deque来保存窗口内有用的信息，在本问题中就是保存负数对应的索引

```python
from collections import deque

def printFirstNegativeIntegar(arr, n, k):
    Di = deque()

    for i in range(k):
        if arr[i] < 0:
            Di.append(i)
    
    for i in range(k, n):
        if not Di:
            print(0, end=" ")
        else:
            print(arr[Di[0]], end=" ")
        
        while Di and Di[0] <= (i - k):
            Di.popleft()
        
        if arr[i] < 0:
            Di.append(i)
    
    if not Di:
        print(0)
    else:
        print(arr[Di[0]])
```



### 长度至少为K的子序列之和的最大值

[Largest sum subarray of size at least k - GeeksforGeeks](https://www.geeksforgeeks.org/largest-sum-subarray-least-k-numbers/)


kadane算法：先计算每个索引前的最大和，然后用一个大小为k的窗口，计算连续k个元素之和。

```python
def maxSumWithK(a, n, k):
	maxSum = [a[0]]
	currMaxSum = a[0]
	# kadane算法
	for i in range(1, n):
		# 要么是a[i] 要么是前面i-1所对应的序列和a[i]
		currMaxSum = max(a[i], maxSum[i-1]+a[i])
		maxSum.append(currMaxSum)
	
	s = 0
	for i in range(k):
		s += a[i]
	res = s
	for i in range(k, n):
		s += a[i] - a[i - k]
		
		res = max(res, s)
		# 如果加上前面i-k的最大值
		res = max(res, s + maxSum[i-k])
	
	return res
```

另一种算法：用一个长度为k的窗口计算连续k个元素之和，然后计算窗口之前的元素之和，如果和为负值，就丢弃前面这些元素

```python
def maxSumWithK(arr, k):
    
    # Calculate initial sum of 
    # first k elements (first window)
    sum = 0
    for i in range(k):
        sum += arr[i]

    last = 0
    j = 0
    ans = float('-inf')
    ans = max(ans, sum)

    # Process rest of the array after first k elements
    for i in range(k, len(arr)):

        # Add current element to window sum
        sum = sum + arr[i]

        # Add element at j to 'last' and increment j
        last = last + arr[j]
        j += 1

        # Update answer if current window sum is greater
        ans = max(ans, sum)

        # If sum of elements before window becomes negative
        if last < 0:
            sum = sum - last
            ans = max(ans, sum)
            last = 0

    return ans
```


最小交换次数


## 前缀和


前缀和的大小和原数组相同，`prefixSum[i] = arr[0]+arr[1]+...+arr[i]`

从 L 到 R 的和用前缀和表达为（L 和 R 均从 1 开始计数）
如果 L 大于1，`prefixSum[R] - prefixSum[L-1]`，否则为 `prefixSum[R]`

前缀和可以用于产生满足一定概率分布的随机数 [Prefix Sum Array - Implementation and Applications in Competitive Programming - GeeksforGeeks](https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/)

### 令所有子序列之和小于k的最大子序列长度

[Maximum subarray size, such that all subarrays of that size have sum less than k - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-subarray-size-subarrays-size-sum-less-k/)

给定一个子序列，找到一个最大的序列长度，使得所有小于该长度的子序列之和小于k。

该问题可以转为找到一个最小的子序列长度使得其之和大于k，可以使用滑动窗口解决

```python
def solve(arr, k):
    l = 0
    n = len(arr)
    s = 0
    res = n
    no_res = False
    for r in range(n):

        s += arr[r]

        while s > k:
            s -= arr[l]
            l += 1
            res = min(res, r - l + 1)

            # 对于全部大于0的序列来说，如果s等于0，意味着 l > r，
            # 证明arr[r]为一个大于k的数，这样不可能出现和小于k的子序列
            if s == 0:
                no_res = True
                break
        if no_res:
            res = -1
            break
```


### 子序列模m余数的最大值

对于一个序列，求其子序列模m后的余数的最大值

首先求前缀和关于m的余数，并存入一个集合中，每次求出余数后，在这个集合中找到比这个余数至少大1的余数，假设找到余数正好大 `a`，这样两个前缀和相减之后，余数为`m-a`。

```python
def solve(arr, m):
    n = len(arr)

    mp = set()
    mp.add(0)   # 空子序列之和为0，余数也为0
    prefix = 0
    res = 0

    for i in range(n):

        prefix = (prefix + arr[i]) % m
        res = max(res, prefix)
        _p = 0
        for p in mp:
            if p >= prefix + 1:
                _p = p
        
        if _p != 0:
            res = max(res, prefix - _p + m)
        mp.add(prefix)
    return res
```



## 字符串

### 打印所有的可能的带空格的字符串

[Print all possible strings that can be made by placing spaces - GeeksforGeeks](https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/)

```python
def print_util(str):
    strs = []
    if len(str) == 1:
        strs.append(str)
        return strs

    strtemp = print_util(str[1:])

    for i in range(len(strtemp)):
        strs.append(str[0]+ strtemp[i])
        strs.append(str[0] + " "+ strtemp[i])
    
    return strs


def print_all_strings(s):
    strs = print_util(s)
    for i in strs:
        print(i)
```


另一种解法

```python
def get_all_possible_string_utils(s, res, i, r):
	if i >= len(s):
		res.append(r)
		return
	
	self.get_all_possible_string_utils(s, res, i+1, r + " "+ s[i])
	self.get_all_possible_string_utils(s, res, i+1, r + "" + s[i])
    
def get_all_possible_string(s):
	res = []
	get_all_possible_string_utils(s, res, 1, s[0])
	return res
```
