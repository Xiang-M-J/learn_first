
## 数的表示

### 数字可除性

判断一个数是否能被7整除

每个数都可以表示为 `10a+b` 的形式，已知 7a + 7b 能被7整除，那么只需要判断 `10a+b-7a-7b` 即 3a-6b 即 `a-2b` 能否被7整除。

```python
def isDivisibleBy7(num) :
     
    # If number is negative, make it positive
    if num < 0 :
        return isDivisibleBy7( -num )
 
    # Base cases
    if( num == 0 or num == 7 ) :
        return True
     
    if( num < 10 ) :
        return False
         
    # Recur for ( num / 10 - 2 * num % 10 ) 
    return isDivisibleBy7( num // 10 - 2 * ( num - num // 10 * 10 ) )
```



### 质数相关

如何判断一个数是不是质数，一种快速算法如下

依据为：所有数都可以表示为 `6k+i` 的形式，如果一个数不能被 2 或者 3 整除，那么如果是质数的话，必须满足 `6k+1` 或者 `6k+5` 这两种形式（其它形式都可以被 2 或者 3 整除），所以将这个数除 6k+1 或者 6k + 5 可以验证其是否是质数。

```python
import math

def isPrime(n):

    # Check if n is 1 or 0
    if n <= 1:
        return False

    # Check if n is 2 or 3
    if n == 2 or n == 3:
        return True

    # Check whether n is divisible by 2 or 3
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check from 5 to square root of n
    # Iterate i by (i+6)
    i = 5
    while i <= math.sqrt(n):
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6

    return True

if __name__ == "__main__":
  n = 11
  if(isPrime(n)): 
    print("true")
  else:
    print("false")
```


埃拉托色尼筛法：找到0-n之间所有的质数和合数：如果n是质数，那么`n*n+k*n` 都不是质数，

```python
def SieveOfEratosthenes(n):

    # Create a boolean array
    # "prime[0..n]" and initialize
    #  all entries it as true.
    # A value in prime[i] will
    # finally be false if i is
    # Not a prime, else true.
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

        # If prime[p] is not
        # changed, then it is a prime
        if (prime[p] == True):

            # Update all multiples of p
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

    # Print all prime numbers
    for p in range(2, n+1):
        if prime[p]:
            print(p)
```



## 矩阵计算


### 矩阵计算斐波那契数列

对于广义斐波那契数列 $g(n)=a*g(n-1)+b*g(n-2)+c$ ，使用迭代方法时间复杂度为 $O(n)$，使用矩阵计算可以将时间复杂度降为 $O(log_2n)$

矩阵计算可以表示成

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = \left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]\left[ \matrix{
  g(n - 1) \hfill \cr 
  g(n - 2) \hfill \cr 
  c \hfill \cr}  \right]
$$
这样$g(n)$ 可以这样计算

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = {\left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]^{n - 2}}\left[ \matrix{
  g(2) \hfill \cr 
  g(1) \hfill \cr 
  c \hfill \cr}  \right]
$$

等式右侧的幂次矩阵可以一次算两个，甚至可以先算好两次方，直接用也行

具体实现如下

```python
mat = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix
res = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix

def mul(self, res, mat, m):
	res1 = [[0 for i in range(3)] for j in range(3)] # Initializing a 3x3 matrix
	for i in range(3):
		for j in range(3):
			for k in range(3):
				res1[i][j] += (res[i][k]*mat[k][j]) # Multiplying matrices element-wise and summing
				res1[i][j] %= m # Taking modulo m to avoid overflow
	
	for i in range(3):
		for j in range(3):
			res[i][j] = res1[i][j] # Updating the resultant matrix

def mat_exp(self, n, m):
	while n>0:
		if n&1:  
			self.mul(self.res, self.mat, m) # Multiplying the result matrix with the current matrix
		self.mul(self.mat,self.mat,m) # Squaring the current matrix
		n //= 2 # Halving the power of the matrix
```


## 进制问题

### 小鼠和毒药问题

**原始**：假设有1000瓶药水，其中有一瓶是毒药，可以任意混合，请问需要多少只小鼠才能验出有毒的一瓶？（每只小鼠只喝一次药水）

1000瓶药水可以编号为0, 1, ..., 999，写成二进制为

0000000000
0000000001
...
1111100111

为了确定哪一瓶有毒，只需要每一位为1的药水混合起来（对于最低位，就是1，3，5，7等等），喂给一只小鼠，这样一共需要10只小鼠，哪一只小鼠死了，表示该位为1，否则不为1，这样便能确定毒药的位置，当然如果全部都不死，那么第一瓶就是毒药。

即小鼠数量等于 $ceil(\log_2N)$，$N$ 为药水数量。

**变体1**：假设可以测试两轮，4只小鼠可以检测多少瓶药水（只有一瓶有毒，每只小鼠一轮只喝一次）

分成两种情况

1、如果死的小鼠不能更换，那么每只小鼠有3种状态，第一轮死、第二轮死和不死。那么共能测试 $3^{4}$ 瓶药水，具体测试过程为：

先将药水编成3进制

0000
0001
0002
0010
0011
0012
...
2222

第一轮先将每一位有2的药水全部混合起来，喂给4只小鼠。如果有一只小鼠死了，代表这一位为2，那么把所有该位为2的药水拿出来做第二轮测试，由于第二轮测试中该位全部为2，相当于回到了原来的情况，不过位数少了一位，用剩下的3只测试就够了；如果第一轮测试没有小鼠死，那么去掉所有编码包含2的瓶子，这样只剩下了01编码的，回到了二进制，用剩下的4只小鼠测试即可


2、如果死的小鼠可以替换，那么相当于有8只小鼠，这样共可以测试 $2^8$ 瓶药水。另外一种思考方式为将药水按顺序每16个混合在一起做一轮测试，这样下一轮再测试16个。

**变体2**：如果有16瓶药水，有一瓶是毒药，请问需要多少只小鼠能找到14瓶不是毒药的药水

这个问题可以转换成找两瓶可能带毒药的，由于16瓶药水可以表示成 xxxx 的形式，所以只需要确定前面3位就能找到可能带毒药的；先相邻两位混合成共8瓶药水，用3只小鼠测试即可。




## 查找表

查找表是一个数组，一般事先计算好查找表，在后续使用时直接在查找表中索引即可，可以加速运算。

如计算DFT时，事先将旋转因子$W_N^{kn}$计算好，对于长度为 N 的DFT，查找表需要存储 N 个复数（$W_N^0$，$W_N^1$，...，$W_N^{N-1}$）


### 计算整数的二进制中1的个数

如 9 的二进制为 1001， 1的个数为2

简单的算法如下：

```python
def  countSetBits(n):
    count = 0
    while (n):
        count += n & 1
        n >>= 1
    return count
```

时间复杂度为 log(n)

使用查找表可以将时间复杂度降为1，查找表是一个256位的数组，存储0-255这256个数字中1的个数

```python
BitsSetTable256 = [0] * 256

# Function to initialise the lookup table 
def initialize():
	
	# To initially generate the 
	# table algorithmically 
	BitsSetTable256[0] = 0
	for i in range(256):
		# 如果最后一位为0，那么向右移动一位，1 的个数不变
		# 如果最后一位不为0，那么向右移动一位，1 的个数减1
		BitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2] 
```

有了查找表后，对于1个32位的整数 n，只需要将整数 n 的二进制分成四段（注意每一段需要移动到最后8位，并且屏蔽之前若干位），分别计算即可

```python
def countSetBits(n):
	return (BitsSetTable256[n & 0xff] +
			BitsSetTable256[(n >> 8) & 0xff] +
			BitsSetTable256[(n >> 16) & 0xff] +
			BitsSetTable256[n >> 24])
```


## 数组问题

数组中存储了数据（C/C++等）或者索引（Python，JS等），数组是连续地址，可以在常数时间完成随机访问


### 第k个最大和连续子序列

找到一个序列中的子序列，使其之和从大到小排在第k位

常规的做法是用 $O(n^2)$  的时间获得所有的子序列之和，然后再排序，时间复杂度为 $O(n^2logn^2)$

可以使用前缀和以及最小堆优化，先计算序列的前缀和保存在数组中，这样子序列之和直接用数组的两个值相减即可。

```python
# Python program to find the K-th largest sum
# of subarray
import heapq

# function to calculate Kth largest element
# in contiguous subarray sum


def kthLargestSum(arr, N, K):

    # array to store prefix sums
    sum = []
    sum.append(0)
    sum.append(arr[0])
    for i in range(2, N + 1):
        sum.append(sum[i - 1] + arr[i - 1])

    # priority_queue of min heap
    Q = []
    heapq.heapify(Q)

    # loop to calculate the contiguous subarray
    # sum position-wise
    for i in range(1, N + 1):

        # loop to traverse all positions that
        # form contiguous subarray
        for j in range(i, N + 1):
            x = sum[j] - sum[i - 1]   # x 为某一段序列之和

            # if queue has less than k elements,
            # then simply push it
            if len(Q) < K:
                heapq.heappush(Q, x)
            else:
                # it the min heap has equal to
                # k elements then just check
                # if the largest kth element is
                # smaller than x then insert
                # else its of no use
                if Q[0] < x:
                    heapq.heappop(Q)
                    heapq.heappush(Q, x)

    # the top element will be then kth
    # largest element
    return Q[0]
```


### 最小子序列之和大于某个值

找到一个子序列，使其和大于某一个值，并且要求这个子序列长度最小。该序列所有值大于等于0。

```python
def smallestSubWithSum(x, arr):

    i, j = 0, 0
    sum = 0
    ans = float('inf')

    while j < len(arr):

        # Expand window until sum > x 
        # or end of array reached
        while j < len(arr) and sum <= x:
            sum += arr[j]
            j += 1

        # If we reached end of array and sum 
        # still <= x, no valid subarray exists
        if j == len(arr) and sum <= x:
            break

        # Minimize window from start 
        # while maintaining sum > x
        while i < j and sum - arr[i] > x:
            sum -= arr[i]
            i += 1

        ans = min(ans, j - i)

        # Remove current start 
        # element and shift window
        sum -= arr[i]
        i += 1

    # Return 0 if no valid subarray
    # found, else return min length
    if ans == float('inf'):
        return 0
    return ans
```


### 找到数组中每一个元素右侧大于自己的数

[Surpasser Count of Each Element in Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-surpasser-count-of-each-element-in-array/)

给定一个包含不同元素的数组，找到数组中在右侧大于自己的数（Surpasser）（$i< j$ 并且 $a[i]<a[j]$），并统计数量。

使用合并排序的思路进行求解

在合并排序中，需要将数组连续二等分，连续分到最后，只有一个值。由于数组中包含的是不同的元素，可以用一个字典保存各个元素的Surpasser的数量。在合并的时候，只需要考虑左侧数组，因为左侧数组在原数组的位置在右侧数组之前，如果左侧数组中的元素小于右侧数组中的某个值，那么之后的全都小于。

```python
# Python program to find the surpasser count of each element
# using merge step of merge sort

def merge(arr, lo, mid, hi, m):
    n1 = mid - lo + 1
    n2 = hi - mid
    left = arr[lo:lo+n1]
    right = arr[mid+1:mid+1+n2]

    i = j = 0
    k = lo

    # Merging two halves
    while i < n1 and j < n2:
      
        # All elements in right[j..n2] are greater than left[i]
        # So add n2 - j, in surpasser count of left[i]
        if left[i] < right[j]:
            m[left[i]] += n2 - j
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1

    # Copy remaining elements of left[] if any
    while i < n1:
        arr[k] = left[i]
        i += 1
        k += 1

    # Copy remaining elements of right[] if any
    while j < n2:
        arr[k] = right[j]
        j += 1
        k += 1

def mergeSort(arr, lo, hi, m):
    if lo < hi:
        mid = lo + (hi - lo) // 2

        # Sort left and right half
        mergeSort(arr, lo, mid, m)
        mergeSort(arr, mid + 1, hi, m)

        # Merge them
        merge(arr, lo, mid, hi, m)

def findSurpasser(arr):
    n = len(arr)
    
    # Map to store surpasser counts
    m = {key: 0 for key in arr}

    # Duplicate array to perform merge Sort
    # so that original array is not modified
    dup = arr[:]
    
    mergeSort(dup, 0, n - 1, m)
    
    # Store surpasser counts in result array
    # in the same order as given array
    res = [m[arr[i]] for i in range(n)]
    
    return res
```


### 统计数组中前k个经常出现的元素

[Top K Frequent Elements in an Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-k-numbers-occurrences-given-array/)
一般做法是先统计频次，再排序

一种更好的方法是先统计频次，再使用一个最大堆来存储前k个频次最大的元素

```python
def topKFrequent(arr, k):

    # Dictionary 'mp' implemented as frequency hash
    # table
    mp = Counter(arr)

    pq = []
    
    for key, value in mp.items():
        heapq.heappush(pq, (value, key))
        if len(pq) > k:
            heapq.heappop(pq)

    # store the result
    res = []
    
    while pq:
        res.append(heapq.heappop(pq)[1])

    res.reverse()
    return res
```










## 哈希问题

哈希最大的特点是可以实现常数时间搜索、插入和删除，主要用于实现不相等的元素，如键值对。

### 子集问题

问一个集合 m 是否包含了另一个集合 n

1、最简单的是直接暴力搜索
2、先排序再搜索（使用自带的高效排序方法）
3、使用哈希

实现方式

```python
def isSubset(a, b):

    # Create a hash set and insert all elements of arr1
    hash_set = set(a)

    # Check each element of arr2 in the hash set
    for num in b:
        if num not in hash_set:
            return False

    # If all elements of arr2 are found in the hash set
    return True
```


### 两数之和

在一个序列找到两个数和为目标值

一种常规做法是先排序，再用两个指针进行索引

哈希算法可以在一次迭代中找到：先按顺序选择一个值，然后看目标值减去这个值后的结果是否在集合里即可

为了找出所有的pair使得两数之和为目标值，还需要一个字典来记录序列中每个值出现的次数

```python
def countPairs(arr, target):
    freq = {}
    cnt = 0

    for i in range(len(arr)):
        
        # 仅考虑之前点和当前点是否能组成成对关系
        if (target - arr[i]) in freq:
            cnt += freq[target - arr[i]] 
        
        # 统计当前点及其之前点的频数
        freq[arr[i]] = freq.get(arr[i], 0) + 1 
    return cnt
```

这里的频率更新需要放在计数之后，放在前面则会导致如果 `arr[i]`和 `target-arr[i]` 相等会导致同一个位置相加。




### 三数之和

在一个序列找到三个数之和为目标值

先在外部循环确定好一个值，然后在内部循环时按照二数之和求

```python
def countTriplets(arr, target):
    cnt = 0
    n = len(arr)
    
    for i in range(n-2):
    # 先确定好 arr[i]
    # 内部循环按照二数之和求解
        freq = {}
        for j in range(i+1, n):
            if target - arr[i] - arr[j] in freq:
                cnt += freq[target - arr[i] - arr[j]]
            freq[arr[j]] = freq.get(arr[j], 0) + 1

    return cnt
```


### 四数之和

对于四数之和，可以采用上面的思路，先确定两个值，再在内部循环时按照二数之和求解

还有另外一种思路，只在外部循环中确定第3个数的值，在频数中保存前两个数之和，然后循环第四个数

```python
def countSum(arr, target):
	#code here
	freq = {}
	n = len(arr)
	cnt = 0
	# 确定第三个数的值
	for i in range(n-1):
		# 这是第四个数
		for j in range(i+1, n):
			temp = arr[i] + arr[j]   # 三四两个数之和
			if target - temp in freq:
				cnt += freq[target - temp]
		
		# 此处更新前两个数之和，再遍历下一个i之前，需要更新i之前的可能对之和
		for j in range(i):
			temp = arr[i] + arr[j]
			freq[temp] = freq.get(temp, 0) + 1
	return cnt
```


### 最长子序列之和被K整除

对于一个序列，找到其中的一个最长子序列，使其之和能被 K 整除

使用一个hash（实际上是字典）保存前缀和及其对应位置

```python
# Python Code to find longest Subarray With Sum Divisible
# By K using Prefix Sum and Hash map

def longestSubarrayDivK(arr, k):
    n = len(arr)
    res = 0
    prefIdx = {}
    sum = 0

    # Iterate over all ending points
    for i in range(n):

        # prefix sum mod k 
        sum = (sum + arr[i]) % k

        # If sum == 0, then update result with the
        # length of subarray arr[0...i]
        if sum == 0:
            res = i + 1

        # Update max length for repeating sum
        elif sum in prefIdx:
            res = max(res, i - prefIdx[sum])

        # Store the first occurrence of sum
        else:
            prefIdx[sum] = i

    return res
```

存储所有前缀和出现的位置，这样如何再次出现这个前缀和，就证明这两个前缀和中间的序列之和能被 K 整除。


### 找到所有的序列对(a,b)使得 a%b = k

首先进行如下分析

$$
\eqalign{
  & a\% b = k  \cr 
  & a = n*b + k  \cr 
  & a - k = n*b \cr} 
$$
因此只需要找到 a-k 的因子即可，因子分解的算法如下

```python
def findDivisors(n):
    v = []

    # Vector is used to store the divisors
    for i in range(1, mt.floor(n**(.5)) + 1):
        if (n % i == 0):
            
            # If n is a square number, push only one occurrence
            if (n / i == i):
                v.append(i)
            else:
                v.append(i)
                v.append(n // i)
    return v
```

注意不是所有的因子都可以，需要测试一下。

```python
def printPairs(arr, k):
	n = len(arr)
	ans = 0
	occ = {}

	# creating a hashmap to store occurrence of array elements
	for num in arr:
		occ[num] = True

	isPairFound = False

	# iterating through the array elements
	for num in arr:
		# if k is in the array and k is smaller than num
		if k in occ and k < num:
			ans += 1
			isPairFound = True

		# if num is greater than or equal to k
		if num >= k:
			divisors = findDivisors(num - k)
			for divisor in divisors:
				# if num modulo divisor is equal to k, num is not equal to divisor
				# and divisor exists in the hashmap
				if num % divisor == k and num != divisor and divisor in occ:
					ans += 1
					isPairFound = True

	return ans
```


### 找到包含所有不重复元素的子序列

对于一个序列，其中一些元素是重复的，找到包含所有不重复元素的子序列

一般的做法是，通过两个循环，外部循环遍历序列左端，内部序列遍历序列的右端，判断是否存在所有的不重复元素

利用滑动窗口解决这一问题

只使用一个循环来遍历序列左端，通过一个字典来记录窗口内所有元素的出现频次，通过一个遍历记录窗口内不重复元素的数量。

如果窗口大小等于不重复元素数量，那么右端所有的子序列都包含了所有不重复元素

```python
def countDistinctSubarray(self,arr, n): 
	#code here.
	uset = set(arr)
	k = len(uset)  # 不重复元素的数量
	window = 0  # 记录窗口内不重复元素的数量
	vid = {}  # 记录窗口内各个值出现频次
	right = 0
	cnt = 0
	for left in range(n):
		while right < n and window < k:
			vid[arr[right]] = vid.get(arr[right], 0) + 1
			
			# 窗口内出现了新元素
			if vid[arr[right]] == 1:
				window += 1
			right += 1

		if window == k:
			cnt += n - right + 1

		# 窗口左侧将要缩小，失去最左侧元素
		vid[arr[left]] -= 1
		
		# 窗口将要失去一个新元素
		if vid[arr[left]] == 0:
			window -= 1
	return cnt
```

