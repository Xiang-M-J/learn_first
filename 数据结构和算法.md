
[首页 | CSView计算机招聘知识分享](https://www.csview.cn/)

## 数的表示

### 数字可除性

[Check divisibility by 7 - GeeksforGeeks](https://www.geeksforgeeks.org/divisibility-by-7/)

判断一个数是否能被7整除

每个数都可以表示为 `10a+b` 的形式，已知 7a + 7b 能被7整除，那么只需要判断 `10a+b-7a-7b` 即 3a-6b 即 `a-2b` 能否被7整除。

```python
def solve(num):
    if num < 0:
        return solve(-num)
    
    if num == 0 or num == 7:
        return True
        
    # 如果num小于10，提前中止
    if num < 10:
        return False
    
    return solve(num // 10 - 2 * (num % 10))
```


### 快速幂算法

[50. Pow(x, n) - 力扣（LeetCode）](https://leetcode.cn/problems/powx-n/description/)

采用分治的思想，初始化结果 `res` 为 1，如果 n 为奇数，则需要 `res *= x`，否则 `x *= x`，并且 `n = n // 2`。相当于将 `a^b` 分成 `(a*a) ^ (b // 2)`

```python
def myPow(x: float, n: int) -> float:
	flag = False
	if n < 0:
		flag = True
		n = -n
	res = 1
	while n > 0:
		if n & 1 == 1:
		   res *= x
		x *= x
		n = n >> 1 

	if flag: return 1 / res
	return res
```

同理还有快速加算法

```python
def myAdd(x: float, n: int) -> float:
	res = 0
	while n > 0:
		if n & 1 == 1:
		   res += x
		x += x
		n = n >> 1 
	return res
```


### 两数相除

[29. 两数相除 - 力扣（LeetCode）](https://leetcode.cn/problems/divide-two-integers/description/)

不使用乘法、除法和取余运算实现两数除法

可以使用二分查找算法搜索结果，整数除法结果在 `[0, 2 ^ 31-1]` 之间。在这个区间内二分搜索，每次搜索到的结果 `mid` 使用快速加算法判断 `mid * divisor` 是否满足要求。

除此之外还可以使用快速除算法，将 `a // b` 改为 `(a // (b + b)) * 2`，如果 a 和 b均为正数，计算如下

```python
def div(a, b):  # a 为被除数，b 为除数
	if a < b: return 0
	num = 1
	tb = b
	while tb + tb <= a:
		tb += tb
		num += num
	return num + div(a-tb, b)
```


### 判断质数

如何判断一个数是不是质数，一种快速算法如下

依据为：所有数都可以表示为 `6k+i` 的形式，如果一个数不能被 2 或者 3 整除，那么如果是质数的话，必须满足 `6k+1` 或者 `6k+5` 这两种形式（其它形式都可以被 2 或者 3 整除），所以将这个数除 6k+1 或者 6k + 5 可以验证其是否是质数。

```python
import math

def isPrime(n):
    if n <= 1:
        return False

    if n == 2 or n == 3:
        return True

    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # 判断n是否整除 5, 7, 11, 13 ... 
    i = 5
    while i <= math.sqrt(n):   # 小于等于，等于是为了判断平方数
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
```


埃拉托色尼筛法：找到0-n之间所有的质数和合数：如果n是质数，那么`n*n+k*n` （k 为大于等于0的整数）都不是质数，

```python
def SieveOfEratosthenes(n):

    prime = [True for i in range(n+1)]  # 初始时令所有数均为质数
    p = 2
    while p * p <= n:

        # 如果 prime[p] 为True, 证明是质数
        if prime[p] == True:

            # 更新 p * p + k * p 非质数
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
```


### 回文质数

[866. 回文质数 - 力扣（LeetCode）](https://leetcode.cn/problems/prime-palindrome/description/)

给定一个整数，返回大于等于这个整数的最小回文质数。

这个问题先求所有的回文数，再判断这些数是否为质数

首先需要注意，回文数的长度可以为奇数或者偶数，并且只需要考虑一半就可以了。题目中的要求，整数长度小于等于8，因此回文数的一半的长度在 `[1,5]` 即可。先判断奇数长度的回文数，再判断偶数长度的回文数

```python
def primePalindrome(n: int) -> int:
	def is_prime(n):
		if n == 1:
			return False
		
		if n == 2 or n == 3:
			return True
		
		if n % 2 ==0 or n % 3 == 0:
			return False
		
		i = 5
		while i <= math.sqrt(n):
			if n % i == 0 or n % (i+2) == 0:
				return False
			i += 6
		return True
	
	for l in range(1, 6):
		# 生成长度为奇数的回文字符串
		for root in range(10**(l - 1), 10 ** l):
			s = str(root)
			x = int(s + s[:-1][::-1])
			if x >= n and is_prime(x):
				return x
		# 生成长度为偶数的回文字符串
		for root in range(10**(l - 1), 10 ** l):
			s = str(root)
			x = int(s + s[::-1])
			if x >= n and is_prime(x):
				return x
```


### 用Rand7() 实现 Rand10()

[470. 用 Rand7() 实现 Rand10() - 力扣（LeetCode）](https://leetcode.cn/problems/implement-rand10-using-rand7/)

用Rand7 （会生成 `[1,7]` 均匀分布的数字）实现 Rand10（会生成 `[1,10]` 均匀分布的数字），需要生成均匀分布的数字

考虑 `a = rand7() - 1`，此时 `a = [0, 6]`，将 `a` 乘上 7，就能得到 `[0, 7, 14, 21,..., 42]`，再在 `a` 的基础上加上 `b=rand7()`，这样就能填满中间的空隙，因此只需要前四十个数便能实现

```python
def rand10():
	"""
	:rtype: int
	"""
	while True:
		a = rand7()
		b = rand7()
		s = (a - 1) * 7 + b
		if s <= 40:
			return 1 + (s - 1) % 10
```



## 进制问题

### 小鼠和毒药问题

**原始**：假设有1000瓶药水，其中有一瓶是毒药，可以任意混合，请问需要多少只小鼠才能验出有毒的一瓶？（每只小鼠只喝一次药水）

1000瓶药水可以编号为0, 1, ..., 999，写成二进制为

0000000000
0000000001
...
1111100111

为了确定哪一瓶有毒，只需要每一位为1的药水混合起来（对于最低位，就是1，3，5，7等等），喂给一只小鼠，这样一共需要10只小鼠，哪一只小鼠死了，表示该位为1，否则不为1，这样便能确定毒药的位置，当然如果全部都不死，那么第一瓶就是毒药。

即小鼠数量等于 $ceil(\log_2N)$，$N$ 为药水数量。

**变体1**：假设可以测试两轮，4只小鼠可以检测多少瓶药水（只有一瓶有毒，每只小鼠一轮只喝一次）

分成两种情况

1、如果死的小鼠不能更换，那么每只小鼠有3种状态，第一轮死、第二轮死和不死。那么共能测试 $3^{4}$ 瓶药水，具体测试过程为：

先将药水编成3进制

0000
0001
0002
0010
0011
0012
...
2222

第一轮先将每一位有2的药水全部混合起来，喂给4只小鼠。如果有一只小鼠死了，代表仅有这一位为2，那么把所有仅该位为2的药水拿出来做第二轮测试，由于第二轮测试中该位全部为2，相当于回到了原来二进制的情况，不过位数少了一位，用剩下的3只测试就够了；如果第一轮测试没有小鼠死，那么去掉所有编码包含2的瓶子，这样只剩下了01编码的，回到了二进制，用剩下的4只小鼠测试即可


2、如果死的小鼠可以替换，那么相当于有8只小鼠，这样共可以测试 $2^8$ 瓶药水。另外一种思考方式为将药水按顺序每16个混合在一起做一轮测试，这样下一轮再测试16个。

**变体2**：如果有16瓶药水，有一瓶是毒药，请问需要多少只小鼠能找到14瓶不是毒药的药水

这个问题可以转换成找两瓶可能带毒药的，由于16瓶药水可以表示成 xxxx 的形式，所以只需要确定前面3位就能找到可能带毒药的；先相邻两位混合成共8瓶药水，用3只小鼠测试即可。




## 查找表

查找表是一个数组，一般事先计算好查找表，在后续使用时直接在查找表中索引即可，可以加速运算。

如计算DFT时，事先将旋转因子$W_N^{kn}$计算好，对于长度为 N 的DFT，查找表需要存储 N 个复数（$W_N^0$，$W_N^1$，...，$W_N^{N-1}$）


### 计算整数的二进制中1的个数

如 9 的二进制为 1001， 1的个数为2

简单的算法如下：

```python
def  countSetBits(n):
    count = 0
    while (n):
        count += n & 1
        n >>= 1
    return count
```

时间复杂度为 log(n)

使用查找表可以将时间复杂度降为1，查找表是一个256位的数组，存储0-255这256个数字中1的个数

```python
BitsSetTable256 = [0] * 256

def initialize():
	BitsSetTable256[0] = 0
	for i in range(256):
		# 如果最后一位为0，那么向右移动一位，1 的个数不变
		# 如果最后一位不为0，那么向右移动一位，1 的个数减1
		BitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2] 
```

有了查找表后，对于1个32位的整数 n，只需要将整数 n 的二进制分成四段（注意每一段需要移动到最后8位，并且屏蔽之前若干位），分别计算即可

```python
def countSetBits(n):
	return (BitsSetTable256[n & 0xff] +
			BitsSetTable256[(n >> 8) & 0xff] +
			BitsSetTable256[(n >> 16) & 0xff] +
			BitsSetTable256[n >> 24])
```


## 数组问题

数组中存储了数据（C/C++等）或者索引（Python，JS等），数组是连续地址，可以在常数时间完成随机访问


### 第k个最大和连续子序列

[K-th Largest Sum Contiguous Subarray - GeeksforGeeks](https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/)

找到一个序列中的连续子序列，该子序列之和从大到小排在第k位

常规的做法是用 $O(n^2)$  的时间获得所有的子序列之和，然后再排序，时间复杂度为 $O(n^2logn^2)$

可以使用前缀和以及最小堆优化，先计算序列的前缀和保存在数组中，这样子序列之和直接用数组的两个值相减即可，最小堆大小为k，如果最小堆的大小已经达到k，并且堆顶元素小于遍历到的元素，就pop出堆顶元素，把当前遍历到的元素push进堆里。

```python
import heapq
def kthLargestSum(arr, N, K):
    sum = []
    sum.append(0)
    sum.append(arr[0])  # 先计算前缀和
    for i in range(2, N + 1):
        sum.append(sum[i - 1] + arr[i - 1])

    Q = []
    heapq.heapify(Q)
    
    for i in range(1, N + 1):
    
        for j in range(i, N + 1):
            x = sum[j] - sum[i - 1]   # x 为某一段序列之和

            # 堆中元素数量小于 k
            if len(Q) < K:
                heapq.heappush(Q, x)
            else:
                if Q[0] < x:
                    heapq.heappop(Q)
                    heapq.heappush(Q, x)

    return Q[0]
```


### 最小子序列之和大于某个值

[Smallest subarray with sum greater than a given value - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-length-subarray-sum-greater-given-value/)

该问题可以先求前缀和，然后遍历前缀和，使用二分搜索搜索符合要求的值

一种更简单的方法为使用双指针，找到一个子序列，使其和大于某一个值，并且要求这个子序列长度最小。该序列所有值大于等于0。

```python
def smallestSubWithSum(x, arr):

    i, j = 0, 0
    sum = 0
    ans = float('inf')

    while j < len(arr):

        # 先增加窗口，使得窗口内的值的总和大于目标值
        while j < len(arr) and sum <= x:
            sum += arr[j]
            j += 1

        # 如果已经到了数组的末尾，并且仍然不能满足要求，停止
        if j == len(arr) and sum <= x:
            break

        # 在保证总和大于目标值的基础上缩小窗口
        while i < j and sum - arr[i] > x:
            sum -= arr[i]
            i += 1

        ans = min(ans, j - i)

        # 为了保证能继续向前，找到可能更小的子序列，向右移动
        sum -= arr[i]
        i += 1

    if ans == float('inf'):
        return 0
    return ans
```

如果同时移动两个指针可能有一些麻烦，可以考虑只移动一个指针

```python
def smallestSubWithSum(x, arr):
	n = len(arr)
	min_len = n + 1
	l = 0  # 左边的指针
	s = 0
	for i in range(n):  # i 为右边的指针，按照顺序向右移动即可
		s += arr[i]
		
		if s > x:
			min_len = min(min_len, i - l + 1)
		
		while l < i and s - arr[l] > x: 
		# 如果丢掉窗口最左边的元素，仍然能满足要求，就丢掉这个元素
			s -= arr[l]
			l += 1
			min_len = min(min_len, i - l + 1)
	if min_len == n + 1:
		return 0
	return min_len
```


### 统计数组中每一个元素右侧大于自己的数的数量

[Surpasser Count of Each Element in Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-surpasser-count-of-each-element-in-array/)

给定一个包含不同元素的数组，找到数组中在右侧大于自己的数（Surpasser）（$i< j$ 并且 $a[i]<a[j]$），并统计数量。

使用合并排序的思路进行求解

在合并排序中，需要将数组连续二等分，连续分到最后，只有一个值。由于数组中包含的是不同的元素，可以用一个字典保存各个元素的Surpasser的数量。在合并的时候，只需要考虑左侧数组，因为左侧数组在原数组的位置在右侧数组之前，如果左侧数组中的元素小于右侧数组中的某个值，那么之后的全都小于。

```python
def merge(arr, lo, mid, hi, m):
    n1 = mid - lo + 1
    n2 = hi - mid
    left = arr[lo:lo+n1]
    right = arr[mid+1:mid+1+n2]

    i = j = 0
    k = lo

    while i < n1 and j < n2:
      
        # right[j..n2] 的所有元素都大于 left[i]，所以加上 n2-j
        if left[i] < right[j]:
            m[left[i]] += n2 - j
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1

    while i < n1:
        arr[k] = left[i]
        i += 1
        k += 1

    while j < n2:
        arr[k] = right[j]
        j += 1
        k += 1

def mergeSort(arr, lo, hi, m):
    if lo < hi:
        mid = lo + (hi - lo) // 2

        # 分组
        mergeSort(arr, lo, mid, m)
        mergeSort(arr, mid + 1, hi, m)

        # 合并
        merge(arr, lo, mid, hi, m)

def findSurpasser(arr):
    n = len(arr)
    
    m = {key: 0 for key in arr}

    dup = arr[:]
    
    mergeSort(dup, 0, n - 1, m)
    
    res = [m[arr[i]] for i in range(n)]
    
    return res
```


> 如果是统计右侧小于自己的数，可以改成从大到小排

> 如果数组中包含重复元素，那么还需要有一个指数数组，或者更简单的，将数组改成 (num,  i) 这种形式，如下所示

```python
for i, a in enumerate(arr):
	m[(a, i)] = 0
	dup.append((a, i))
```


### 统计数组中前k个经常出现的元素

[Top K Frequent Elements in an Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-k-numbers-occurrences-given-array/)

一般做法是先统计频次，再排序。一种更好的方法是先统计频次，再使用一个最小堆来存储前k个频次最大的元素

```python
def topKFrequent(arr, k):

    mp = Counter(arr)
    pq = []
	# 最小堆存储前k个频次最大的元素
    for key, value in mp.items():
        heapq.heappush(pq, (value, key))
        if len(pq) > k:
            heapq.heappop(pq)  # 弹出频次最小的元素

    res = []
    
    while pq:
        res.append(heapq.heappop(pq)[1])

    res.reverse()   # 反转按照从小到大排
    return res
```

### 找到数据流中的中位数

[Find Median from Running Data Stream - GeeksforGeeks](https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/)

[295. 数据流的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-median-from-data-stream/description/)

给定一个数据流，如何找到中位数，假设有偶数个数，那么需要对中间两个进行平均。

使用堆实现，主要思路是维持两个堆，一个堆存储较小值，另一个堆存储较大值

注意 python 中只给出了最小堆的实现，最大堆可以通过每次传入数据时加上负号实现。

```python
import heapq

def getMedian(arr):
    
    # 最大堆：存储较小的一半
    leftMaxHeap = []
    
    # 最小堆：存储较大的一半
    rightMinHeap = []
    
    res = []
  
    for num in arr:
        # 先把新元素塞入最大堆
        heapq.heappush(leftMaxHeap, -num)
        
        # 将最大堆中的最大的元素塞入最小堆中，即将较小的一半中的最大值塞入较大的一半中
        temp = -heapq.heappop(leftMaxHeap)
        heapq.heappush(rightMinHeap, temp)
      
        # 如果最小堆中有更多的元素，将元素放在最大堆中
        if len(rightMinHeap) > len(leftMaxHeap):
            temp = heapq.heappop(rightMinHeap)
            heapq.heappush(leftMaxHeap, -temp)
        
        # 根据堆的大小来判断从什么地方取较大值
        if len(leftMaxHeap) != len(rightMinHeap):
            median = -leftMaxHeap[0]
        else:
            median = (-leftMaxHeap[0] + rightMinHeap[0]) / 2.0
        
        res.append(median)
    
    return res
```


### 给定范围内最常出现的整数

[Maximum occurring integer in given ranges - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-occurred-integer-n-ranges/)

两个等长的数组分别给出左端点和右端点，求出这些范围内最常出现的整数

使用 difference 数组求解：定义一个 `diff` 数组，`diff[left] += 1`，对应的 `diff[right+1] -=1`，这样 `diff` 中大于0的表示这里有多少个起点，小于0表示这里有多少个终点，求前缀和时最大值的位置即代表最常出现的数。

```python
MAX = 1000

def maximumOccurredElement(L, R, n):
 
    # 初始化 diff 数组
    arr = [0 for i in range(MAX)]
 
    # 左侧端点加1，右侧端点减1
    for i in range(n):
        arr[L[i]] += 1
        arr[R[i] + 1] -= 1
 
    # 计算前缀和，并且找到最大的前缀和
    msum = arr[0]
    for i in range(1, MAX):
        arr[i] += arr[i - 1]
        if (msum < arr[i]):
            msum = arr[i]
            ind = i
    return ind
```

该方法还能用于求是否存在重叠边界

[Check if any two intervals intersect in a given set - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-any-two-intervals-overlap-among-a-given-set-of-intervals/)

先求所有边界的最大值 N，初始化一个数组 `arr`，大小为N，对于每个间隔 `[a, b]`，`arr[a]+=1`，`arr[b+1]-=1`，然后求前缀和，如果前缀和中是否存在大于1的，如果有就是重叠

> 这种方法对于范围较大的数据而言，还是比较耗时的

### 买卖股票

[Stock Buy and Sell - At-most k Transactions Allowed - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-k-times/)


一个数组存储了每天的股票价格，问在给定的交易次数下，所获取的最大利润。该问题有如下三个变体：

1、如果只允许一次交易：最大利润为当前股票价格减去当前最小价格

```python
def maxProfit(prices):
    minSoFar = prices[0]
    res = 0

    for i in range(1, len(prices)):
        minSoFar = min(minSoFar, prices[i])  # 更新当前最小价格
                  
        res = max(res, prices[i] - minSoFar)
    
    return res
```


2、只允许至多两次交易：

一种做法是直接迭代两次，两个循环的思路和一个循环的基本一致

```python
class Solution:
    # 该函数和上面的函数等价，如果当前价格小于历史最低价格，就可以卖
    # 但是如果大于历史最低价格，就需要更新历史最低价格
    def maxProfit1(self, idx, arr):
        minP = arr[idx]
        profit = 0
        for i in range(idx + 1, len(arr)):
            if minP < arr[i]:
                profit = max(profit, arr[i] - minP)
            else:
                minP = arr[i]
        return profit
    
    def maxProfit(self, arr):
        minP = arr[0]
        profit = 0
        
        for i in range(1, len(arr)):
            if minP < arr[i]:
                profit = max(profit, arr[i] - minP + self.maxProfit1(i, arr))
            else:
                minP = arr[i]
        return profit
```

这样时间复杂度过高

另一种方法考虑到最多进行两次交易，因此可以分成两段，即从 0 到 i 进行一次交易，从 i 到 n-1进行一次交易。先计算 0 到 i 的交易所能获取的利润最大值，如果历史最低价格小于当前价格，那么可以选择卖或者不卖

```python
def maxProfit(arr):
	profit = 0
	profits = [0] * len(arr)
	
	minP = arr[0]
	# 计算从 0 到 i 的利润最大值
	for i in range(1, len(arr)):
		if minP < arr[i]:
			# 选择卖或者不卖
			profits[i] = max(profits[i-1], arr[i] - minP) 
			profit = max(profit, profits[i])
		else: # 当前价格较低，不卖，
			minP = arr[i]
			profits[i] = profits[i - 1]
	
	maxP = arr[-1]
	# 计算从 n-1 到i的利润最大值
	for j in range(len(arr) - 2, -1, -1):
		if maxP > arr[j]:
			profit = max(profit, maxP - arr[j] + profits[j])  
		else:
			maxP = arr[j]
	
	return profit
```


3、至多k次交易

最一般的方法是使用回溯法（递归），在某一天，只能进行三项操作，分别为买，卖和什么都不做

```python
def _solve(arr, i, k, state):
    if i == len(arr) or k == 0:
        return 0
    profit = 0
    if state == "buy":
        profit = _solve(arr, i + 1, k, state)   # 什么都不做
        profit = max(profit, _solve(arr, i + 1, k, "sell") - arr[i])  
    elif state == "sell":
        profit = _solve(arr, i + 1, k, state)   # 什么都不做
        profit = max(profit, _solve(arr, i + 1, k - 1, "buy") + arr[i])
    return profit

def solve(arr, k):
    profit = _solve(arr, 0, k, "buy")
    print(profit)
```

这种方法时间复杂度过高，存在大量重复计算步骤。

可以通过一个矩阵保存所有情况下的利润，避免重复计算。

```python
def solveProfit(arr, i, k, state, memo):
    if i == len(arr) or k == 0:
        return 0
    profit = 0
    if memo[i][k][state] != -1:
        return memo[i][k][state]
    
    if state == 1:
        profit = solveProfit(arr, i+1, k, state, memo)
        profit = max(profit, solveProfit(arr, i+1, k, 0, memo) - arr[i])
    elif state == 0:
        profit = solveProfit(arr, i+1, k, state, memo)
        profit = max(profit, solveProfit(arr, i+1, k-1, 1, memo) + arr[i])
    
    memo[i][k][state] = max(memo[i][k][state], profit)
    return profit

class Solution:
    
    def maxProfit(self, arr, k):
        
        n = len(arr)
        memo = [[[-1]*2 for _ in range(k + 1)]
            for _ in range(n)]
        profit = solveProfit(arr, 0, k, 1, memo)
        return profit
```


另外还有动态规划的方法，这样可以不使用递归

参考上面的递归过程，可以得出动态递归方程为（从后向前）：

```
Buy: dp[i][k][1] = max(dp[i+1][k][1], dp[i+1][k][0] - prices[i])

Sell: dp[i][k][0] = max(dp[i+1][k][0], dp[i+1][k-1][1] + prices[i])
```

这里的dp指的是在第`i`天，有`k`次交易机会，状态为 1（可以买）或 0（可以卖）会得到的收益。

下面是另一种规划方式的代码，此处的 `dp[i][j][s]` 表示的是到第 i 天，最多进行 j 次交易，状态为 s 时的收益 [188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

```python
def maxProfit(k: int, prices: List[int]) -> int:
	n = len(prices)
	dp = [[[0, 0] for _ in range(k+1)] for _ in range(n)]
	for j in range(1, k+1):
		dp[0][j][1] = -prices[0]   # 第 0 天，最多 j 次交易，状态为有股票
	for i in range(1, n):
		for j in range(1, k+1):
			# 第 i 天，最多 j 次交易，没股票：可以是前一天不买股票或者前一天卖股票
			dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])
			dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])
	return dp[-1][k][0]
```


### 在一个可以循环移位的序列中找到最大和子序列

首先在一个序列中找到最大和子序列的算法如下（Kadane算法）

```python
def findMaxSum(arr):
    n = len(arr)
    cur_sum = 0
    max_sum = -1e5
    for i in range(n):
        cur_sum = max(cur_sum+arr[i], arr[i])
        max_sum = max(max_sum, cur_sum)
    return max_sum
```

其思路是求前缀和，如果前缀和小于0，就将前缀和置为0（相当于重新开始一个子序列），重新开始求，前缀和的最大值就是最大和子序列。

对于本问题，由于序列可以循环移位，如果将所有移位的情形全部列举，时间复杂度过高。可以换一种思路，对于循环后的子序列的最大和子序列，其实相当于在原本的子序列中求最小和子序列，求完最小和之后用总和减去最小和即为最大和

```python
def circularSubarraySum(arr):

    n = len(arr)
    max_sum1 = findMaxSum(arr)
    
    s_sum = 0
    for i in range(n):  # 求数组总和，以及给数组元素取负
        s_sum += arr[i]
        arr[i] = -arr[i]
    
    min_sum = findMaxSum(arr)
    max_sum2 = s_sum + min_sum
    
    return max(max_sum1, max_sum2)
```


本题还有另外一个变体，在环形子数组中求最大和 [918. 环形子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

基本思路一致，都是求一个最大和子序列和最小和子序列，总和减去最小和子序列即为跨越头尾的子序列之和的最大值，不过需要注意如果最大和子序列本身小于0（数组中所有元素全部小于0），那就不需要再去求最小和子序列了。

```python
def maxSubarraySumCircular(nums: List[int]) -> int:
	n = len(nums)
	fmax, fmin = nums[0], nums[0]
	cmax, cmin = nums[0], nums[0]
	tot = nums[0]
	for i in range(1, n):
		cmax = max(cmax+nums[i], nums[i])
		cmin = min(cmin+nums[i], nums[i])
		fmax = max(fmax, cmax)
		fmin = min(fmin, cmin)
		tot += nums[i]

	# 如果fmax小于0，证明数组中全为负数，不需要考虑总和减去最小值了
	if fmax < 0: return fmax
	
	return max(fmax, tot - fmin)
```


### 直方图的最大矩形面积

[Largest Rectangular Area in a Histogram - GeeksforGeeks](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/)

通过数组给定一个直方图，找到这个直方图的最大矩形面积

一个简单的想法，对于每个直方图，我们分别在左右看是否有更大的直方图，如果有更大的，就再加上当前直方图的面积。

```python
def getMaxArea(arr):
    res = 0
    n = len(arr)
    
    for i in range(n):
        curr = arr[i]
        
        # 遍历左侧，找到一个更大的值
        j = i - 1
        while j >= 0 and arr[j] >= arr[i]:
            curr += arr[i]
            j -= 1
        
        # 遍历右侧，找到一个更小的值
        j = i + 1
        while j < n and arr[j] >= arr[i]:
            curr += arr[i]
            j += 1
        
        res = max(res, curr)
    
    return res
```

如果先能找到每个点左边比自己小的索引和右边比自己小的索引，就可以避免重复搜索了

```python
def solve(arr):
    n = len(arr)

    prev = [-1] * n
    next = [n] * n

    st = []
    # 找到后一个较小值
    for i in range(n):
        # 如果 i 比栈中最后一个元素要小
        while st and arr[i] < arr[st[-1]]:
            next[st.pop()] = i
        st.append(i)
    
    # 找到前一个较小值
    st = []
    for i in range(n):
        while st and arr[i] < arr[st[-1]]:
            st.pop()
        if st:
            prev[i] = st[-1]
        st.append(i)
    
    maxArea = 0
    for i in range(n):
        twidth = next[i] - prev[i] - 1
        maxArea = max(arr[i] * twidth, maxArea)
    return maxArea
```

这里在找到前一个较小值时，可以同时找到后一个较小值

```python
st = []
for i in range(n):
	while st and arr[i] < arr[st[-1]]:
		next[st.pop()] = i
	if st:
		prev[i] = st[-1]
	st.append(i)
```


### 数组的下一个排列

[31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/description/)

找到下一个字典序的排序


基本思路是从后向前，找到第一个降序排序的元素 x，然后再从最后向后向前找到第一个比 x 大的元素 y，交换 x 和 y 之后，此时原本 x 对应的位置之后的元素均为降序排序，需要将其转为升序排序（用两个指针交换前后元素即可）

```python
def nextPermutation(nums: List[int]) -> None:
	n = len(nums)
	i, j = n - 2, n-1
	while i >= 0 and nums[i] >= nums[j]:
		i -= 1
		j -= 1
	# 从后向前全是升序，返回倒序
	if i == -1:
		nums.reverse()
		return
	k = n - 1
	while k >= 0 and nums[i] >= nums[k]:
		k -= 1
	
	nums[i], nums[k] = nums[k], nums[i]

	# i 之后的需要升序排列，注意在调换完之后，i之后是降序排序交换一下即可
	l = i + 1
	r = n - 1
	while l < r:
		nums[l], nums[r] = nums[r], nums[l]
		l += 1
		r -= 1
```


### 缺失的第一个正数

[41. 缺失的第一个正数 - 力扣（LeetCode）](https://leetcode.cn/problems/first-missing-positive/description/)

需要在 `O(n)` 的时间复杂度和常数级别额外空间实现

首先需要将 `x` 放在第 `x-1` 位置

```python
for x in nums:
	while 1 <= x <= n and x != nums[x - 1]:
		nums[x - 1], x = x, nums[x - 1]
```

然后需要判断 `nums[i] != i + 1`，则返回 `i+1`

如果之前都符合，就返回 `len(nums)+1`

```python
def solve(nums):
	n = len(nums)
	for x in nums:
		while 1 <= x <= n and x != nums[x - 1]:
			nums[x - 1], x = x, nums[x - 1]
	
	for i in range(n):
		if nums[i] != i + 1:
			return i + 1
	return len(nums) + 1
```


### 寻找重复数

[287. 寻找重复数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-duplicate-number/)

一个长度为 n+1 的数组中，数字分布在 `[0,n]` 中，要求在常数空间、`O(n)` 时间内找到数组中的重复元素，该元素保证只有一个，出现两次或多次

如果不要求常数空间，可以通过哈希记录每个元素的位置，如果出现重复元素就返回。

如果将时间放宽一些，可以通过二分查找来实现，如果出现了一个变量是重复的，那么统计小于等于该变量的元素的个数，会发现个数大于等于这个变量。定义一个变量 `cnt` 统计小于等于 `mid` 的元素的数量，如果 `cnt > i`，证明该元素处于右半部分，否则处于左半部分

```python
def findDuplicate(nums: List[int]) -> int:
	n = len(nums)
	low, high = 1, n-1
	res = -1
	while low <= high:
		mid = low + (high - low) // 2
		cnt = 0
		for i in range(n):
			cnt += nums[i] <= mid
		if cnt <= mid:  # 计数小于mid，证明重复数在右半部分
			low = mid + 1
		else:
			high = mid - 1
			ans = mid
    return ans
```


基于二进制判断，将`[1, n]` 内的所有数字按照二进制展开，统计每一位 1 的数量，再将数组中每个数字都展开为二进制，统计每一位1的数量，如果两者数量不等，证明存在重复数，并且可以根据哪些位不等判断重复数的具体值

```python
def findDuplicate( nums: List[int]) -> int:
	n = len(nums)
	bit_max = 31
	while ((n - 1) >> bit_max) == 0: 
		bit_max -= 1
	ans = 0
	for bit in range(0, bit_max+1):
		x, y = 0, 0
		for i in range(n):
			if nums[i] & (1 << bit): # 统计数组中的每个值
				x += 1
			if i >= 1 and (i & (1 << bit)): # 统计[1, n]
				y += 1
		if x > y:
			ans |= 1 << bit
	return ans
```


快慢指针判环，对于数组每个位置连一条 `i->nums[i]` 的边，如果存在重复数字，那么重复数字一定有两条边，因此存在环。如 1 4 5 5 2 3 这个例子

`0->nums[0]=1`, `1->nums[1]=4`, `4->nums[4]=2`, `2->nums[2]=5`, `5->nums[5]=3`, `3->nums[3]=5`，出现环，并且环的起点为重复数字（注意似乎只能从0出发才能实现，并且并不是因为有重复数字才会出现环）

```python
def findDuplicate(nums: List[int]) -> int:
	slow = 0
	fast = 0  # 注意这里不能让fast先走一步，否则会出错
	while True:
		slow = nums[slow]
		fast = nums[nums[fast]]
		if fast == slow:
			break
	
	fast = 0
	while fast != slow:
		slow = nums[slow]
		fast = nums[fast]
	return fast
```



## 哈希问题

哈希最大的特点是可以实现常数时间搜索、插入和删除，主要用于实现不相等的元素，如键值对。

哈希表在存储时存在一个连续的存储空间中，在查找时根据 key 直接通过哈希算法计算出存储的地址。


### 子集问题

问一个集合 m 是否包含了另一个集合 n

1、最简单的是直接暴力搜索
2、先排序再搜索（使用自带的高效排序方法）
3、使用哈希

实现方式

```python
def isSubset(a, b):
	# 先获得a中的全部元素的集合
    hash_set = set(a)

    # 检查 b 中的元素是否都在 a 中
    for num in b:
        if num not in hash_set:
            return False
    return True
```


### 两数之和

在一个序列找到两个数和为目标值

一种常规做法是先排序，再用两个指针进行索引

哈希算法可以在一次迭代中找到：先按顺序选择一个值，然后看目标值减去这个值后的结果是否在集合里即可

为了找出所有的pair使得两数之和为目标值，还需要一个字典来记录序列中每个值出现的次数

```python
def countPairs(arr, target):
    freq = {}
    cnt = 0

    for i in range(len(arr)):
        
        # 仅考虑之前点和当前点是否能组成成对关系
        if (target - arr[i]) in freq:
            cnt += freq[target - arr[i]] 
        
        # 统计当前点及其之前点的频数
        freq[arr[i]] = freq.get(arr[i], 0) + 1 
    return cnt
```

这里的频率更新需要放在计数之后，放在前面则会导致如果 `arr[i]`和 `target-arr[i]` 相等会导致同一个位置相加。


>该问题还可以延申至矩阵中，将矩阵中的所有值用hashmap保存下来，然后对每个值判断其补值是否在hashmap中

### 三数之和

在一个序列找到三个数之和为目标值

先在外部循环确定好一个值，然后在内部循环时按照二数之和求

```python
def countTriplets(arr, target):
    cnt = 0
    n = len(arr)
    
    for i in range(n-2):
    # 先确定好 arr[i]
    # 内部循环按照二数之和求解
        freq = {}
        for j in range(i+1, n):
            if target - arr[i] - arr[j] in freq:
                cnt += freq[target - arr[i] - arr[j]]
            freq[arr[j]] = freq.get(arr[j], 0) + 1

    return cnt
```


为了节省空间，还可以先排序，先在外侧循环确定第一个数，再使用两个指针确定第2个和第3个数

```python
def threeSum(arr, target):
	n = len(arr)
	arr.sort()
	sols = []
	for i in range(n):
		# arr[i-1] 之前已经找过了，避免重复
		if i > 0 and arr[i] == arr[i-1]:
			continue
		
		l = i + 1  # 第二个数
		r = n - 1 # 第三个数
		
		while l < r:
			s = arr[i] + arr[l] + arr[r]
			if s == target:
				sols.append([arr[i], arr[l], arr[r]])
				l += 1
				r -= 1
				
				# 避免重复
				while l < r and arr[l] == arr[l-1]:
					l += 1
				
				while r > l and arr[r] == arr[r+1]:
					r -= 1
			
			elif s < target:
				l += 1
			else:
				r -= 1
			
	return sols
```


### 四数之和

对于四数之和，可以采用上面的思路，先确定两个值，再在内部循环时按照二数之和求解

还有另外一种思路，只在外部循环中确定第3个数的值，在频数中保存前两个数之和，然后循环第四个数

```python
def countSum(arr, target):
	freq = {}
	n = len(arr)
	cnt = 0
	# 确定第三个数的值
	for i in range(n-1):
		# 这是第四个数
		for j in range(i+1, n):
			temp = arr[i] + arr[j]   # 三四两个数之和
			if target - temp in freq:
				cnt += freq[target - temp]
		
		# 此处更新前两个数之和，再遍历下一个i之前，需要更新i之前的可能对之和
		for j in range(i):
			temp = arr[i] + arr[j]
			freq[temp] = freq.get(temp, 0) + 1
	return cnt
```

如果只需要判断四数之和是否存在，还有另外一种思路

[4 Sum - Check if a Quadruple with given Sum Exists in an Array - GeeksforGeeks](https://www.geeksforgeeks.org/find-four-numbers-with-sum-equal-to-given-sum/)

先计算前两个数字之和，将其作为键保存在字典里，对应的值为两个数字的坐标索引。再计算后两个数字之和，看目标减去这两个数字之和的结果是否位于字典里。

```python
def check4Sum(arr, target):
    n = len(arr)

    # 储存所有数字对之和
    mp = {}
    for i in range(n - 1):
        for j in range(i + 1, n):
            mp[arr[i] + arr[j]] = (i, j)

    # 遍历所有数字对
    for i in range(n - 1):
        for j in range(i + 1, n):
            sum_val = arr[i] + arr[j]

            # 如果 target - sum 在哈希表中
            if target - sum_val in mp:
                p = mp[target - sum_val]
                
                # 检查元素位置是否不同
                if p[0] != i and p[0] != j and p[1] != i and p[1] != j:
                    return True

    return False
```


上面求出的答案会出现重复，如果要求答案不重复，还是用排序双指针来做，再加上一些剪枝

```python
def fourSum(nums, target):
	n = len(nums)
	nums.sort()
	res = []

	for i in range(n-3):
		if i > 0 and nums[i] == nums[i-1]:
			continue
		
		# 如果 nums[i] 和后三个数相加仍小于target，无需继续
		if nums[i] + nums[n- 3] + nums[n - 2] + nums[n - 1] < target:
			continue

		for j in range(i+1, n-2):
			if j > i + 1 and nums[j] == nums[j-1]:
				continue
			# 如果前四个数已经超过目标值，无需后续判断
			if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:
				break
			
			nt = target - nums[i] - nums[j]

			l = j + 1
			r = n - 1
			while l < r:
				if nums[l] + nums[r] == nt:
					res.append([nums[i], nums[j], nums[l], nums[r]])
					l += 1
					r -= 1
					# 避免重复
					while l < r and nums[l] == nums[l-1]:
						l += 1

					while r > l and nums[r] == nums[r + 1]:
						r -= 1
				elif nums[l] + nums[r] > nt:
					r -= 1
				else:
					l += 1
	return res
```


### 最长子序列之和被K整除

对于一个序列，找到其中的一个最长子序列，使其之和能被 K 整除。

使用一个hash（实际上是字典）保存前缀和及其对应位置

```python
def longestSubarrayDivK(arr, k):
    n = len(arr)
    res = 0
    prefIdx = {}
    sum = 0

    for i in range(n):

        # 前缀和被 k 除的结果
        sum = (sum + arr[i]) % k

        # 如果 sum 等于0，证明从 0 到 i 的子序列之和能被k整除
        if sum == 0:
            res = i + 1
        # 如果 sum 在字典中已经存在，证明这两个点之间的元素之和能被k整除
        elif sum in prefIdx:
            res = max(res, i - prefIdx[sum])
        # 记录第一次出现sum时的位置
        else:
            prefIdx[sum] = i

    return res
```

存储所有前缀和出现的位置，这样如果再次出现这个前缀和，就证明这两个前缀和中间的序列之和能被 K 整除。


### 最长子序列之和为 K

与上一个题目类似，使用一个字典保存前缀和，然后判断当前和减去目标值的结果是否在前缀和字典中。

```python
def subarraySum(arr, target):
	n = len(arr)
	prefixs = {}
	s = 0
	for i in range(n):
		s += arr[i]
		
		if s == target:
			return [1, i+1]
		
		if s - target in prefixs:
			return [prefixs[s - target]+1, i+1]
		
		prefixs[s] = i + 1
	return [-1]
```


### 最长连续序列

[128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/)

求一个数组中数字连续最长的序列，不要求原本的位置连续

使用哈希表存储所有的数字，对于每个数字只有在其下一个数存在时，才会计数加1，这里有一个注意的地方，为了保证时间复杂度为 `O(n)`，只会在连续序列的头部进行内部循环

```python
def longestConsecutive(nums) -> int:
	num_set = set(nums)
	max_len = 0
	for num in num_set:
		if num - 1 not in num_set:  # 保证为最开始的元素
			cnum = num
			cres = 1

			while cnum + 1 in num_set:
				cnum += 1
				cres += 1
			max_len = max(max_len, cres)
	return max_len
```


### 找到所有的序列对(a,b)使得 a%b = k

[Find all pairs (a, b) in an array such that a % b = k - GeeksforGeeks](https://www.geeksforgeeks.org/find-pairs-b-array-b-k/)

分成两种情况，这两种情况可以同时存在

+ 如果 k 在数组中，并且存在比k大的数，那么存在一个序列对
+ 如果一个数大于k，进行如下分析
$$
\eqalign{
  & a\% b = k  \cr 
  & a = n*b + k  \cr 
  & a - k = n*b \cr} 
$$
因此只需要找到 a-k 的因子即可，因子分解的算法如下

```python
def findDivisors(n):
    v = []
    for i in range(1, mt.floor(n**(.5)) + 1):
        if (n % i == 0):
            
            # 如果 n 是平方数，只存储一次 n
            if (n / i == i):
                v.append(i)
            else:
                v.append(i)
                v.append(n // i)
    return v
```

注意不是所有的因子都可以，需要测试一下。

```python
def printPairs(arr, k):
	n = len(arr)
	ans = 0
	occ = {}

	# 创建一个字典，记录所有出现的元素
	for num in arr:
		occ[num] = True

	# 遍历数组中的元素
	for num in arr:
		# 如果 k 在数组中，并且某个元素大于k，那么存在一个序列对
		if k in occ and k < num:
			ans += 1

		# 如果这个元素大于等于k
		if num >= k:
			divisors = findDivisors(num - k)
			for divisor in divisors:
				# 如果num % divisor = k，并且 num 不等于 divisor，divisor存在于数组中
				if num % divisor == k and num != divisor and divisor in occ:
					ans += 1

	return ans
```


### 找到包含所有不重复元素的子序列

对于一个序列，其中一些元素是重复的，找到包含所有不重复元素的子序列

一般的做法是，通过两个循环，外部循环遍历序列左端，内部序列遍历序列的右端，判断是否存在所有的不重复元素

可以使用滑动窗口解决这一问题，先固定左端，再将右端移动至包含所有的不重复元素的位置（判断是否包含所有不重复元素时，可以用一个变量表示不重复元素的数量）。此时右端所有的子序列都包含了所有不重复元素。然后向右移动左端，并更新不重复元素的数量。

```python
def countDistinctSubarray(self,arr, n): 
	uset = set(arr)
	k = len(uset)  # 不重复元素的数量
	window = 0  # 记录窗口内不重复元素的数量
	vid = {}  # 记录窗口内各个值出现频次
	right = 0
	cnt = 0
	for left in range(n):
		while right < n and window < k:
			vid[arr[right]] = vid.get(arr[right], 0) + 1
			
			# 窗口内出现了新元素
			if vid[arr[right]] == 1:
				window += 1
			right += 1
		# 如果当前窗口的不重复元素满足要求，则后面所有的连续子序列都满足要求
		if window == k:
			cnt += n - right + 1

		# 窗口左侧将要缩小，失去最左侧元素
		vid[arr[left]] -= 1
		
		# 窗口将要失去一个新元素
		if vid[arr[left]] == 0:
			window -= 1
	return cnt
```


### 求序列中的多数元素

[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/description/)

如果要求空间复杂度为1，并且必定存在多数元素，可以使用 Boyer-Moore 投票算法，将多数元素看为一类，其它元素看为另一类。

初始时，假定序列最开始的元素为多数元素 `maj`，设置一个计数器 `cnt`。遍历序列，如果遍历元素 `a` 等于当前多数元素 `maj`，则 `cnt` 加1，否则 `cnt` 减1，当计数重新为0时，更新多数元素。在上述过程中，当 `cnt` 为0时，证明当前所选的 `maj` 并不能满足多数元素的条件，并且之前的所有元素都不能满足，因此需要挑选一个新元素作为 `maj`。

```python
def majorityElement(nums) -> int:
	major = None
	count = 0
	for n in nums:
		if count == 0:
			major = n
		if n == major:
			count += 1
		else:
			count -= 1
	return major
```


如果是找出出现次数大于 `n/3` 的所有元素，[229. 多数元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element-ii/description/)

该问题也可以用Boyer-Moore 投票方法

```python
def majorityElement(nums: List[int]) -> List[int]:
	ans = []
	element1, element2 = 0, 0
	vote1, vote2 = 0, 0

	for num in nums:
		# 如果该元素为第一个元素，则计数加1
		if vote1 > 0 and num == element1:
			vote1 += 1
		# 如果该元素为第二个元素，则计数加1
		elif vote2 > 0 and num == element2:
			vote2 += 1
		# 选择第一个元素
		elif vote1 == 0:
			element1 = num
			vote1 += 1
		# 选择第二个元素
		elif vote2 == 0:
			element2 = num
			vote2 += 1
		# 如果三个元素均不相同，则相互抵消1次
		else:
			vote1 -= 1
			vote2 -= 1

	cnt1, cnt2 = 0, 0
	for num in nums:
		if vote1 > 0 and num == element1:
			cnt1 += 1
		if vote2 > 0 and num == element2:
			cnt2 += 1        
	# 检测元素出现的次数是否满足要求
	if vote1 > 0 and cnt1 > len(nums) / 3:
		ans.append(element1)
	if vote2 > 0 and cnt2 > len(nums) / 3:
		ans.append(element2)

	return ans
```



### 多数元素大于K的最长子序列

[Longest Subarray having Majority Elements Greater Than K - GeeksforGeeks](https://www.geeksforgeeks.org/length-of-longest-subarray-in-which-elements-greater-than-k-are-more-than-elements-not-greater-than-k/?ref=rp)

给定一个序列，在这个序列中找到一个最长子序列，要求子序列中的多数元素大于k。

建立一个辅助序列，原序列中大于k的元素记为1，否则记为-1，并且计算这个辅助序列的前缀和，前缀和的范围为 `[-n,n]`。对于序列 `arr[0:i]` 的前缀和 s，我们需要找到在 `i` 之前最左侧的比 s 还小的前缀和，这里如果每次都去求一次最小的前缀和显然太麻烦了，因此可以创建一个数组 `prefidx` 记录每个前缀和首次出现的位置，并且每个前缀和出现的位置都取前面最小的，这样便可以直接通过 `prefidx[s-1]` 的位置找到前面最小的。

```python
def longestSubarray(arr, k):
	n = len(arr)
	preidx = {}
	s = 0
	for i in range(n):
		if arr[i] > k:
			s += 1
		else:
			s -= 1
		if s not in preidx:
			preidx[s] = i
	# -n 在 preidx 中证明所有元素都小于k，无需继续
	if -n in preidx:
		return 0
	
	preidx[-n] = n

	# 记录每个小于等于前缀和 i 的前缀和出现的最早的位置
	for i in range(-n+1, n+1):
		if i not in preidx:
			preidx[i] = preidx[i-1]
		else:
			preidx[i] = min(preidx[i], preidx[i - 1])
	
	s = 0
	res = 0
	for i in range(n):
		if arr[i] > k:
			s += 1
		else:
			s -= 1
		if s > 0:
			res = i + 1
		else:
			res = max(res, i - preidx[s - 1])
	return res
```


### 找到包含K个不同元素的最小序列

[Smallest subarray with k distinct numbers - GeeksforGeeks](https://www.geeksforgeeks.org/smallest-subarray-k-distinct-numbers/)

给定一个序列，找到一个包含K个不同元素的最小序列，使用滑动窗口解决这一问题

```python
from collections import defaultdict

def minRange(arr, n, k): 

	# 初始化左右两侧
	l, r = 0, n 
	i = 0
	j = -1
	
	hm = defaultdict(lambda:0)   # 存储不同元素的出现频次
	while i < n: 
	
		while j < n: 
			j += 1

			# 如果不同元素的数量小于k
			if len(hm) < k and j < n:
				hm[arr[j]] += 1

			# 如果不同元素的数量等于k，并且长度会更小
			if len(hm) == k and ((r - l) >= (j - i)):
				l, r = i, j 
				break

		# 如果不同元素的数量小于k，停止循环
		if len(hm) < k:
			break

		# 保证不同元素的数量等于k的基础上，缩小左侧边界
		while len(hm) == k: 

			if hm[arr[i]] == 1: 
				del(hm[arr[i]]) 
			else:
				hm[arr[i]] -= 1
			i += 1
			
			if len(hm) == k and (r - l) >= (j - i): 
				l, r = i, j 
		# 左侧边界向右移动，探索其它可能
		if hm[arr[i]] == 1: 
			del(hm[arr[i]]) 
		else:
			hm[arr[i]] -= 1
			
		i += 1

	if l == 0 and r == n:
		print("Invalid k") 
	else:
		print(l, r) 
```


### 分数简化显示

[Fraction to Recurring Decimal - GeeksforGeeks](https://www.geeksforgeeks.org/represent-the-fraction-of-two-numbers-in-the-string-format/)

考虑两个数 a 和 b，`rem=a%b` 是余数，我们用一个字典记录rem首次出现时的结果字符串长度，如果rem能再次出现，那么结果字符串就是首次出现之前的字符串加上括号加之后的字符串

```python
def calculateFraction(a, b):
    if a == 0:
        return "0"
        
    res = "-" if (a < 0) ^ (b < 0) else ""

    a = abs(a)
    b = abs(b)

    # 计算非小数部分
    res += str(a // b)

    rem = a % b

    # 完全可除，返回结果
    if rem == 0:
        return res

    res += "."
    mp = {}

    while rem > 0:
        # 如果余数出现过，证明存在循环小数
        if rem in mp:
            res = res[:mp[rem]] + "(" + res[mp[rem]:] + ")"
            break
        
        # 记录第一个见到某个余数时，结果的长度
        mp[rem] = len(res)

        rem = rem * 10
        
        res += str(rem // b)
        rem = rem % b

    return res
```


### 最长双调序列

[Longest Bitonic Subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/)

在一个序列中找到最长的双调序列，双调序列指严格的先增加后减小

参考最长增长子序列的做法，对于每个元素，求以该元素结尾的最长增长子序列长度和以该元素开始的最长下降子序列的长度。如果两个长度都大于1，那就可以求双调序列的长度。

```python
def LongestBitonicSequence(n : int, arr) -> int:
	def lis(arr):
		n = len(arr)
		dp = [1] * n
		
		for i in range(1, n):
			for j in range(i):
				if arr[i] > arr[j]:
					dp[i] = max(dp[i], 1+dp[j])
		return dp
	
	left = lis(arr)
	# 求最长下降子序列，可以直接通过翻转列表之后按照最长增长子序列求
	right = lis(list(reversed(arr)))
	max_len  = 0
	for i in range( n):
		if left[i] > 1 and right[n-i-1] > 1:  # 这里最长下降需要做一个对称
			max_len = max(max_len, left[i]+right[n-1-i]-1)
	return max_len
```

如果严格增加1或减小1，有更简单的解决方法

[Length of longest strict bitonic subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/length-longest-strict-bitonic-subsequence/)

用字典保存之前出现过的数字及其最长递增，递减长度，再额外设置一个数组保存每个位置的最长递增，递减长度

```python
def longLenStrictBitonicSub(arr, n):
    inc, dec = defaultdict(int), defaultdict(int)
    len_inc, len_dec = [0] * n, [0] * n  # 保存每个位置的最长递增，递减序列长度
    for i in range(n):
        # 判断 arr[i] - 1 是否在之前的序列中出现，不存在返回0
        l = inc[arr[i] - 1] 
        inc[arr[i]] = len_inc[i] = l + 1
    
    for i in range(n-1, -1, -1):
        l = dec[arr[i] - 1]
        dec[arr[i]] = len_dec[i] = l + 1
        
    max_len = 0
    for i in range(n):
        max_len = max(max_len, len_inc[i] + len_dec[i] - 1)
    return max_len
```


### 找到相同的子树

[Find All Duplicate Subtrees - GeeksforGeeks](https://www.geeksforgeeks.org/find-duplicate-subtrees/)

给定一个树，找到树中相同的子树（包括结构和值）

采用中序遍历，将每个节点的遍历结果变成字符串保存在字典中，看是否有相同的字符串。

```python
def inorder(node, m, res):
	if not node:
		return ""
	_str = "("
	_str += inorder(node.left, m, res)
	_str += str(node.data)
	_str += inorder(node.right, m, res)
	_str += ")"
	
	if _str in m and m[_str] == 1:
		res.append(node)
	
	if _str in m:
		m[_str] += 1
	else:
		m[_str] = 1
	return _str

def printAllDups(root):
	m = {}
	res = []
	inorder(root, m, res)
	return res
```


### 找到角点均为1的矩阵

[Find if there is a rectangle in binary matrix with corners as 1 - GeeksforGeeks](https://www.geeksforgeeks.org/find-rectangle-binary-matrix-corners-1/)

在一个大矩阵中找到所有角点均为 1 的小矩阵

一般的方法是直接枚举行和列的组合，这种方法时间复杂度过高，可以使用哈希表来降低复杂度。这个哈希表用来储存每行两列元素全为1的组合，如 j 列 和 k 列元素为1，则 `table[j]` 添加 k，即对于第 `j` 列，第 `k` 列是为1的，对应的 `table[k]` 添加 `j` 

只需要遍历一次行，然后枚举列的组合。每次遍历行时，如果两列 `j` 和 `k` 对应的值均为1，则判断 `k` 是否位于 `table[j]`，或者 `j` 是否位于 `table[k]`

```python
def ValidCorner(matrix): 
	from collections import defaultdict
	table = defaultdict(set)
	m = len(matrix)
	n = len(matrix[0])
	for i in range(m):
		for j in range(n-1):
			for k in range(j+1, n):
				if matrix[i][j] != 1 or matrix[i][k] != 1:
					continue
				# 如果当前行的 j 列和 k 列元素均为1
				# 则考虑历史行中是否存在 j 列和 k 列元素均为0
				if j in table and k in table[j]:
					return True
				if k in table and j in table[k]:
					return True
				
				table[j].add(k)
				table[k].add(j)
	return False
```



## 搜索问题

搜索分为线性搜索，二分搜索和双指针技术

线性搜索主要用于未排序的列表、小数据、链表等。线性搜索往往需要在每一次循环中进行一次条件判断，可以在列表的末尾添加目标值，这样直接用while

```python
def sentinelSearch(arr, n, key):
	# 保存最后一个元素
    last = arr[n - 1]

    # 要搜索的元素放在末尾
    arr[n - 1] = key
    i = 0

    while (arr[i] != key):
        i += 1

    # 恢复最后一个元素
    arr[n - 1] = last
    
	# 如果没有到达最后一个元素就找到，或者就是最后那个元素
    if ((i < n - 1) or (arr[n - 1] == key)):
        print(key, "is present at index", i)
    else:
        print("Element Not found")
```

二分搜索实现如下，需要数据排好序，或者有一定的规律

```python
def binarySearch(arr, low, high, x):
	# low = 0, high = len(arr) - 1

    while low <= high:  # 等于号用于处理arr只有单个元素

        mid = low + (high - low) // 2

        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```

>如果是一个无限的有序数组，可以采用自定义边界的方法，如
>第一轮搜索 [0, 1]
>第二轮搜索 [1, 2]
>第三轮搜索 [2, 4]
>第四轮搜索 [4, 8]

双指针技术用两个指针同时索引，一般一个位于开始，另一个位于末尾，并且对于数据有一定的排序要求。

Python 的bisect包提供了 `bisect_left` 和 `bisect_right`，其中 `bisect_left` 是找到小于等于 `x` 的位置（尽量偏左），`bisect_right` 是找到大于等于 `x` 的位置（尽量偏右）。

```python
# bisect_left
def bl(arr, x):
    l, r = 0, len(arr) - 1
    while l <= r:
        mid = l + (r - l) // 2
        if x <= arr[mid]:  # 这里是小于等于
            r = mid - 1
        else:
            l = mid + 1
    return l

# bisect_right
def br(arr, x):
    l, r = 0, len(arr) - 1
    while l <= r:
        mid = l + (r - l) // 2
        if x < arr[mid]: # 这里是小于
            r = mid - 1
        else:
            l = mid + 1
    return l
```


### 三分搜索

```python
def ternarySearch(l, r, key, ar):
    while r >= l:
        
        mid1 = l + (r-l) // 3
        mid2 = r - (r-l) // 3
        
        if key == ar[mid1]:
            return mid1
        if key == ar[mid2]:
            return mid2
		# 如果key位于mid右边
        if key < ar[mid1]:
            r = mid1 - 1
        elif key > ar[mid2]:
            l = mid2 + 1
        else:
            l = mid1 + 1
            r = mid2 - 1
    return -1
```


### 在未排序的数组中找到第K个最小的数

1、先排序再找，时间复杂度为 nlog(n)，空间复杂度为 1
2、用最大堆保存K个数，时间复杂度为 nlog(K)，空间复杂度为 K
3、快速选择算法，虽然最差情况下时间复杂度为 $n^2$，但是实践使用时是快的。

快速选择算法基于快速排序算法，partition的部分一致，只是在后续搜索时有差别，当找到pivot的位置时，比较该位置左侧是否包含了k-1个数，如果包含了，那么pivot就是需要的数，如果左侧大于k-1个数，就在左侧找，否则在右侧找。

```python
def partition(arr, l, r):
    pivot = arr[l]
    index = l
    i, j = l, r

    while i < j:
        while i < j:  # 先处理右侧
            if arr[j] < pivot:
                arr[index] = arr[j]
                index = j
                break
            j -= 1
        while i < j:
            if arr[i] > pivot:
                arr[index] = arr[i]
                index = i
                break
            i += 1
        
    arr[index] = pivot
    return index

def kthSmallest(arr, l, r, k):
	# 分割数组
	index = partition(arr, l, r)

	# 如果位置和 k 相等
	if (index == k - 1):
		return arr[index]

	# index 左侧元素数量超过了 k，在左边寻找
	if (index > k - 1):
		return kthSmallest(arr, l, index - 1, k)

	# 否则在右边寻找，注意 k 要减去左边元素的数量
	return kthSmallest(arr, index + 1, r, k)
```

### 在旋转后的排序数组中搜索

[33. 搜索旋转排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

对于一个排好序的数组，如果进行了部分循环移位，在这种数组进行搜索

1、使用两次二分搜索，第一次搜索最小值的位置，再根据最小值的位置进行二分搜索
2、在上面搜索最小值时，已经用了这样的原理，即 mid 左侧或者右侧的数组必定有一侧是排好序的，如对于左侧，只要 `arr[low]<arr[mid]` 那么就是排好序的，如果 key 落在`arr[low]` 和 `arr[high]` 这个范围之内，就在左侧找，反之就在右侧找。 

```python
def search(arr: List[int], target: int) -> int:
	n = len(arr)
	l, r = 0, n - 1

	while l < r:
		mid = l + (r - l) // 2

		if arr[mid] == target:
			return mid   
		if arr[l] == target:
			return l
		if arr[r] == target:
			return r   

		if arr[l] < arr[mid]:  # 如果左侧排好序
			if target > arr[mid] or target < arr[l]:
				l = mid + 1
			else:
				r = mid - 1
		else:    # 右侧排好序
			if target < arr[mid] or target > arr[r]:
				r = mid - 1
			else:
				l = mid + 1
	
	if arr[l] == target:  # 处理只有一个元素的情况
		return l
	return -1
```


### 在旋转后的数组中找到最小值

[153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)

如果 `arr[mid]>arr[r]` 证明右半部分出现了乱序，那么最小值在右半部分，设置 `l=mid+1`，反之在左半部分，为了避免 mid 指向的就是最小值所以设置 `h = mid`

```python
def findMin(nums):
	n = len(nums)
	l, r = 0, n - 1
	while l <= r:
		if l == r:
			return nums[l]
		if r == l + 1:
			return min(nums[l], nums[r])
		
		mid = l + (r - l) // 2

		if nums[mid] > nums[r]:
			l = mid + 1
		else:
			r = mid
```


### 在三个排好序的数组中找到最相近的数

有三个已经排好序的数组，现在要找到三个数组中最相近的三个数

使用三个指针分别索引这三个数组，每次会索引到三个数，求出这三个数中的最大值和最小值，然后计算最大值和最小值之间的差值，每次循环时只更新最小值对应的数组索引。

```python
def findCloset(A, B, C, p, q, r):
    diff = 1e9
    res_i, res_j, res_k = 0, 0, 0   # 保存结果
	i, j, k = 0, 0, 0
	
    while(i < p and j < q and k < r):
        
        minimum = min(A[i], min(B[j], C[k]))
        maximum = max(A[i], max(B[j], C[k]));
 
        # 如果目前差距小于最小差距
        if maximum-minimum < diff:
            res_i, res_j, res_k = i, j, k
            diff = maximum - minimum;

        if diff == 0:
            break
            
        # 移动最小元素的指针
        if A[i] == minimum:
            i = i+1
        elif B[j] == minimum:
            j = j+1
        else:
            k = k+1
```


### 求两个相同大小的有序数组合并后的中位数

https://www.geeksforgeeks.org/median-of-two-sorted-arrays

一种方法是使用归并排序中的归并方法

另一种方法是使用二分搜索，这里的二分搜索需要利用到中位数的一个性质，对于一个长度为 2n 的数组，中位数之前需要有 n-1 个数，因此如果确定了一个数组的 mid，另一种数组的 mid可以设置为 n-mid，这里的 mid 并不指一个元素，而是两个元素之间的边界，mid两边的元素分为记为`l`和`r`，只要满足两个数组的 `l` 和 `r` 相互交叉即可。

```python
def getMedian(a, b):
    n = len(a)
    low, high = 0, n
    
    while low <= high:
      
        # 数组 a 的中点
        mid1 = low + (high - low) // 2
        
        # 数组 b 的中点
        mid2 = n - mid1
        
        # 确定中点两边的元素
        l1 = float('-inf') if mid1 == 0 else a[mid1 - 1]
        r1 = float('inf') if mid1 == n else a[mid1]
        
        l2 = float('-inf') if mid2 == 0 else b[mid2 - 1]
        r2 = float('inf') if mid2 == n else b[mid2]
        
        # 如果存在合理划分
        if l1 <= r2 and l2 <= r1:
            return (max(l1, l2) + min(r1, r2)) / 2.0
	    
        if l1 > r2:
            high = mid1 - 1    
        else:
            low = mid1 + 1
    
    return 0
```


如果两个数组大小不相同，也可以按照这种方法，不过需要处理一边数据过多时的情况

```python
def findMedianSortedArrays(self, nums1, nums2) -> float:
	m = len(nums1)
	n = len(nums2)

	if n > m:
		return self.findMedianSortedArrays(nums2, nums1)

	half = (m + n) // 2  # 一半数据

	low, high = 0, m
	while low <= high:
		mid = low + (high - low) // 2

		ml = float("-inf") if mid <= 0 else nums1[mid-1]
		mr = float("inf") if mid >= m else nums1[mid]

		nmid = half - mid  # 另一个数组的分界点
		# 处理一边过多数据时的情况
		if nmid > n:
			low = mid + 1
			continue
		if nmid < 0:
			high = mid - 1
			continue

		nl = float("-inf") if nmid <= 0 else nums2[nmid-1]
		nr = float("inf") if nmid >= n else nums2[nmid]

		if mr < nl:
			low = mid + 1
		elif nr < ml:
			high = mid - 1
		else: # 存在交点（相等也是交点）
			# 奇偶分类
			if (m + n) & 1 == 1:
				return min(mr, nr)
			else:
				return (max(nl, ml) + min(mr, nr)) / 2
```


### 在一个几乎排好序的数组中搜索

已有一个几乎排好序的数组，`arr[i]` 只会和 `arr[i-1]` 或者 `arr[i+1]` 交换位置

可以使用二分查找，不过需要考虑 mid, mid - 1 和 mid + 1三个位置，在判断mid-1和mid+1时，还需要注意不能让其超出`l`和 `r`

```python
def binarySearch(arr, l, r, x):

    if (r >= l):

        mid = int(l + (r - l) / 2)

        # 判断目标值是否在mid，mid-1和mid+1这三个位置
        if (arr[mid] == x):
            return mid
        if (mid > l and arr[mid - 1] == x):
            return (mid - 1)
        if (mid < r and arr[mid + 1] == x):
            return (mid + 1)

        if (arr[mid] > x):
            return binarySearch(arr, l, mid - 2, x)

        return binarySearch(arr, mid + 2, r, x)
        
    return -1
```


## 排序问题


对于链表，归并排序往往比较好


### 排序方法


#### 选择排序

从未排序的数组中找到最小（或最大）的元素放在开始，时间复杂度为 $O(n^2)$，内存占用率很低

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):

        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```


#### 冒泡排序

两次遍历，内部遍历时，如果当前值大于下一个值就交换位置

```python
def bubbleSort(arr):
    n = len(arr)
    
    # 遍历数组
    for i in range(n):
        swapped = False

        # 最后的 i 个值已经放好了
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if swapped == False:
            break
```


#### 插入排序

从数组的第二个元素开始，找到其在前面应该所处的位置。

```python
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
		# 如果 key 小于 arr[i]，向后移动
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
```


#### 堆排序

[Heap Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks](https://www.geeksforgeeks.org/heap-sort/)

将数组看成是完全二叉树，对于一个长度为n的数组，根节点位于0，i 节点的左节点位于2i+1，右节点位于2i+2。

创建一个最大堆：保证父节点比子节点大，如果子节点比父节点大，就交换子节点和父节点。

排序：将最大的元素与未排序的数组最后一位交换，然后继续创建最大堆。

下面是堆排序的实现过程

```python
# 建立最大堆
def heapify(arr, n, i):
    largest = i     # 根节点
    l = 2 * i + 1   # 左子节点
    r = 2 * i + 2   # 右子节点

    if l < n and arr[l] > arr[largest]:
        largest = l
    
    if r < n and arr[r] > arr[largest]:
        largest = r
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)   # 继续排列下面的节点

def heapSort(arr):
    n = len(arr)
    # 从最下层开始
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
	# 此时排列完，最大的元素在数组的开始
	
	# 下面逐步将最大的元素放到末尾
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)  # 将最大元素放在数组开始
```



#### 快速排序

对于一个序列，先选定一个值作为pivot，将数组排列成pivot右侧的值都大于等于pivot，左侧的值都小于等于pivot。

具体排列方法如下：首先选定一个pivot，一般选定子数组的左端，该位置记为index，另外分别从子数组的左端（记为left）和右端（记为right）向中间进发，先从右端开始。

从右端开始遍历，如果`arr[right]` 比 pivot 大，继续遍历，如果`arr[right]`小于 pivot，令`arr[index]` 等于`arr[right]`，然后将 right 这个位置记为新的 index。

右端暂时遍历完后，从左端开始遍历，同样的如果`arr[left]` 大于 pivot，令 `arr[index]` 等于 `arr[left]`，然后将 left 这个位置记为新的 index。

如此循环下去，直到 left 大于 right，循环结束之后，令`arr[index]`等于 pivot。

```python
def partition(arr, l, r):
    i = l
    j = r

    pivit = arr[l]
    index = l
    while i < j:
		# 在右侧找到小于pivot的值
        while j > i:
            if arr[j] < pivit:
                arr[index] = arr[j]
                index = j
                break
            j -= 1
        # 在左侧找到大于pivot的值
        while j > i:
            if arr[i] > pivit:
                arr[index] = arr[i]
                index = i
                break
            i += 1
    arr[index] = pivit
    return index

def quickSort(arr, l, r):
    if l < r and l >= 0:

        idx = partition(arr, l, r)

        quickSort(arr, l, idx-1)
        quickSort(arr, idx+1, r)
    
arr = [ 1, 3, 2, 0, 8 ]
n = len(arr)
quickSort(arr, 0, n-1)
```

对于已经排好序的数组，会出现时间复杂度为 $O(n^2)$ 的情况，为了避免这种情况，可以随机选择pivot，并将其移到数组最左端

```python
index = random.randint(l, r)
pivit = arr[index]
arr[index], arr[l] = arr[l], arr[index]
index = l 
```

对于数组包含大量重复元素的情况，可以在进行递归前进行判断（需要partition函数返回pivot）

```python
idx, pivit = partition(arr, l, r)
li = idx - 1
ri = idx + 1

while li > l and arr[li] == pivit:
	li -= 1
while ri < r and arr[ri] == pivit:
	ri += 1

quickSort(arr, l, li)
quickSort(arr, ri, r)
```

partition 函数的另外一种写法

```python
def partition(arr, l, r):
    x = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= x:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            
    arr[i], arr[r] = arr[r], arr[i]
    return i
```


#### 基数排序

基数排序是一种非比较的排序方法，对每一位进行排序，先对低位排序，然后收集起来（即计数排序），再按照高位排序，直至最高位

```python
def countingSort(arr, exp1):

    n = len(arr)
    output = [0] * (n)

    count = [0] * (10)
	# 统计出现频次
    for i in range(0, n):
        index = arr[i] // exp1
        count[index % 10] += 1

    # 使count[i]包含之前的元素
    for i in range(1, 10):
        count[i] += count[i - 1]

    # 建立输出数组
    i = n - 1
    while i >= 0:
        index = arr[i] // exp1
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    i = 0
    for i in range(0, len(arr)):
        arr[i] = output[i]

def radixSort(arr):

    max1 = max(arr)

    # 对每一位进行计数排序
    exp = 1
    while max1 / exp >= 1:
        countingSort(arr, exp)
        exp *= 10
```

>基数排序可以用于解决计数排序面对数字范围过大时的问题



#### 桶排序

比较适用于分布均匀的数组，将数组分在若干个桶内，对于每个桶内的数据进行排序，再将桶内的数据排在一起。


### 两种类型数组排序

用两个指针，分别指向开始和末尾，如果左侧为0，就增加左指针，右侧为1，就减小右指针。然后交换左右指针对应的位置。

```python
def segregate0and1(arr):
    lo, hi = 0, len(arr) - 1
    while lo < hi:
        while arr[lo] == 0 and lo < hi:
            lo += 1
        while arr[hi] == 1 and lo < hi:
            hi -= 1
        if lo < hi:
            arr[lo], arr[hi] = arr[hi], arr[lo]
            lo += 1
            hi -= 1
```

或者另一种方法，见下面分割奇偶数，一个指针指向数组末尾，用一个指针遍历数组，发现奇数就和末尾的指针交换，同时末尾的指针向左移动一步

```python
def segregateevenandodd(arr):
    l = 0
    r = len(arr) - 1

    while l < r:
        if arr[l] & 1 == 0:
            l += 1
        else:
            arr[l], arr[r] = arr[r], arr[l]
            r -= 1
```


### 三种类型数据排序

[75. 颜色分类 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-colors/description/)

将三种颜色进行排序，红色代表0，白色代表1，蓝色代表2

使用两个指针 `p0` 和 `p1` 分别指向 0 和 1 应处于的位置，然后遍历数组 `i`，如果一个值为1，那么将`i` 和指针 `p1` 交换，然后 `p1+1`；如果一个值为 0，那么将 `i` 和指针 `p0` 交换，此处需要注意一点，这里的交换可能会把 1 交换出去，如果 `p0<p1`，那么之前一定有连续的1，此时会把1交换出去，所以需要将 `p1` 需要和第 `i` 个值交换，重新换回来，两个指针均向后移动。

```python
def sortColors(nums: List[int]) -> None:
	p0 = 0
	p1 = 0

	n = len(nums)
	for i in range(n):
		if nums[i] == 1:
			nums[i], nums[p1] = nums[p1], nums[i]
			p1 += 1
		elif nums[i] == 0:
			nums[i], nums[p0] = nums[p0], nums[i]
			if p0 < p1:  # 将 1 交换出去了，现在要交换回来
				nums[i], nums[p1] = nums[p1], nums[i]
			p0 += 1
			p1 += 1
```

### 将数组排序为波形

给定一个未排序的数组，将其排序为 `arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4]` 这种情况

一种简单的算法为先排序，再交换相邻位置的元素

另一种算法：只需要考虑偶数位的元素，使其大于相邻的奇数位元素即可。

```python
def sortInWave(arr, n):
	# 遍历偶数位元素
    for i in range(0, n , 2):

        # 偶数位元素小于之前的奇数位元素
        if (i > 0 and arr[i] < arr[i-1]):
            arr[i], arr[i-1] = arr[i-1], arr[i]

        # 偶数位元素小于之后的奇数位元素
        if (i < n-1 and arr[i] < arr[i+1]):
            arr[i], arr[i+1] = arr[i+1], arr[i]
```


### 排序多个机器上的数组

[Sort numbers stored on different machines - GeeksforGeeks](https://www.geeksforgeeks.org/sort-numbers-stored-on-different-machines/)

给定N个数组，每个机器保存了一些已经排好序的数组，但是数组长度不固定，现在需要排序所有机器中的数组。

每个机器上的数据流可以看成一个链表，可以使用一个最小堆来实现。

首先用一个容量为 N 的最小堆来存储N个机器上的链表头，从最小堆中取出最小值，将最小堆的头更新为最小值对应的链表中的下一个值，如果该链表已经空了，最小堆中的最后一个链表头移动过去。重复上述步骤直到最小堆为空。

```python
def extract_min(min_heap: MinHeap):
    if is_empty(min_heap):
        return None
    temp = min_heap.array[0][0]
    if temp.next is not None:
        min_heap.array[0] = (temp.next, min_heap.array[0][1])
    else:
        min_heap.array[0] = min_heap.array[min_heap.count - 1]
        min_heap.count -= 1
    
    min_heapify(min_heap, 0)
    return temp
```

使用python自带的heapq实现

```python
import heapq

class ListNode:
    def __init__(self, data, next = None):
        self.data = data
        self.next = next

def push(head, ndata):
    new_node = ListNode(ndata)
    new_node.next = head
    head = new_node
    return head

def merge_lists(lists):
    min_heap = []
    for li in lists:
        heapq.heappush(min_heap, (li.data, li))
    return min_heap

def external_sort(array, n):
    min_heap = merge_lists(array)

    while min_heap:
        data, node = heapq.heappop(min_heap)
        print(data, end=" ")
        if node.next != None:
            heapq.heappush(min_heap, (node.next.data, node.next))
```


### 按照二进制中1的数量排序


一种简单的方法是调用库函数

```python
def countBits(a):
    count = 0
    while (a):
        if a & 1:
            count += 1
        a = a>>1
    return count

arr.sort(key= countBits, reverse=True)
```

还有利用计数排序的方法，即对于数组中的每个元素计算1的个数，然后按照1的个数出现次数包括每个元素。

### 让数组各元素均不同的最小增加量

给定一个数组，希望通过给一些元素加1，来使所有元素都不同

一种简单的方法是先排序，再比较前一个元素和后一个元素，始终保持后一个元素比前一个元素大1。

```python
def minIncrements(arr): 
	cnt = 0
	
	arr.sort()
	n = len(arr)
	
	for i in range(1, n):
		if arr[i] <= arr[i-1]:
			cnt += (arr[i-1] - arr[i]) + 1
			arr[i] = arr[i-1] + 1
	return cnt
```


另一种方法是使用一个频率数组记录原数组中所有元素的出现次数，然后只需要让所有元素的出现次数小于等于1即可。

```python
def minIncrements(arr): 
	max_value = max(arr) + 1
	
	freq = [0] * max_value
	
	for i in range(len(arr)):
		freq[arr[i]] += 1
	
	cnt = 0
	
	for i in range(max_value-1):
		if freq[i] > 1:
			cnt += freq[i] - 1
			freq[i+1] += freq[i] - 1
	
	while freq[max_value-1] > 1:
		cnt += freq[max_value-1] - 1
		freq[max_value-1] -= 1
	
	return cnt
```


### 最小操作次数使得数组元素相等

[453. 最小操作次数使数组元素相等 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/description/)

允许对数组中的n-1个数加1，求使所有元素相等时的最小操作次数

直接求不好求，时间复杂度会很高，但是如果换一个方向，对 n-1 个数加1，可以转换为对 1 个数减1，这样就变成了每次操作对一个数减1，需要多少次操作，数组中的元素全部变为最小值

```python
def minMoves(nums) -> int:
	minv = min(nums)
	n = len(nums)
	cnt = 0
	
	for i in range(n):
		cnt += nums[i] - minv
	
	return cnt
```

还有等式可以计算，首先假设最后的目标值为 target，最后的总和为 `target * n`，为了找到最小操作次数，则每次都需要在最小值上加1，因此最小操作次数为 `target-minv`，每次操作会增加 n-1，所以最后有等式：`target*n - sum = (target - minv) * (n-1)`，即 `target = sum-(n-1)*minv`

如果每次允许对一个元素加1或减1，那么使全部元素相等的最小操作次数便是将所有元素变成中位数。


### 火车到达的最少平台问题

https://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station

假设有若干列火车到达某个站点，到达时间为 arr，离站时间为dep，请问该站点最少需要多少个平台

一种方法是先分别对到达时间和离站时间进行排序（不需要管是否一一对应，火车在走之前肯定会先到站），统计在每辆车来之前有多少辆车走即可

```python
def minimumPlatform(arr,dep):
	n = len(arr)
	arr.sort()
	dep.sort()
	min_plat = 0
	plat = 0
	j = 0
	for i in range(n):
		while j < n and dep[j] < arr[i]:
			j += 1
			plat -= 1   # 一辆车在本辆车来之前离站
		plat += 1   # 一辆车来了
		min_plat = max(min_plat, plat)
	return min_plat
```

另一种方法是将其转为有多少个区间重叠的问题，参考数组问题中给定范围内最常出现的整数解法。


### 距离最近的坐标点

[Closest Pair of Points using Divide and Conquer algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/)

分治算法：先按照x轴坐标对点进行排序，然后根据x轴坐标选择一个中间点，将数组分成两个部分，重复这个步骤，将数组分成大小小于3的子数组，在这些子数组中使用暴力解法求最小距离，得到左半边和右半边的最小距离 d，然后选择x轴距离中点小于d的点，再按照y轴排序，在这些点中使用暴力解法求出最小距离。

```python
import math

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
def dist(p1: Point, p2: Point):
    return math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)

def bruteForce(P, n):
    min_dist = float("inf")
    for i in range(n):
        for j in range(i+1, n):
            d = dist(P[i], P[j])
            min_dist = min(min_dist, d)
    return min_dist

def compX(item):
    return item.x

def compY(item):
    return item.y

def stripClosest(arr, n, d):
    min_dist = d
    arr = sorted(arr, key=compY)

    for i in range(n):
        for j in range(i + 1, n):
            # 减少可能的迭代次数
            if arr[j].y - arr[i].y > min_dist:
                break
            if dist(arr[i], arr[j]) < min_dist:
                min_dist = dist(arr[i], arr[j])
    return min_dist

def divide(arr, n):
    if n <= 3:
        return bruteForce(arr, n)
    
    mid = n // 2
    dl = divide(arr[:mid], mid)
    dr = divide(arr[mid:], n - mid)

    d = min(dl, dr)

    stripes = []
    for i in range(n):
        if abs(arr[i].x - arr[mid].x) < d:
            stripes.append(arr[i])
    return min(d, stripClosest(stripes, len(stripes), d))
    
P = [Point(x=2, y=3), Point(x=12, y=30), Point(x=40, y=50), Point(x=5, y=1), Point(x=12, y=10), Point(x=3, y=4)]
n = len(P)
P = sorted(P, key=compX)
print(divide(P, n))
```


### 计算交换次数

[Count Inversions of an Array - GeeksforGeeks](https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/)
[Minimum swaps to sort an array - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/)

给定一个未排序的数组，计算将其排好序所需的交换次数

#### 归并排序

可以使用归并排序来解决这一问题，参考数组问题中找到数组中每一个元素右侧大于自己的数

如果左侧序列中的某个数 `left[i]` 大于右侧序列中的某个数 `right[j]`，那么 `right[j]` 要和 `left[i]` 右侧和自身所有的数交换，交换次数为 `n-i`

```python
class Solution:
    def merge(self, arr, low, mid, high):
        res = 0
        left = arr[low: mid+1]
        right = arr[mid+1:high+1]
        n1 = len(left)
        n2 = len(right)
        
        i, j = 0, 0
        k = low
        while i < n1 and j < n2:
            if left[i] <= right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                res += n1 - i    # 唯一需要注意的地方
                j += 1
            k += 1
        
        while i < n1:
            arr[k] = left[i]
            i += 1
            k += 1
        while j < n2:
            arr[k] = right[j]
            j += 1
            k += 1
        return res
    
    def mergeSort(self, arr, low, high):
        res = 0
        if low < high:
            mid = low + (high - low) // 2
            res += self.mergeSort(arr, low, mid)  # 左半部分的交换次数
            res += self.mergeSort(arr, mid+1, high)  # 右半部分的交换次数
            res += self.merge(arr, low, mid, high)  # 合并左右时的交换次数
        return res
        
    def inversionCount(self, arr):
        n = len(arr)
        res = self.mergeSort(arr, 0, n-1)
        return res
```


#### 哈希方法（适用于不同的元素）

先使用自带的排序方法对数组进行排序，记录原数组的元素位置，将排好序的数组与原数组比较，如果不一致，进行交换

```python
def minSwaps(arr):
  
    temp = sorted(arr)
    
    # 记录数组的正确位置
    pos = {}
    for i in range(len(arr)):
        pos[arr[i]] = i
    
    swaps = 0
    for i in range(len(arr)):
        if temp[i] != arr[i]:
            
            # 获取排序之前的位置
            ind = pos[temp[i]]
            arr[i], arr[ind] = arr[ind], arr[i]

            # 更新位置信息
            pos[arr[i]] = i
            pos[arr[ind]] = ind

            swaps += 1
    return swaps
```


#### 环检测

一个未排序的元素处于一个环中，找出这个环，环的大小减一就是这个环内元素需要交换的次数

```python
def minSwaps(arr):
    n = len(arr)
        
    # 记录已经包括在环里的元素
    vis = [False] * n
    
    # 记录原本的位置
    pos = {}
    for i in range(len(arr)):
        pos[arr[i]] = i
        
    arr.sort()
    
    swaps = 0
    for i in range(n):

        # 已经是一个环的一部分，或者处于正确的位置
        if vis[i] or pos[arr[i]] == i:
            continue

        j, cycleSize = i, 0

        # 创建一个环
        while not vis[j]:
            vis[j] = True

            # 移动到环的下一个元素
            j = pos[arr[j]]
            cycleSize += 1

        # 环的大小减1就是需要交换的次数
        if cycleSize > 0:
            swaps += (cycleSize - 1)
    return swaps
```



### 排序多个有序链表

1、将K个有序链表，以类似归并排序中的分割方法，分割成单个，然后两两merge

2、使用最小堆，可以参考排序多个机器上的数组问题中的解法，维持一个大小为K的最小堆，将K个有序链表的头节点塞入最小堆中，每次弹出最小的头节点，并将最小头节点对应的链表中的下一个元素再塞入最小堆中。

```python
def mergeKLists(arr):
    pq = []
    
    # 插入k个有序链表的头
    for i in range(0, len(arr)):
        head = arr[i]
        if head is not None:
            heapq.heappush(pq, (head.data, i, head))
    
    # 初始化虚拟节点
    dummy = Node(-1)
    tail = dummy

    while pq:
        
        _, index, top = heapq.heappop(pq)
        
        tail.next = top
        tail = top
        
        # 如果有下一个节点，塞入堆中
        if top.next is not None:
            heapq.heappush(pq, (top.next.data, index, top.next))

    return dummy.next
```


### 找到最小长度的未排序序列

[Find the Minimum length Unsorted Subarray, sorting which makes the complete array sorted - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/)

最简单的方法是先对序列排序，然后将排好序的数组和未排序的数组做对比，找到第一个和最后一个两者不相等的点。

一种时间复杂度为 $O(n)$ 的方法，考虑到如下情况

1、对于第 `i` 个元素，如果前面 `i-1` 个元素中存在比这个元素大的值，那么该元素是乱序的
2、从开始索引，从遇到逆序开始时，记录见到的最小值
3、第二步记录的最小值是整个乱序子序列的最小值，需要将其排到合适的地方

```python
def solve(arr):
    n = len(arr)
    
    has_meet_max = arr[0]
    unsort_min = float("inf")
    unsort_begin = 0
    unsort_end = 0 

    for i in range(1, n):
        has_meet_max = max(has_meet_max, arr[i-1]) # 前面 i - 1个数字的最大值
        
        if has_meet_max > arr[i]: 
        # 如果前面 i-1 个元素中存在大于当前元素的元素，那么证明该元素是乱的
            unsort_end = i
        if arr[i] < arr[i-1]:   # 如果出现逆序，找出逆序数组中最小的元素 
            if unsort_min > arr[i]:
                unsort_min = arr[i]
                unsort_begin = i

    if unsort_begin > 0:     # 保证逆序数组中最小元素大于未排序数组左侧的元素
        while unsort_begin > 0 and arr[unsort_begin - 1] > unsort_min:
            unsort_begin -= 1

    print(f"{unsort_begin}, {unsort_end}")
```


另外一种更容易理解的方法：考虑到如下的情况
1、从左到右，找到第一个逆序的地方 `l`，从右到左，找到第一个逆序的地方 `r`
2、`[l, r]` 是一个可能的逆序子序列，从中找出最小值和最大值
3、在 `[0, l-1]` 中找到比最小值还小的地方，在 `[r+1,n-1]` 中找到比最大值还大的地方

```python
def printUnsorted(arr, n):
    e = n-1
	# 从左到右，找到逆序的地方
    for s in range(0,n-1):
        if arr[s] > arr[s+1]:
            break
        
    if s == n-1:
        print ("The complete array is sorted")
        exit()

    # 从右到左，找到逆序的地方
    e= n-1
    while e > 0:
        if arr[e] < arr[e-1]:
            break
        e -= 1

    # 找到逆序序列中的最大值和最小值
    max = arr[s]
    min = arr[s]
    for i in range(s+1,e+1):
        if arr[i] > max:
            max = arr[i]
        if arr[i] < min:
            min = arr[i]
            
    # 找到 [0, s-1] 中比最小值还小的地方
    for i in range(s):
        if arr[i] > min:
            s = i
            break

    # 找到 [e+1, n-1] 中比最大值还大的地方
    i = n-1
    while i >= e+1:
        if arr[i] < max:
            e = i
            break
        i -= 1
```


### K-排序问题

https://www.geeksforgeeks.org/nearly-sorted-algorithm

对于一个几乎排好序的序列，即每个元素位于和其应处位置的距离小于等于 k 的位置

可以使用堆排序，维持一个大小为k的堆，将前k个元素放进堆里，如果第k+1个元素小于堆顶元素，那么将其放到第一个位置，否则将堆顶元素弹出，并放入第一个位置，再将第k+1个元素塞进去

因为每个元素最多位于正确位置距离为k的位置，因此第k+2个元素不可能会比第1个元素还小，否则距离就是k+1了。

```python
def nearlySorted(self, arr, k):
	n = len(arr)
	min_heap = []
	if k == 0:
		return
	# 将前 k 个元素塞入堆中
	for i in range(k):
		heapq.heappush(min_heap, arr[i])
	
	for i in range(k, n):
		# 如果该元素小于堆顶元素，则将其放在前面
		if arr[i] < min_heap[0]:
			arr[i - k] = arr[i]
		else:
		# 弹出最小元素，将较大的元素塞入堆中
			item = heapq.heappop(min_heap)
			arr[i - k] = item
			heapq.heappush(min_heap, arr[i])
	
	for i in range(n-k, n):
		item = heapq.heappop(min_heap)
		arr[i] = item
```


### 数组中的第 K 个最大元素

[215. 数组中的第K个最大元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

给定整数数组和整数 k，返回数组中第 k 个最大的元素

如果需要设计一个时间复杂度为 `O(n)` 的算法，可以使用桶排序，由于本问题针对整数数组，因此桶的大小取1即可。

```python
def findKthLargest(nums: List[int], k: int) -> int:
	# -10000 <= nums[i] <= 10000
	buckets = [0] * 20001
	n = len(nums)
	for i in range(n):
		buckets[nums[i]+10000] += 1
	
	for i in range(10000, -10001, -1):
		k -= buckets[i+10000]
		if k <= 0:
			return i
```

如果不是整数或者值的范围很大，可以使用快速排序

```python
def findKthLargest(nums: List[int], k: int) -> int:
	def quickSelect(l, r, k):
		if l == r: return nums[k]
		pivot, i, j = nums[l], l-1, r+1
		while i < j:
			i += 1
			while nums[i] < pivot: # 在左侧找到大于pivot的数
				i += 1
			j -= 1
			while nums[j] > pivot: # 在右侧找到小于pivot的数
				j -= 1
			if i < j:        # 如果可以交换，就交换
				nums[i], nums[j] = nums[j], nums[i]
		# j 为右侧大于pivot的数的数量，如果 n-k 小于j，证明在左侧寻找
		if k <= j: return quickSelect(l, j, k)
		else: return quickSelect(j+1, r, k)
	
	n = len(nums)
	return quickSelect(0, n-1, n-k)
```

快速排序的另一种方法，首先在数组中随机选择一个pivot，然后设置三个数组，分别储存大于pivot，等于pivot和小于pivot的值，然后根据三个数组的大小和要选择的第k个值决定在哪个数组中，对该数组进行同样的操作

```python
def findKthLargest(nums: List[int], k: int) -> int:
	def quickSelect(nums,k):
		pivot = random.choice(nums)
		bigger, equal, smaller = [], [], []
		for i in range(len(nums)):
			if nums[i] > pivot:
				bigger.append(nums[i])
			elif nums[i] < pivot:
				smaller.append(nums[i])
			else:
				equal.append(nums[i])
		# 如果 k 小于bigger的长度则在bigger中寻找
		if k <= len(bigger): 
			return quickSelect(bigger, k)
		# 如果 k 大于bigger和equal的长度，那么在smaller中寻找
		elif k > len(bigger) + len(equal): 
			return quickSelect(smaller, k - len(bigger) - len(equal))
		else: 
			return pivot
	return quickSelect(nums, k)
```


### 在线性时间排序固定范围内的数据

如果想要在线性时间排序范围为 0 到 $n^2-1$ 的数据，可以使用基数排序，将基数设置为 n 即可实现

```python
def sort(arr, n) :
    
    # 在基数 n 对第一位元素进行计数排序 exp (n^0 = 1)
    countSort(arr, n, 1) 
    # 在基数n，对第二位元素进行计数排序 exp (n^1 = n)
    countSort(arr, n, n)
```


### 让两个包含相同元素的数组相等所需的最小交换次数


[Minimum swaps to make two arrays consisting unique elements identical - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-to-make-two-array-identical/)

假设有两个数组包含了相同的元素，并且这些元素各不相同，但是顺序不同，请问如何计算让这两个数组排列顺序相同的最小交换次数。

因为只需要计算最小交换次数，因此只需要获取第二个数组的元素在第一个数组中的索引，最后该问题转换为了排序时计算交换次数。

如 `arrA = {3, 6, 4, 8}`，`arrB = {4, 6, 8, 3}`，arrB 中的元素在 arrA 中的索引为 `[2, 1, 3, 0]`，接着对索引排序即可。



### 无需额外空间融合两个有序列表

https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space

给定两个有序列表，将这两个列表变成一个整体有序的列表，即一个列表只包含较小的部分值，另一个列表包含较大的部分值

使用两个指针分别指向一个列表的结尾和另一个列表的开始，如果`a[i]>b[j]`，就交换，并移动到下一位，否则让一个指针继续前进，直至停止迭代。


```python
def mergeArrays(a, b):
	n1 = len(a)
	n2 = len(b)
	i = n1 - 1
	j = 0
	# 将 a 中较大的值交换出去
	while i >= 0 and j < n2:
		if a[i] > b[j]:
			a[i], b[j] = b[j], a[i]
			i -= 1
			j += 1
		else:
			i -= 1
	a.sort()
	b.sort()
```


### 包含连续数的最小子集数

[Partition into minimum subsets of consecutive numbers - GeeksforGeeks](https://www.geeksforgeeks.org/count-minimum-number-subsets-subsequences-consecutive-numbers/)

注意只有一个数也算是连续数，因此，在排好序的数组中只需要 `arr[n] != arr[n-1]+1`，那么就代表有一个最小子集包含了连续数，计数加一。

还可以用哈希，将数组转成一个集合，对于数组中的每个数X，如果 X-1不在集合中就代表有一个子集

### 将所有小于k的数排在一起的最小交换数

[Minimum swaps required to bring all elements less than or equal to k together - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-required-bring-elements-less-equal-k-together/)

首先统计所有小于 k 的数的个数 s，然后创建一个滑动窗口，大小为 s，统计这个窗口内大于等于k的元素的个数，最小交换数取这些窗口内大于等于 k 的元素个数的最小值即可。

上述结论基于这样的思考，如果想让所有小于k的元素排在一起，即排在一个滑动窗口内。这样的话，只需要将滑动窗口内大于等于k的元素交换出去即可，即统计大于等于k的元素的数量。

```python
def minSwap (arr, k) : 
	n = len(arr)
	ws = 0
	for i in range(n):
		if arr[i] <= k:
			ws += 1
	if ws == 0:
		return 0
	bad = 0
	
	# 计算初始窗口中大于k的数量
	for i in range(ws):
		if arr[i] > k:
			bad += 1
	
	res = bad
	# 遍历后面的窗口
	for i in range(ws, n):
		if arr[i - ws] > k:
			bad -= 1
		
		if arr[i] > k:
			bad += 1
		# 更新结果
		res = min(res, bad)
	return res
```


### 二叉树转为二叉搜索树的最小交换次数

[Minimum swap required to convert binary tree to binary search tree - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swap-required-convert-binary-tree-binary-search-tree/)

先进行中序遍历（in-order），将得到的数组排列出来，再计算将该数组排序所需的次数



### 计算文本中某个模式的出现次数


[Count distinct occurrences as a subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/count-distinct-occurrences-as-a-subsequence/)

给定一个文本，计算某个模式的出现次数，如 txt = banana, pat = ban，ban 在 banana 中的出现次数为3次，分别为 `[ban]`、`[ba n]` 和 `[b an]`

#### 自己写的解法


使用一个栈保存已经匹配好的字符，匹配到文本的末尾后就弹出栈中保存的字符，继续进行匹配。

```python
def patCount(txt, pat):
    n1 = len(txt)
    n2 = len(pat)

    stack = []    # 储存当前已经匹配好的字符
    
    i, j = 0, 0   # i 和 j分别是txt和pat的索引，其中j是pat中目前需要匹配的字符索引
    cnt = 0
    while True:
        if i < n1:      # 如果没有索引到 txt 的末尾
            if txt[i] != pat[j]:   # 如果不相等，就向后索引
                i += 1
                continue
            if j == n2 - 1:    # 已经完成了一次匹配，继续尝试向后匹配更多的字符
                cnt += 1
                i += 1
                j = n2 - 1
            else: 
                stack.append(i+1)  # 储存字符的位置
                j += 1
                i += 1
        else:
            if len(stack) == 0:    
            # 已经匹配到末尾了，如果栈为空，证明已经没有可以匹配到的字符了
                break
            else:
	            # 弹出栈中的一个元素，进行下一次循环，匹配第j个元素
                i = stack.pop()    
                j = len(stack)
    return cnt
```

#### 回溯法

对于两个字符串 txt 和 pat，从前到后，如果`txt[i+1]=pat[j+1]`，那么考虑 `i+1` 之后的 txt 和 `j+1` 之后 pat （匹配该字符） 以及 `i+1` 之后的 txt 和 `j` 之后的 pat（不匹配该字符）

```python
def count(txt, pat, i, j, n1, n2):
    if j == n2 - 1:
        return 1
    if i == n1 - 1:
        return 0
    
    if txt[i+1] == pat[j+1]:
        return count(txt, pat, i + 1, j+1, n1, n2) + count(txt, pat, i + 1, j, n1, n2)
    return count(txt, pat, i+1, j, n1, n2)

count(txt, pat, -1, -1, n1, n2)   # 注意从-1开始
```

反过来，从后向前

```python
def subCountRec(i, j, txt, pat):
    if j == 0:    # 如果pat已经匹配完毕
        return 1

    if i == 0:    # 如果 txt 已经匹配完了 
        return 0

    if txt[i-1] == pat[j-1]:
        return subCountRec(i - 1, j - 1, txt, pat) \
          + subCountRec(i - 1, j, txt, pat)

    return subCountRec(i - 1, j, txt, pat)
subCountRec(len(txt), len(pat), txt, pat)
```


这样做复杂度过高，可以使用一个矩阵保存已经计算过的情况。

```python
def countSubsequences(i, j, pat, txt, memo):
    if i == 0:
        return 1 
    if j == 0:
        return 0 
        
    if memo[i][j] != -1:
        return memo[i][j]

    # 上一个字符未匹配，则txt向后移动
    if pat[i - 1] != txt[j - 1]:
        memo[i][j] = countSubsequences(i, j - 1, pat, txt, memo)
    else:
        memo[i][j] = (countSubsequences(i, j - 1, pat, txt, memo)
                      + countSubsequences(i - 1, j - 1, pat, txt, memo))

    return memo[i][j]
  
def findSubsequencecount(txt, pat):
    m, n = len(pat), len(txt)

    if m > n:
        return 0
        
    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]

    return countSubsequences(m, n, pat, txt, memo)
```


#### 动态规划

从前到后，令 `dp[i][j]` 为 `txt[:i+1]` 和 `pat[:j+1]` 之间的匹配数

如果 `txt[i]==pat[j]`，则考虑匹配 `txt[:i]` 和 `pat[:j+1]` 以及 `txt[:i]` 和 `pat[:j]`

如果 `txt[i]!=pat[j]`，则考虑匹配 `txt[:i]` 和 `pat[:j+1]`


```python
def numDistinct(txt: str, pat: str) -> int:
	n1 = len(txt)
	n2 = len(pat)
	cnt = 0
	dp = [[0 for _ in range(n2)] for _ in range(n1)]
	p0nums = 0
	for i in range(n1):  # 初始化 pat[0] 在txt中的匹配次数
		if txt[i] == pat[0]:
			p0nums += 1
		dp[i][0] = p0nums
	
	for i in range(1, n1):
		for j in range(1, n2):
			if txt[i] == pat[j]:
				dp[i][j] = dp[i-1][j] + dp[i-1][j-1]
			else:
				dp[i][j] = dp[i-1][j]
	
	return dp[-1][-1]
```


## 双指针

双指针一般用于已经排好序的数组中

### 三元组两个之和为第三个值

给定一个数组，找到一个三元组，其中两个值之和等于第三个值。

可以使用双指针来解决这一问题，对数组先排序，先确定第三个值，用双指针指向前两个值进行搜索

```python
def findTriplet(arr):
	arr.sort()
	n = len(arr)
	for i in range(2, n):   # i 指向第三个值
		l, r = 0, i - 1     # l, r 指向前两个值
		
		while l < r:
			target = arr[l] + arr[r]
			if target == arr[i]:
				return True
			elif target > arr[i]:
				r -= 1
			else:
				l += 1
		
	return False
```


### 雨水收集问题

[Trapping Rain Water Problem - Tutorial with Illustrations - GeeksforGeeks](https://www.geeksforgeeks.org/trapping-rain-water/)

#### 自己的算法

先找到全局最大值，然后从两边向最大值靠拢计算能收集的雨水。从左到右，如果遇到右侧大于等于左侧的**最大值**就计算一个能存储的雨水量。

如果用前缀和代替这里的求和过程，时间复杂度就能降为 $O(n)$

```python
def findMaxWater(self, arr):
        max_units = 0
        now_units = 0
        
        si = 0
        while arr[si] == 0:
            si += 1
        
        for i in range(si + 1, len(arr)):
            if arr[i] >= arr[si]:
                now_units = (i - si - 1) * arr[si] - sum(arr[si+1: i])
                si = i
                max_units += now_units
        return max_units
        
    def maxWater(self, arr):
        max_units = 0
        max_height = max(arr)
        max_height_index = arr.index(max_height)
        
        left_arr = arr[:max_height_index+1]
        right_arr = arr[max_height_index:][::-1]
        
        left_units = 0
        right_units = 0
        
        if len(left_arr) > 1:
            left_units = self.findMaxWater(left_arr)
        
        if len(right_arr) > 1:
            right_units = self.findMaxWater(right_arr)
        return left_units + right_units
```


#### 官方解法

找到每个点左边和右边的最大值，然后取较小的一个，减去该点的值即为该点的水量。使用两个数组分别存储每个点左侧和右侧的最大值，可以降低时间复杂度

```python
def maxWater(arr):
    n = len(arr)

    # Left[i] 为包括自身时的左侧最大值
    left = [0] * n

    # Right[i] 为包括自身时的右侧最大值
    right = [0] * n

    res = 0

    # 计算左侧
    left[0] = arr[0]
    for i in range(1, n):
        left[i] = max(left[i - 1], arr[i])

    # 计算右侧
    right[n - 1] = arr[n - 1]
    for i in range(n - 2, -1, -1):
        right[i] = max(right[i + 1], arr[i])

    # 计算累计水量
    for i in range(1, n - 1):
        minOf2 = min(left[i - 1], right[i + 1])
        if minOf2 > arr[i]:
            res += minOf2 - arr[i]

    return res
```


#### 双指针优化空间


考虑到如果我们知道 `arr[left]` 的左边最大值，和`arr[right]` 的右边最大值，左边最大值小于右边最大值，可以确定 `arr[left]`（因为`arr[left]` 的右侧最大值肯定大于左侧最大值），否则可以确定 `arr[right]`。

```python
def maxWater(arr):
    left = 1
    right = len(arr) - 2

    # lMax : Maximum in subarray arr[0..left-1]
    # rMax : Maximum in subarray arr[right+1..n-1]
    lMax = arr[left - 1]
    rMax = arr[right + 1]

    res = 0
    while left <= right:
      
        # If rMax is smaller, then we can decide the 
        # amount of water for arr[right]
        if rMax <= lMax:
          
            # Add the water for arr[right]
            res += max(0, rMax - arr[right])

            # Update right max
            rMax = max(rMax, arr[right])

            # Update right pointer as we have decided 
            # the amount of water for this
            right -= 1
        else: 
          
            # Add the water for arr[left]
            res += max(0, lMax - arr[left])

            # Update left max
            lMax = max(lMax, arr[left])

            # Update left pointer as we have decided 
            # the amount of water for this
            left += 1
    return res
```


#### 使用栈

```python
def maxWater(arr):
    st = []
    res = 0

    for i in range(len(arr)):
       
        # Pop all items smaller than arr[i]
        while st and arr[st[-1]] < arr[i]:
            pop_height = arr[st.pop()]

            if not st:
                break

            # arr[i] is the next greater for the removed item
            # and new stack top is the previous greater 
            distance = i - st[-1] - 1

            # Take the minimum of two heights (next and prev greater)
            water = min(arr[st[-1]], arr[i])

            # Find the amount of water
            water -= pop_height

            res += distance * water
        st.append(i)

    return res
```


## 滑动窗口

一般用于找到满足特定要求的子序列，找到包含不同字符的最长子字符串等问题。可以分为定长和不定长。


### 子序列和为K

在一个序列中找到一个子序列，其和为K。该问题可以通过前缀和求解，下面给出使用滑动窗口的解法

先设置窗口的左右点均为0，处于同一个点，先滑动右窗口，再滑动左窗口。

```python
def subarraySum(arr, target):
        
	l, r = 0, 0
	n = len(arr)
	
	s = 0
	
	while l <= r and r < n:
		while s < target and r < n:
			s += arr[r]
			r += 1
		
		if s == target:
			return [l+1, r]
		if s < target:
			return [-1]
		
		while s > target and l < r:
			s -= arr[l]
			l += 1
			
		if s == target:
			return [l+1, r]
	
	return [-1]
```


### 固定大小的子序列中的最大值

找到一个序列中每个固定长度的子序列的最大值。使用一个有序列表作为窗口

```python
from sortedcontainers import SortedList

def maxSlidingWindow(arr, k):
    ans = []
    window = SortedList()

    # 初始化一个窗口
    for i in range(k):
        window.add((-arr[i], i))  # 最大堆

    # 获取最大值对应的
    ans.append(-window[0][0])

    # Process the remaining elements
    for i in range(k, len(arr)):
        window.add((-arr[i], i))
        # Remove the element that is out of the window
        if i - k >= 0:
            window.remove((-arr[i - k], i - k))
        # The maximum element in the current window
        ans.append(-window[0][0])

    return ans
```

也可以用一个最大堆保存

```python
import heapq

def max_sliding_window(arr, k):
    ans = []
    heap = []

    # 初始化窗口
    for i in range(k):
        heapq.heappush(heap, (-arr[i], i))

    # 第一个窗口的最大值
    ans.append(-heap[0][0])

    for i in range(k, len(arr)):
        heapq.heappush(heap, (-arr[i], i))

        # 删除即将出去的元素
        while heap[0][1] <= i - k:
            heapq.heappop(heap)
    
        ans.append(-heap[0][0])

    return ans
```

还可以用一个双向队列来保存，队首元素为当前窗口最大的值，如果新的值比队尾元素大，就弹出队尾元素

```python
def maxSlidingWindow(nums, k: int):
	window = deque()
	ans = []

	for i in range(k):
		while window and window[-1] < nums[i]:
			window.pop()
		window.append(nums[i])
	
	ans.append(window[0])

	for i in range(k, len(nums)):

		# 如果队首元素为即将失去的元素
		if window[0] == nums[i-k]:
			window.popleft()

		while window and window[-1] < nums[i]:
			window.pop()

		window.append(nums[i])
		
		ans.append(window[0])
	return ans
```


### 长度为K的子序列中的首个负数

[First negative integer in every window of size k - GeeksforGeeks](https://www.geeksforgeeks.org/first-negative-integer-every-window-size-k/)

使用一个queue来保存窗口内有用的信息，在本问题中就是保存负数对应的索引

```python
from collections import deque

def printFirstNegativeIntegar(arr, n, k):
    Di = deque()

    for i in range(k):
        if arr[i] < 0:
            Di.append(i)
    
    for i in range(k, n):
        if not Di:
            print(0, end=" ")
        else:
            print(arr[Di[0]], end=" ")
        
        while Di and Di[0] <= (i - k):
            Di.popleft()
        
        if arr[i] < 0:
            Di.append(i)
    
    if not Di:
        print(0)
    else:
        print(arr[Di[0]])
```


### 最小覆盖子串

[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/)

这里需要统计当前滑动窗口内的字符是否满足目标字符串的构成，如果一个个比较，会很慢，可以用一个变量设置为目标字符串元素的种类数，这样如果第一次元素数相等，种类数减一，如果种类数为0，则证明已经覆盖了。

在求最小字串时，如果同时移动左右指针，会很麻烦，不如先确定右边界，如果窗口内包含了所有的元素再调整左边界。

```python
def solve(s, t):
    target = dict(Counter(t))
    window = {}
    for key in target:
        window[key] = 0
    cnt = len(target)   # 元素的种类数
    left, right = -1, len(s)
    l = 0
    for r, c in enumerate(s):  # 遍历右端
        if c in window:
            window[c] += 1
            # 如果滑动窗口内已有相同数量的对应元素
            if window[c] == target[c]:  
                cnt -= 1
        while cnt==0:  # cnt 为0，表示包含了所有的元素
            if r - l < right - left:
                right, left = r, l
            if s[l] in window:
                window[s[l]] -= 1
                if window[s[l]] < target[s[l]]:
                    cnt += 1
            l += 1
    if left < 0: return ""

    return s[left: right + 1]
```



### 长度至少为K的子序列之和的最大值

[Largest sum subarray of size at least k - GeeksforGeeks](https://www.geeksforgeeks.org/largest-sum-subarray-least-k-numbers/)


kadane算法：先计算每个索引前的最大和，然后用一个大小为k的窗口，计算连续k个元素之和，然后加上前面 i - k 个元素的最大和看是否更大。

```python
def maxSumWithK(a, n, k):
	maxSum = [a[0]]
	currMaxSum = a[0]
	# kadane算法
	for i in range(1, n):
		# 要么是a[i] 要么是前面i-1所对应的序列和a[i]
		currMaxSum = max(a[i], maxSum[i-1]+a[i])
		maxSum.append(currMaxSum)
	
	s = 0
	for i in range(k):
		s += a[i]
	res = s
	for i in range(k, n):
		s += a[i] - a[i - k]
		
		res = max(res, s)
		# 如果加上前面i-k的最大和，就加上前面i-k的最大和
		res = max(res, s + maxSum[i-k])
	
	return res
```

另一种算法：用一个长度为k的窗口计算连续k个元素之和，然后计算窗口之前的元素之和，如果和为负值，就丢弃前面这些元素

```python
def maxSumWithK(arr, k):
    
    # 计算初始k个元素之和
    sum = 0
    for i in range(k):
        sum += arr[i]

    last = 0
    j = 0
    ans = float('-inf')
    ans = max(ans, sum)

    # 处理剩下的元素
    for i in range(k, len(arr)):

        # 加入当前值到窗口中
        sum = sum + arr[i]

        # 添加左侧元素到last
        last = last + arr[j]
        j += 1

        # 更新最大和
        ans = max(ans, sum)

        # 如果last < 0，用 sum 减去last
        if last < 0:
            sum = sum - last
            ans = max(ans, sum)
            last = 0

    return ans
```


## 前缀和


前缀和的大小和原数组相同，`prefixSum[i] = arr[0]+arr[1]+...+arr[i]`

从 L 到 R 的和用前缀和表达为（L 和 R 均从 1 开始计数）
如果 L 大于1，`prefixSum[R] - prefixSum[L-1]`，否则为 `prefixSum[R]`

前缀和可以用于产生满足一定概率分布的随机数 [Prefix Sum Array - Implementation and Applications in Competitive Programming - GeeksforGeeks](https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/)


### 令所有子序列之和小于k的最大子序列长度

[Maximum subarray size, such that all subarrays of that size have sum less than k - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-subarray-size-subarrays-size-sum-less-k/)

给定一个序列，找到一个最大的序列长度，使得所有小于该长度的子序列之和小于k。

该问题可以转为找到一个最小的子序列长度使得其之和大于k，可以使用滑动窗口解决

```python
def solve(arr, k):
    l = 0
    n = len(arr)
    s = 0
    res = n
    no_res = False
    for r in range(n):

        s += arr[r]

        while s > k:
            s -= arr[l]
            l += 1
            res = min(res, r - l + 1)

            # 对于全部大于0的序列来说，如果s等于0，意味着 l > r，
            # 证明arr[r]为一个大于k的数，这样不可能出现和小于k的子序列
            if s == 0:
                no_res = True
                break
        if no_res:
            res = -1
            break
```


### 子序列模m余数的最大值

对于一个序列，求其子序列模m后的余数的最大值

首先求前缀和关于m的余数，并存入一个集合中，每次求出余数后，在这个集合中找到比这个余数至少大1的余数，假设找到余数正好大 `a`，这样两个前缀和相减之后，余数为`m-a`。

```python
def solve(arr, m):
    n = len(arr)

    mp = set()
    mp.add(0)   # 空子序列之和为0，余数也为0
    prefix = 0
    res = 0

    for i in range(n):

        prefix = (prefix + arr[i]) % m
        res = max(res, prefix)
        _p = 0
        for p in mp:
            if p >= prefix + 1:
                _p = p
        
        if _p != 0:
            res = max(res, prefix - _p + m)
        mp.add(prefix)
    return res
```



## 字符串

### 打印所有的可能的带空格的字符串

[Print all possible strings that can be made by placing spaces - GeeksforGeeks](https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/)

```python
def print_util(str):
    strs = []
    if len(str) == 1:
        strs.append(str)
        return strs

    strtemp = print_util(str[1:])

    for i in range(len(strtemp)):
        strs.append(str[0]+ strtemp[i])
        strs.append(str[0] + " "+ strtemp[i])
    
    return strs

def print_all_strings(s):
    strs = print_util(s)
    for i in strs:
        print(i)
```


另一种解法

```python
def get_all_possible_string_utils(s, res, i, r):
	if i >= len(s):
		res.append(r)
		return
	
	self.get_all_possible_string_utils(s, res, i+1, r + " "+ s[i])
	self.get_all_possible_string_utils(s, res, i+1, r + "" + s[i])
    
def get_all_possible_string(s):
	res = []
	get_all_possible_string_utils(s, res, 1, s[0])
	return res
```


### 字符串的数值运算

[Multiply Large Numbers represented as Strings - GeeksforGeeks](https://www.geeksforgeeks.org/multiply-large-numbers-represented-as-strings/)

[Divide large number represented as string - GeeksforGeeks](https://www.geeksforgeeks.org/divide-large-number-represented-string/)



### 字符串是否一一映射

[Isomorphic Strings Check - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-two-given-strings-are-isomorphic-to-each-other/)

判断两个字符串是否能一一对应，基本思路为统计每个字符串每个字母的首次出现位置，如果相同的话就证明，两个字母出现的位置相同（只需要记录首次出现即可，因为如果后续不匹配，就会遇到不同的字母，结果自然不同）

```python
def areIsomorphic(self,s1,s2):
	d1 = {}
	d2 = {}
	
	if len(s1) != len(s2):
		return False
	
	for i in range(len(s1)):
		if s1[i] not in d1:
			d1[s1[i]] = i
		
		if s2[i] not in d2:
			d2[s2[i]] = i
			
		if d1[s1[i]] != d2[s2[i]]:
			return False
	return True
```


### 判断字符串是否为其它两个字符串的插值

[Check if a String is Interleaving of Other Two - GeeksforGeeks](https://www.geeksforgeeks.org/find-if-a-string-is-interleaved-of-two-other-strings-dp-33/)

给定三个字符串，判断第三个字符串是否是另外两个字符串的插值。

#### 回溯法

用 `i` 和 `j` 分别索引前两个字符串，然后 `i + j` 索引第三个字符串

```python
def interleave(s1, s2, s3, i, j):

    if i == len(s1) and j == len(s2) and i + j == len(s3):
        return True
    
    # 如果 s3[i+j] 为 s1 的第i个元素，继续匹配 s1 的下一个元素
    a = i < len(s1) and s3[i+j] == s1[i] and interleave(s1, s2, s3, i+1, j)
    # 或者匹配 s2 的下一个元素
    b = j < len(s2) and s3[i+j] == s2[j] and interleave(s1, s2, s3, i, j+1)
    return a or b

def solve(s1, s2, s3):
    if len(s1) + len(s2) != len(s3):
        print(False)
        return
    res = interleave(s1, s2, s3, 0, 0)
    print(res)
```


#### 动态规划

。。。



### 获取字符串所有的置换结果

[Permutations of given String - GeeksforGeeks](https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/)



![](https://media.geeksforgeeks.org/wp-content/uploads/20250106173028544574/4.webp)


```python
def recurPermute(index, s, ans):
    if index == len(s):
        ans.append("".join(s))
        return

    # 交换当前和之后所有的点
    for i in range(index, len(s)):
        s[index], s[i] = s[i], s[index]
        recurPermute(index + 1, s, ans)  # 回溯下一个位置
        s[index], s[i] = s[i], s[index]

def findPermutation(s):
    ans = []
    recurPermute(0, list(s), ans)
    ans.sort()
    return ans
```


### 最长回文字符串

[Longest Palindromic Substring - GeeksforGeeks](https://www.geeksforgeeks.org/longest-palindromic-substring/)

遍历字符串的每个位置 `i`，以 `i` 为中心向两边扩展统计回文字符串的长度，以及以 `i` 和 `i+1` 为中心的回文字符串长度。

```python
def longestPalindrome(s: str) -> str:
    start, maxLen = 0, 1
    n = len(s)
    for i in range(n):
        for j in range(2):
            low, high = i, i + j

            while low >= 0 and high < n and s[low] == s[high]:
                currLen = high - low + 1
                if currLen > maxLen:
                    maxLen = currLen
                    start = low
                low -= 1
                high += 1
        
    return s[start: start+maxLen]
```



### 回文字符串的最小切割

[Palindrome Partitioning - GeeksforGeeks](https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/)

[132. 分割回文串 II - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning-ii/)

对一个字符串进行切割，使其每个子字符串都是回文的，求最小切割次数

递归：对问题进行分析，首先需要编写一个判断回文的函数，递归过程中输入字符串，子字符串的起始点和终点，对这两个点之间的每一个点都尝试一次切割，取其中的最小值

```python
import sys

def isPalindrome(s, i, j):
    while i < j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True

def palPartitionRec(s, i, j):
	# 如果 s[i...j] 是空字符串或者回文字符串，则不用切割
    if i >= j or isPalindrome(s, i, j):  
        return 0

    res = sys.maxsize
	# 尝试每种切割方法
    for k in range(i, j):
        cuts = 1 + palPartitionRec(s, i, k) \
                 + palPartitionRec(s, k + 1, j)
        res = min(res, cuts)

    return res

def palPartition(s):
    return palPartitionRec(s, 0, len(s) - 1)
```


加上矩阵存储状态

```python
def isPalindrome(s, i, j):
    while i < j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True

def palPartitionRec(s, i, j, memo):

    if memo[i][j] != -1:
        return memo[i][j]
        
    if i >= j or isPalindrome(s, i, j):
        memo[i][j] = 0
        return 0

    res = sys.maxsize

    for k in range(i, j):
        cuts = 1 + palPartitionRec(s, i, k, memo) \
        + palPartitionRec(s, k + 1, j, memo)
        res = min(res, cuts)

    memo[i][j] = res
    return res

def palPartition(s):
    n = len(s)
    memo = [[-1 for _ in range(n)] for _ in range(n)]
    return palPartitionRec(s, 0, n - 1, memo)
```

使用动态规划方法，先动态规划计算子字符串是否为回文字符串，然后用 `dp[i]` 表示 `s[0..i]` 的字符串的最小切分次数，如果 `0` 到 `i` 不是回文字符串，就在 `1` 到 `i` 之间重新划分起点。

```python
def minCut(s: str) -> int:
	n = len(s)
	dp = [n for _ in range(n)]
	isPalin = [[True] * n for _ in range(n)]  # 先初始化为True
	# 动态规划判断 s[i...j] 是否为回文字符串
	for i in range(n-1, -1, -1):
		for j in range(i+1, n):
			if s[i] == s[j]:
				isPalin[i][j] = isPalin[i+1][j-1]
			else:
				isPalin[i][j] = False
	dp[0] = 0  # 单个元素分割次数为0
	for i in range(1, n):
		if isPalin[0][i]:
			dp[i] = 0
		else:
			for j in range(1, i+1):
				# 如果 s[j..i] 为回文字符串
				# 只需要在s[0..j-1]的基础上加一次分割即可
				if isPalin[j][i]:  
					dp[i] = min(dp[i], dp[j-1]+1)
	return dp[n-1]
```


### 分割回文串Ⅲ

[1278. 分割回文串 III - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning-iii/description/)

允许对字符串进行修改，求出将某个字符串分割为 k 个字符串时的最小修改次数

首先求出 `s[i..j]` 变成回文串时的最小修改次数 `cost[i][j]`

令 `dp[i][j]` 为 `s[0:i]` 分为 `j` 个字符串时的最小修改次数，对于第 j 个字符串，可以枚举其开始可能出现的位置 `ii`，`dp[ii][j-1]` 则为`s[0..ii-1]` 分为 `j-1` 个回文字符串的最小修改次数，然后再加上 `s[ii..i-1]` 时的修改次数即可

`dp[i][j] = min(dp[i][j], dp[ii][j-1]+cost[ii][i-1])`

```python
def palindromePartition(s: str, k: int) -> int:
	n = len(s)
	cost = [[0 for _ in range(n)] for _ in range(n)]
	# 动态规划计算 s[i...j] 变为回文字符串时的修改次数
	for i in range(n-1, -1, -1):
		for j in range(i+1, n):
			if s[i] == s[j]:
				cost[i][j] = cost[i+1][j-1]
			else:
				cost[i][j] = cost[i+1][j-1] + 1
	
	# dp[i,j] 为 s[0:i] 分为 j 个回文字符串所需的最小修改次数
	dp = [[n for _ in range(k+1)] for _ in range(n+1)]

	dp[0][0] = 0
	for i in range(1, n+1):
		for j in range(1, min(k,i)+1):
			if j == 1:
				dp[i][j] = cost[0][i-1]
			else:
				# 遍历 ii 为第 j 个字符串的起点
				for ii in range(j-1, i):
				# dp[ii][j-1] 为 s[0:ii]分为j-1个回文字符串时的最小修改次数
					dp[i][j] = min(dp[i][j], dp[ii][j-1]+cost[ii][i-1])
	return dp[n][k]
```


### 不重叠回文子字符串的最大数目

[2472. 不重叠回文子字符串的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/description/)

采用记忆化搜索的方法，对于一个位置，可以选择将其作为开始，或者不选择其作为开始。如果选择作为开始，则遍历长度大于等于k的字符串末端，如果找到一个可以形成回文字符串，就停止该位置的搜索。

```python
def maxPalindromes(s: str, k: int) -> int:
	if k == 1:
		return len(s)
	n = len(s)
	isPalin = [[True for _ in range(n)] for _ in range(n)]

	for i in range(n-1, -1, -1):
		for j in range(i+1, n):
			if s[i] == s[j]:
				isPalin[i][j] = isPalin[i+1][j-1]
			else:
				isPalin[i][j] = False
	
	def solve(s, idx):
		if idx == n:
			return 0
		if memo[idx] != -1:
			return memo[idx]    
		res = 0
		# 忽略当前位置，探索下一个位置
		res = max(res, solve(s, idx+1))
		# 以当前节点idx作为开始，找到一个最近的可形成回文字符串的位置
		for i in range(idx+k-1, n):
			if isPalin[idx][i]:
				res = max(res, 1 + solve(s, i+1))
				break
		
		memo[idx] = res
		return res
	memo = [-1 for i in range(n)]
	cnt = solve(s, 0)
	return cnt
```

换成动态规划则是

```python
dp = [0] * (n+1)
for i in range(1, n+1):
	dp[i] = dp[i-1]
	for j in range(1, i+1): 
	# 如果有长度至少为 k 的回文子字符串，加1
		if (i - j + 1 >= k and isPalin[j-1][i-1]):
			dp[i] = max(dp[i], dp[j-1]+1)
```


### 获取所有的顺序子字符串

回溯法

```python
def solve(s):
    n = len(s)
    sols = []
    def _solve(i, res):
        if i == n:
            if res != "":
                sols.append(res)
            return
		# 每个位置选择
        _solve(i+1, res)
        _solve(i+1, res+s[i])
    
    _solve(0, "")
    print(sorted(sols))

solve("cab")
```

使用二进制mask实现

```python
def solve_b(s):

    n = len(s)
    sols = []
    s = ''.join(sorted(s))

    for i in range(1, 2 ** n):
        subs = ""
        j = 0
        while i > 0: 
            if i & 1:  # 根据各位是否为1来决定是否添加该字符
                subs+=s[j]
            j += 1
            i >>= 1
    sols.sort()
    print(sols)
```


### 打印所有的回文字符串（拆分字符串）

[Print all Palindromic Partitions of a String using Backtracking - GeeksforGeeks](https://www.geeksforgeeks.org/given-a-string-print-all-possible-palindromic-partition/)

首先拆分字符串为子字符串，然后判断子字符串是否是回文字符串

拆分子字符串的代码为

```python
def palPartitionRec(s, idx, p, sols):
	if idx == len(s):
		sols.append(p[:])
		return
	temp = ""
	for i in range(idx, len(s)):
		temp += s[i]
		# 注意是i+1，不是 idx + 1
		palPartitionRec(s, i+1, p + [temp], sols)
sols = []
palPartitionRec(s, 0, [], sols)
print(sols)
```


只需要加上判断temp是否为回文的条件即可
```python
def allPalindromicPerms(s):
	def is_palindrome(s):
		return s == s[::-1]
	
	def _all_palindrome(s, idx, res, sols):
		
		if idx == len(s):
			sols.append(res[:])
			return
		
		temp = ""
		for i in range(idx, len(s)):
			temp += s[i]
			if is_palindrome(temp):
				_all_palindrome(s, i+1, res + [temp], sols)
	
	sols = []
	_all_palindrome(s, 0, [], sols)
	return sols
```

### 判断一个字符串是否是scramble

[Check if a string is a scrambled form of another string - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-string-is-a-scrambled-form-of-another-string/)


### 合法的IP地址

[93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/)

合法的IP地址需要满足每一部分的值小于255，同时没有前导0。

```python
def restoreIpAddresses(s: str) -> List[str]:
	n = len(s)
	def dfs(s, ans, res, idx, depth):

		if idx == n and depth == 4:
			ans.append(res[:])
			return

		if n - idx > 3 * (4-depth):  # 如果剩下的元素太多，就无法构成
			return
		temp = ""
		for i in range(idx, n):
			if temp == "0":  # 如果temp为"0"就不要继续了
				break
			
			temp += s[i]
			if int(temp) <= 255:
				res.append(temp)
				dfs(s, ans, res, i+1, depth+1)
				res.pop()
			else:
				break
	
	ans = []
	dfs(s, ans, [], 0, 0)
	ans = [".".join(a) for a in ans]
	return ans
```

### 判断一句话能否被给定词表分解

[Word Break - GeeksforGeeks](https://www.geeksforgeeks.org/word-break-problem-dp-32/)

判断一句话能否被给定的词表分解，使用动态规划的方法，通过一个数组保存 `s[0:i+1]` 时是否可以被分，如果可以，就尝试一下在 `i+1` 之后是否存在可以被分解的，每次只取最短的一种可能。

```python
def wordBreak(s, dictionary):
	n = len(s)
	dp = [False for _ in range(n)]

	for i in range(n):
		
		if (not dp[i] and s[:i+1] in dictionary):
			dp[i] = True
		# 如果当前词可以被分解，判断之后的是否能分解
		if dp[i]:
			if i == n-1:
				return True
			
			for j in range(i, n):
				if (not dp[j] and s[i+1:j+1] in dictionary):
					dp[j] = True
				
				if dp[j] and j == n-1:
					return True
	return False
```


### 获取字符串中的异序词对

[Count of total anagram substrings - GeeksforGeeks](https://www.geeksforgeeks.org/count-total-anagram-substrings/)

异序词对指两个词之间字母种类和数量相同，但是排列顺序不同。

首先获取所有的子字符串，对每个子字符串排序后塞入字典中，对于出现次数大于 1 的子字符串，可能的异序词对为 $C_n^2$


### 统计没有连续1的二进制字符串个数

[Count number of binary strings without consecutive 1's - GeeksforGeeks](https://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/)

```python
def solve(n):
    def _solve(s, n, last):
        if n == 1:
            if last == "1":
                return 1
            else:
                return 2
        cnt = 0
        if last == "0":
            cnt += _solve(s, n-1, "0")
            cnt += _solve(s, n-1, "1")
        else:
            cnt += _solve(s, n-1, "0")
        
        return cnt
    s = ""
    cnt = _solve(s, n-1, "0") + _solve(s, n-1, "1")
    print(cnt)
```

带记忆矩阵的

```python
def solve_m(n):

    def _solve(memo, n, last):
        if n == 1:
            if last == "1":
                return 1
            else:
                return 2
        
        if memo[n][int(last)] != -1:
            return memo[n][int(last)]

        cnt = 0
        if last == "0":
            cnt += _solve(memo, n-1, "0")
            cnt += _solve(memo, n-1, "1")
            memo[n][int(last)] = cnt
        else:
            cnt += _solve(memo, n-1, "0")
            memo[n][int(last)] = cnt
        
        return cnt
    
    memo = [[-1, -1] for _ in range(n)]
    cnt = _solve(memo, n-1, "0") + _solve(memo, n-1, "1")
    print(cnt)
```

动态规划

```python
def solve_dp(n):

    dp = [[0, 0] for _ in range(n)]  # 第 i 位为0或1时的可能性

    # 如果字符串长度为 1，那么只有 dp[0][0] + dp[0][1] = 2 种可能性
    dp[0][0] = 1
    dp[0][1] = 1

    for i in range(1, n):
        dp[i][0] = dp[i-1][0] + dp[i-1][1]
        dp[i][1] = dp[i-1][0]

    cnt = dp[n-1][0] + dp[n-1][1]
    print(cnt)
```


### 判断字符串是否能被拆分四个不同的子字符串

[Check if given string can be split into four distinct strings - GeeksforGeeks](https://www.geeksforgeeks.org/check-given-string-can-split-four-distinct-strings/)

对于长度大于等于10的字符串来说，必定可以拆分为长度为1、2、3、4的子字符串，所以只需要考虑长度小于10的字符串

```python
def solve(s):
    if len(s) >= 10:
        return True
    
    n = len(s)
    for i in range(0, n-3):
        for j in range(i+1, n-2):
            for k in range(j+1, n-1):
                s1 = s[:i+1]
                s2 = s[i+1:j+1]
                s3 = s[j+1:k+1]
                s4 = s[k+1:]

                if s1 != s2 and s1 != s3 and s1 != s4 \
                and s2 != s3 and s2 != s4 and s3 != s4:
                    return True
    return False
```


### 最长平衡子序列

[Length of Longest Balanced Subsequence - GeeksforGeeks](https://www.geeksforgeeks.org/length-longest-balanced-subsequence/)


使用动态规划解决这个问题，`dp[i][j]` 表示 `s[i..j]` 的最长平衡子序列，如果 `s[i]==s[j]`，那么最长平衡子序列在 `dp[i+1][j-1]` 的基础上加 2，然后在 i 到 j 之间选择一点将子序列分为两部分，两部分的最长平衡子序列取总和

在初始化时，先将所有连续的匹配括号赋值

```python
def maxBalancedSubseq(str):
    n = len(str)
    
    dp = [[0 for _ in range(n)] for _ in range(n)]
    
    # 考虑所有的平衡连续子括号
    for i in range(n - 1):
        if str[i] == '(' and str[i + 1] == ')':
            dp[i][i + 1] = 2
    
    # 考虑其它的子字符串
    for l in range(2, n):
        for i in range(0, n - l):
            j = i + l
            if str[i] == '(' and str[j] == ')':
                dp[i][j] = 2 + dp[i + 1][j - 1]
            for k in range(i, j):
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j])
    
    return dp[0][n - 1]
```


另一种方法是找到所有不平衡的字符串，具体做法是遇到一个 `(`，`invalidOpen+1`，遇到 `)`，并且 `invalidOpen` 为 0，则 `invalidClose+1`，不为0，则 `invalidOpen-1`

```python
def maxBalancedSubseq(str):
    n = len(str)

    invalidOpen = 0
    invalidClose = 0
    
    for i in range(n):
        if str[i] == '(':
            invalidOpen += 1
        else:
            if invalidOpen == 0:
                invalidClose += 1
            else:
                invalidOpen -= 1
    return n - (invalidOpen + invalidClose)
```




### 平衡子序列的最小相邻交换次数

[Min Adjacent Swaps for Bracket Balancing - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-swaps-bracket-balancing/)

注意这里计算的相邻交换，所以像 `]][[` 这种需要三次相邻交换。

```python
def minimumNumberOfSwaps(s):
	cnt = 0
	n = len(s)
	c1 = 0
	c2 = 0
	for i in range(n):
		if s[i] == "[":
			c1 += 1
		else:
			c2 += 1
			cnt += max(0, c2 - c1)
	return cnt
```


### 给定序列的最小数

[Form minimum number from given sequence - GeeksforGeeks](https://www.geeksforgeeks.org/form-minimum-number-from-given-sequence/)




### 增加最长公共子序列的方式

[Count ways to increase LCS length of two strings by one - GeeksforGeeks](https://www.geeksforgeeks.org/count-ways-increase-lcs-length-two-strings-one/)

有两个序列，现在向第一个序列中添加一个元素，使得两个序列的最长公共子序列增加1，请问有多少种方式

使用动态规划的方法，在第一个字符串中添加一个元素，为了使最长公共子序列加1，那就要这个元素匹配到第二个序列的某个元素，即删除掉第二个序列的这个元素后，仍然能够保证最长公共子序列长度不变。

```python
def solve(s1, s2):

    n1 = len(s1)
    n2 = len(s2)
    positions = {}
    for i in range(n2):
        if s2[i] in positions:
            positions[s2[i]].append(i+1)
        else:
            positions[s2[i]] = [i+1]
    
    lcs = [[0 for _ in range(n2+2)] for _ in range(n1+2)]
    # lcs[i][j]: s1[0...i] 和 s2[0...j] 的最长公共长度
    for i in range(1, n1+1):
        for j in range(1, n2+1):
            if s1[i-1] == s2[j-1]:
                lcs[i][j] = 1 + lcs[i-1][j-1]
            else:
                lcs[i][j] = max(lcs[i][j-1], lcs[i-1][j])
    
    lcsr = [[0 for _ in range(n2+2)] for _ in range(n1+2)]

    # lcsr[i][j]: s1[i...n1] 和 s2[j...n2] 的最长公共子序列长度
    for i in range(n1, 0, -1):
        for j in range(n2, 0, -1):
            if s1[i-1] == s2[j-1]:
                lcsr[i][j] = 1 + lcsr[i+1][j+1]
            else:
                lcsr[i][j] = max(lcsr[i+1][j], lcsr[i][j+1])
    
    ways = 0

    for i in range(n1+1):
        for c in range(26): # 尝试每个字符，如果这个字符在 s2 中出现
            if chr(c+97) in positions:
                for j in range(len(positions[chr(c+97)])):
                    p = positions[chr(c+97)][j]
					# s2 删除 p 这个位置对应的元素
                    if lcs[i][p-1] + lcsr[i+1][p+1] == lcs[n1][n2]:
                        ways += 1
    return ways
```



### 判断字符串数组能否被串联起来

[Find if an array of strings can be chained to form a circle | Set 2 - GeeksforGeeks](https://www.geeksforgeeks.org/find-array-strings-can-chained-form-circle-set-2/)

将字符串的开始和结尾看成一条有向边的起点和终点，构建邻接矩阵和出度，入度。如果能被串联，那么需要满足两个条件

+ 所有顶点的入度和出度相等
+ 从一个顶点出发能遍历到所有的顶点（用一个DFS遍历一个顶点，看是否所有的顶点都能被遍历到）

```python
def isCircle(arr):
	ch2idx = {}
	nc = 0
	for w in arr:
		if w[0] not in ch2idx:
			ch2idx[w[0]] = nc
			nc += 1
		if w[-1] not in ch2idx:
			ch2idx[w[-1]] = nc
			nc += 1
	
	adj = [[] for i in range(nc)]
	indeg = [0] * nc
	oudeg = [0] * nc
	
	for w in arr:
		adj[ch2idx[w[0]]].append(ch2idx[w[-1]])
		indeg[ch2idx[w[-1]]] += 1
		oudeg[ch2idx[w[0]]] += 1
	
	# 入度和出度一致
	for i in range(nc):
		if indeg[i] != oudeg[i]:
			return 0
	
	visited = [False] * nc
	
	def dfs(i):
		visited[i] = True
		
		for j in adj[i]:
			if not visited[j]:
				dfs(j)
	
	dfs(0)  # 从0开始遍历，看是否能遍历所有的节点
	
	# 遍历所有的顶点，是否还有没有访问过的
	for i in range(nc):
		if not visited[i]:
			return 0
	return 1
```

### 外星人字典

[Alien Dictionary - GeeksforGeeks](https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/)

给定一组字符串，字符串的排序顺序按照外星人字典排列，找到字符的顺序

问题的关键是如何根据排序的字符串找到对应的字符之间的顺序，一种方法是枚举字符串，比较字符串之间的差距，如果字符不同，那么就可以得到字符之间的顺序

```python
def findOrder(words):
	from collections import deque
	n = len(words)
	
	# 字符和索引之间的映射
	ch2idx = {}
	idx2ch = {}
	idx = 0
	for w in words:
		for c in list(w):
			if c not in ch2idx:
				ch2idx[c] = idx
				idx2ch[idx] = c
				idx += 1
	nw = len(ch2idx)  # 字符的数量
	adj = [[] for _ in range(nw)]
	indeg = [0] * nw
	
	# 获得字符之间的顺序，有三种情况
	# 1. 两个单词之间存在不同的字符，直接返回即可
	# 2. 两个单词前面的部分相同，但是前面的单词长度更长，显然是错误的
	# 3. 两个单词前面的部分相同，但是前面的单词长度更短，这是合理的
	def get_order(s1, s2):
		n = min(len(s1), len(s2))
		for i in range(n):
			if s1[i] != s2[i]:
				return (ch2idx[s1[i]], ch2idx[s2[i]])
		if len(s1) > len(s2):  # 前面的单词更长，错误
			return False
		else:
			return None
	# 防止重复获取字符顺序
	collected_order = set()
	for i in range(n):
		for j in range(i+1, n):
			order = get_order(words[i], words[j])
			if order is not None:
				if order == False:
					return ""
				if order not in collected_order:
					adj[order[0]].append(order[1])
					indeg[order[1]] += 1
					collected_order.add(order)
	# 拓扑排序
	queue = deque()
	for c in range(nw):
		if indeg[c] == 0:
			queue.append(c)

	res = []
	while queue:
		i = queue.popleft()
		res.append(idx2ch[i])
		for j in adj[i]:
			indeg[j] -= 1
			if indeg[j] == 0:
				queue.append(j)
	if len(res) != nw:  # 不存在拓扑排序
		return ""
	else:
		return "".join(res)
```

### 最小词表分解次数

[Minimum Word Break - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-word-break/)

自己的解法（不一定正确），参考判断一句话能否被给定词表分解问题的解法

```python
def solve(s, d):
    n = len(s)
    dp = [None] * n

    if s in d:
        return 0

    temp = ""
    for i in range(n):
        temp += s[i]
        if temp in d:
            dp[i] = 0

        if dp[i] is not None:
            if i == n-1:
                return dp[i] - 1
            tmp = ""
            for j in range(i+1, n):
                tmp += s[j]
                if tmp in d:
                    dp[j] = dp[i] + 1
                
    return dp[n-1] - 1
```

官方解法

```python
def min_word_break(s, dict):
    n = len(s)
    dp = [float('inf')] * (n + 1)  
    dp[0] = 0  # 空字符串无需分解

    for i in range(1, n + 1):
        for word in dict:
            length = len(word)
            if i >= length and s[i - length:i] == word:
                # 检查 s[i - length:i] 是否和单词相等，如果相等更新
                dp[i] = min(dp[i], dp[i - length] + 1)

    return dp[n] - 1  # 减1是因为最后的空字符串无需被分解
```


判断单词能否被给定词表拆分，可以通过DFS方法

```python
def wordBreak(s: str, wordDict: List[str]) -> bool:
	n = len(s)
	max_len = max(map(len, wordDict))
	@cache
	def dfs(i):
		if i == 0:
			return True
		end = max(i - max_len - 1, -1)
		for j in range(i-1, end, -1):
			if s[j:i] in wordDict and dfs(j):
				return True

		return False
	
	return dfs(n)
```

注意需要使用 `@cache` 修饰符，用空间换时间


### 最大数问题

[179. 最大数 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-number/)

将一组非负整数自由组合排成最大数，注意对于前缀相同的非负整数难以判断谁放在前面比较好。为了解决这个问题，直接在排序时定义，如果 a 在前面比 b 在前面大，那就把 a 放在前面。

```python
def largestNumber(nums: List[int]) -> str:
	strs = [str(n) for n in nums]

	def cmp(a, b):
		if a + b > b + a:
			return -1
		elif a + b < b + a:
			return 1
		else:
			return 0
	strs.sort(key=functools.cmp_to_key(cmp))
	if strs[0] == "0":
		return "0"
	return "".join(strs)
```

### 词搜索

在二维数据中搜索某个词：[Word Search in a 2D Grid of characters - GeeksforGeeks](https://www.geeksforgeeks.org/search-a-word-in-a-2d-grid-of-characters/)

[Word Search - Check if a word exists in a grid or not - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-word-exists-in-a-grid-or-not/)

```python
def solve(mat, word):
    def _solve(mat, word, x, y, idx):

        if idx == len(word):
            return True
        
        m = len(mat)
        n = len(mat[0])

        if x < 0 or y < 0 or x >= m or y >= n:
            return False
        
        if mat[x][y] == word[idx]:

            temp = mat[x][y]
            mat[x][y] = "#"   # 标记此处已经搜索过了

            result = _solve(mat, word, x + 1, y, idx+1) or \
            _solve(mat, word, x-1, y, idx+1) or _solve(mat, word, x, y+1, idx+1) \
            or _solve(mat, word, x, y- 1, idx+1)

            mat[x][y] = temp

            return result
        return False

    m = len(mat)
    n = len(mat[0])

    if len(word) > m * n:
        return False
    
    for i in range(m):
        for j in range(n):
            if mat[i][j] == word[0]:
                if _solve(mat, word, i, j, 0):
                    return True
    return False
```

除了上面的内容，还有一些优化技巧，如统计二维矩阵中每个字母出现的频次，如果频次过少，就不可能搜到。另外一个优化技巧，如果word中第一个单词的出现次数比最后一个单词的出现次数要多，可以从最后一个单词开始搜，这样可以避免多次尝试

```python
cnt = Counter(c for row in board for c in row)
if not cnt >= Counter(word):
	return False
if cnt[word[-1]] < cnt[word[0]]:
	word = word[::-1]
```


### 使得括号是否平衡的最小转变次数

[Minimum number of bracket reversals needed to make an expression balanced - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-number-of-bracket-reversals-needed-to-make-an-expression-balanced/)
首先需要保证括号数量为偶数。

一种递归的方法是，对于字符串中的每个括号采取翻转或者不翻转，翻转指如果是 `{` 就转成 `}`，反之转成 `{`。这样会枚举出所有可能的括号排列方式，再从这些方式中找到平衡的括号

```python
def recur(expr, n, ind, change, ans):
    # 停止条件
    if ind == n:
        if isBalanced(expr):  # isBalanced 判断括号是否平衡，可以用栈来判断
            ans[0] = min(ans[0], change)   # ans 是一个列表，方便保存结果
        return

    # 保持括号
    recur(expr, n, ind + 1, change, ans)

    # 翻转括号
    if expr[ind] == '{':
        expr = expr[:ind] + '}' + expr[ind + 1:]
    else:
        expr = expr[:ind] + '{' + expr[ind + 1:]
    recur(expr, n, ind + 1, change + 1, ans)
```


另一种方法是删除字符串中所有的已经平衡的括号，然后剩下的只能是类似 `}}}{{{` 这种形式，假设有 `m` 个 `{` 和 `n` 个 `}`，则最小转变次数为 `ceil(m/2)+ceil(n/2)`（分别将 `{` 和 `}` 中的一半转变）

```python
def countMinReversals(expr):

    lenn = len(expr)

    # 字符串的长度需要能被2整除
    if (lenn % 2):
        return -1

    # 删除所有平衡的括号，留下不平衡的括号
    s = []
    for i in range(lenn):
        if (expr[i] == '}' and len(s)):
            if (s[0] == '{'):
                s.pop(0)
            else:
                s.insert(0, expr[i])
        else:
            s.insert(0, expr[i])

    # 不平衡括号的长度 red_len = m+n
    red_len = len(s)

    # 计算栈底的开括号的数量
    n = 0
    while len(s) and s[0] == '{':
        s.pop(0)
        n += 1
	
    # 当 m+n 为偶数时 ceil(m/2) + ceil(n/2) 和 (m+n)/2 + n%2 等价
    return (red_len // 2 + n % 2)
```


### 词换行问题

[Word Wrap Problem - GeeksforGeeks](https://www.geeksforgeeks.org/word-wrap-problem-dp-19/)


自己的解法（会超时），每次递归时传入 idx （目前索引的arr元素），row 为当前行的长度

```python
def solve_m(arr, k):

    def _solve(arr, idx, row, k, memo):
        if idx == len(arr):
            return 0
        
        if memo[idx][row] != -1:
            return memo[idx][row]

        cost = 0
        if row != 0:
            nr = arr[idx] + 1 + row
        else:
            nr = arr[idx]
        
        if nr <= k:
	        # 换到下一行更好还是在本行更好
            cost = min( (k - row) ** 2 + _solve(arr, idx+1, arr[idx], k, memo),  _solve(arr, idx+1, nr, k, memo))
        else:
	        # 换到下一行
            cost = (k - row) ** 2 + _solve(arr, idx+1, arr[idx], k, memo)
        memo[idx][row] = cost
        return cost
    
    memo = [[-1 for _ in range(k+1)] for _ in range(len(arr))]
    cost = _solve(arr, 0, 0, k, memo)
    return cost
```


官方解法（回溯法，未添加memo），添加memo后，这种回溯方法对于memo的利用会更高，将row放到循环里面了。

```python
import sys
 
def calculateCost(curr, n, arr, k):
    # 停止条件
    if curr >= n:
        return 0

    # 计算当前行的字符数
    sum = 0

    ans = sys.maxsize

    # 尝试在当前行放置单词
    for i in range(curr, n):
      
        # 加上当前单词的长度
        sum += arr[i]

        # 加上单词间的空格
        tot = sum + (i - curr)

        # 如果长度超过了行宽，停止循环
        if tot > k:
            break

        # 如果不是最后一个单词，计算下一行的损失
        if i != n - 1:
            temp = (k - tot)*(k - tot) + calculateCost(i + 1, n, arr, k)
            ans = min(ans, temp)
            
        # 如果是最后一个单词，没有损失了
        else:
            ans = 0
    return ans

def solveWordWrap(arr, k):
    n = len(arr)
    return calculateCost(0, n, arr, k)
```


动态规划

```python
def solve_dp(arr, k):
    n = len(arr)
    dp = [float("inf") for _ in range(n+1)]

    for curr in range(n-1, -1, -1):
        s = 0
        for i in range(curr, n):
            s += arr[i]
            tot = s + i - curr

            if tot > k:
                break

            if i != n-1:
                dp[curr] = min(dp[curr], dp[i+1] + (k - tot) * (k - tot))
            else:
                dp[curr] = min(dp[curr], 0)
    return dp[0]

```


### 串联所有单词的子串

[30. 串联所有单词的子串 - 力扣（LeetCode）](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

使用滑动窗口来解决这一问题，需要注意的是外侧循环只需要遍历与单词长度 `word_len` 相等的次数即可。因为在第一次循环的时候，就会检查第 `word_len` 个字符是否可以。

在一次外侧循环中，会检查之后的字符串是否满足条件，

```python
def findSubstring(s, words):
	word_len = len(words[0])
	word_num = len(words)
	n = len(s)
	if n < word_len: return []
	
	words = Counter(words)
	res = []
	for i in range(0, word_len):
		cur_cnt = 0
		left = i
		right = i
		cur_Counter = Counter()
		while right + word_len <= n:
			w = s[right:right + word_len]
			right += word_len
			if w not in words:  # 如果当前单词不存在，就跳过这个单词
				left = right
				cur_Counter.clear()
				cur_cnt = 0
			else:          
				cur_Counter[w] += 1
				cur_cnt += 1
				while cur_Counter[w] > words[w]: 
				# 如果某个单词的数量太多，就删除最左侧的单词，直到不多
					left_w = s[left:left+word_len]
					left += word_len
					cur_Counter[left_w] -= 1
					cur_cnt -= 1
				if cur_cnt == word_num:
					res.append(left)
	return res
```




## 回溯（递归）


将大问题拆分为小问题


### 十进制转二进制

```python
def decimal2Binary(num):
    res = ""
    if num < 2:
        return str(num)
    res += decimal2Binary(num // 2) + str(num % 2)
    return res
```


### 组合总和

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/description/)

同一个元素可以重复使用，解法中元素相同但顺序不同，也算为一种解法

```python
def combinationSum(candidates, target: int):
    sols = []
    n = len(candidates)

    def solve(target, idx, res):  # idx 
        if target == 0:
            sols.append(res[:])
            return
        if target < 2:
            return

        for i in range(idx, n):   # 遍历所有的组合
            res.append(candidates[i])
            solve(target - candidates[i], i, res) 
            res.pop()
    solve(target, 0, [])
    return sols
```

另一种写法，考虑每个元素可以选择或者不选

```python
def combinationSum(candidates, target: int):
	sols = []
	n = len(candidates)

	def solve(target, idx, res):
		if target == 0:
			sols.append(res[:])
			return
		if idx == n:
			return
		# 不选该元素
		solve(target, idx+1, res)
		
		# 选择该元素
		if target >= candidates[idx]:
			res.append(candidates[idx])
			solve(target - candidates[idx], idx, res)
			res.pop()
	solve(target, 0, [])
	return sols
```


如果存在重复的数字，并且待选的数字只能选一次

[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

一种做法是先对candidate进行排序，在选择时跳过重复元素

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()  # 先排序，方便去重
        
        def backtrack(start, target, path):
            if target == 0:
                res.append(path)
                return
            
            for i in range(start, len(candidates)):
                if i > start and candidates[i] == candidates[i - 1]:  # 跳过重复元素
                    continue
                if candidates[i] > target:
                    break  # 剪枝优化
                
                backtrack(i + 1, target - candidates[i], path + [candidates[i]])
        
        backtrack(0, target, [])
        return res
```

另一种做法，统计candidate中每个元素出现的次数，然后加上一个频次数组来确保每个元素只被选择一次

```python
def combinationSum2(candidates: List[int], target: int) -> List[List[int]]:
    sols = []
    c = Counter(candidates)
    nums = list(c.keys())
    freqs = list(c.values())

    n = len(nums)
    def solve(target, idx, res):
        if target == 0:
            sols.append(res[:])
            return
        if idx == n:
            return
        if target < 0:
            return
        # 不选择
        solve(target, idx+1, res)

		# 考虑选择
        if nums[idx] <= target:
            res.append(nums[idx])
            if freqs[idx] > 1:   # 该元素还可以选
                freqs[idx] -= 1
                solve(target-nums[idx], idx, res)
                freqs[idx] += 1
            else:
                solve(target-nums[idx], idx+1, res)
            res.pop()
    solve(target, 0, [])
    return sols
```

### 数组全排列

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

对于一个包含不同元素的数组，生成数组的全排列

首先第一个元素和第1到n个元素交换，然后是第二个元素和第2到n个元素交换，。。。最后是第n-1个元素和第n-1到n个元素交换

![](https://assets.leetcode-cn.com/solution-static/46/fig14.PNG)

```python
def permute(self, nums):
	self.sols = []
	n = len(nums)
	def solve(idx):
		if idx == n:
			self.sols.append(nums[:])
			return
		for i in range(idx, n):
			nums[i], nums[idx] = nums[idx], nums[i]
			solve(idx+1)
			nums[i], nums[idx] = nums[idx], nums[i]
	solve(0)
	return self.sols
```


如果存在重复数据[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/)

先排序，在求解的时候去重

```python
def permuteUnique(nums):
	sols = []
	n = len(nums)
	visited = [0] * n  # 记录已经被填入的元素
	nums.sort()
	def solve(res):
		if len(res) == n:
			sols.append(res[:])
			return
		
		for i in range(n):
			# 如果已经被填入，或者和未填入的前一个元素相等
			if visited[i] or (i > 0 and not visited[i-1] and nums[i] == nums[i-1]):
				continue
				
			visited[i] = 1
			solve(res+[nums[i]])
			visited[i] = 0
	solve([])
	return sols
```

这里的 `i > 0 and not visited[i-1] and nums[i] == nums[i-1]` 实际上保证了重复的元素可以按照顺序填入，必须前一个元素已经填入，该元素才能填入。

### 反转队列

[Reversing a queue using recursion - GeeksforGeeks](https://www.geeksforgeeks.org/reversing-queue-using-recursion/)

先取出最前面的元素，再反转剩下的队列，反转好之后，将最前面的元素加到最后。


```python
def reverse_queue(queue: Queue):
    if queue.empty():
        return
 
    # 元素出队列
    item = queue.queue[0]
    queue.get()
 
    # 翻转剩余队列
    reverse_queue(queue)
 
    # 元素入队列
    queue.put(item)
```



### 硬币之和问题

[Coin Change - Count Ways to Make Sum - GeeksforGeeks](https://www.geeksforgeeks.org/coin-change-dp-7/)

对于每个硬币，考虑使用和不使用该硬币时的情况，如果不这么做，容易出现重复的情况

```python
def countRecur(coins, n, sum):
  
    # 如果和为0，那么有一种方案（不选择硬币）
    if sum == 0:
        return 1

    # 这里考虑分不出的情况
    if sum < 0 or n == 0:
        return 0

    # 分成是否选择该硬币两种情况
    return countRecur(coins, n, sum - coins[n - 1]) + \
              countRecur(coins, n - 1, sum)

def count(coins, sum):
    return countRecur(coins, len(coins), sum)
```

一般情况下可以使用一个矩阵保存已经计算过的结果

```python
def countRecur_m(coins, n, sum, memo):
    if sum == 0:
        return 1
    
    if sum < 0 or n == 0:
        return 0
    
    if memo[n][sum] != -1:
        return memo[n][sum]

    memo[n][sum] = countRecur_m(coins, n, sum - coins[n - 1], memo) + countRecur_m(coins, n - 1, sum, memo)
    return memo[n][sum]

def count_m(coins, sum):
    memo = [[-1 for _ in range(sum + 1)] for _ in range(len(coins)+1)]
    return countRecur_m(coins, len(coins), sum, memo)
```

>memo的初始化方式似乎需要注意一下，只能采用这种方法，不能采用 `[[-1] * a] * b` 这种形式，因为这样创建的第二个维度似乎会共享一片内存。



### 求最长回文子字符串的长度

[Length of longest palindrom>ic sub-string : Recursion - GeeksforGeeks](https://www.geeksforgeeks.org/length-of-longest-palindromic-sub-string-recursion/)

递归中止情况是左右相等或左大于右，如果左右相等，那么将count+2，如果不相等的话，count变为0，分别计算一下左边加1和右边减1的情况。

```python
def longestPalindromic(strn, l, r, count):

    if l > r:
        return count
    
    if l == r:
        return count + 1
    
    if strn[l] == strn[r]:
        count = longestPalindromic(strn, l + 1, r - 1, count + 2)

        return max(max(count, longestPalindromic(strn, l + 1, r, 0)), longestPalindromic(strn, l, r - 1, 0))
    
    return max(longestPalindromic(strn, l + 1, r, 0), longestPalindromic(strn, l, r - 1, 0))
```

>用count传入信息时，似乎不能简单的使用memo来简化操作

### 二叉树的底部视图

[Bottom View of a Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/bottom-view-binary-tree/)

二叉树的底部视图指从底部向上看能看到的节点，这里需要考虑每个节点的水平位置，水平位置相等并且处于同一层的选择层次遍历时后遍历到的节点


使用层次遍历，遍历时记住每个节点对应的水平位置，即左子树是根节点的水平位置减1，右子树则是加1。

```python
def bottomView(root):
	from collections import deque, defaultdict
	queue = deque()
	# 根节点的水平位置为0
	queue.append((root, 0))
	
	hd_map = defaultdict(int)        
	while queue:
		node, hd = queue.popleft()
		
		# 更新hd对应的值
		hd_map[hd] = node.data
		
		if node.left is not None:
			queue.append((node.left, hd-1))
		if node.right is not None:
			queue.append((node.right, hd+1))
	
	res = [hd_map[hd] for hd in sorted(hd_map)]
	return res
```


### 生成数组的全部子集

[Print all subsets of a given Set or Array - GeeksforGeeks](https://www.geeksforgeeks.org/backtracking-to-find-all-subsets/)

解法1：从后向前，每次去除数组中的一个元素

```python
def get_all_subsets(arr, n, subs: list):
    
    if n == 0:
        subs.append(arr)
        return
    get_all_subsets(arr[:n-1] + arr[n:], n-1, subs)
    get_all_subsets(arr, n-1, subs)
```

解法2：从前到后，每次向结果中添加一个元素

```python
def get_all_subsets2(arr, l, idx, subs):
    if idx == len(arr):
        subs.append(l[:])   # 注意需要使用切片
        return

    l.append(arr[idx])
    get_all_subsets2(arr, l, idx+1, subs)

    l.pop()
    get_all_subsets2(arr, l, idx + 1, subs)
```

解法3：使用比特位来控制

假设数组中有n个元素，那么子集合共有 $2^n$ 个，可以使用比特来表示，如共有3个元素，则可以用 0- 7这8个数字表示，0 表示三个位置都为0，即空集，7 三个位置都是1，即全集。

```python
for i in range(1 << len(arr)):
	# Creating a list to store the current subset.
	cur = []

	# Iterating over each element of the array.
	for j in range(len(arr)):
		# Checking if the jth bit of i is set.
		if i & (1 << j):
			# If yes, then include that element in the subset.
			cur.append(arr[j])

	# Adding the current subset to the result list.
	ans.append(cur)

# Sorting the subsets in lexicographical order.
ans.sort()
```

### 拆分数组

将数组拆分为连续的子数组，即 `[1,2,3,4]` 拆分为 `[1,2]` 和 `[3,4]`

普通的拆分，每个子数组不为空

```python
def solve_p2(arr):
    n = len(arr)
    def _solve(arr, res, idx):
        if idx >= n:
            print(res)
            return
        temp = []
        for i in range(idx, n):
            temp.append(arr[i])
            res.append(temp[:])   # 注意需要存入切片
            _solve(arr, res, i+1)
            res.pop()
            
    _solve(arr, [], 0)
```

拆分为固定的 k 个子数组，每个子数组不为空

```python
def solve_p(arr, k):
    
    n = len(arr)
    def _solve(arr, nk, res, idx):

        if idx >= n:
            return
	    # 如果已经分了 k-1 个组，剩下的自动成为一个组
        if nk == k - 1:
            print(res+[arr[idx:]])
            return 
        
        temp = []
        for i in range(idx, n):
            temp.append(arr[i])
            res.append(temp[:])
            _solve(arr, nk+1, res, i+1)
            res.pop()
            
    _solve(arr, 0, [], 0)
```


### 矩阵最短路径

[Print all possible paths from top left to bottom right in matrix - GeeksforGeeks](https://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/)

求出所有从矩阵的左上方到右下方的最短路径

每次添加一个路径节点，然后选择向下还是向右

```python
def findAllPossiblePaths(n : int, m : int, grid):
	def get_all_possible_paths(grid, n, m, i,j, path, sols):
		if i == n-1 and j == m-1:
			sols.append(path[:]+[grid[-1][-1]])
			return
		
		path.append(grid[i][j])
		
		if i < n-1:
			get_all_possible_paths(grid, n, m, i+1,j, path, sols)
		
		if j < m - 1:
			get_all_possible_paths(grid, n, m, i,j+1, path, sols)
		
		path.pop()
		
	path = []
	sols = []
	get_all_possible_paths(grid, n, m, 0, 0, path, sols)
	return sols
```

### 生成平衡括号

[Print all combinations of balanced parentheses - GeeksforGeeks](https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/)

注意左括号的数量不超过一半，右括号数不大于左括号

```python
def gen_parenthesis_util(n, open, close, s, ans):
	# 如果左右括号都有 n 个
    if open == n and close == n:
        ans.append(s)
        return

    # 如果左括号的数量小于 n
    if open < n:
        gen_parenthesis_util(n, open + 1, close, s + "{", ans)

    # 只有当close < open时才会放，如果close已经大于等于open，再放右括号就会不平衡
    if close < open:
        gen_parenthesis_util(n, open, close + 1, s + "}", ans)

def AllParenthesis(n):
    ans = []
    if n > 0:
        gen_parenthesis_util(n, 0, 0, "", ans)
    return ans
```

还有另外一种基于动态规划的方法，[22. 括号生成 - 力扣（LeetCode）](https://leetcode.cn/problems/generate-parentheses/solutions/9251/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/)


### 最长公共子序列

[Longest Common Subsequence (LCS) - GeeksforGeeks](https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/)

这里的子序列允许不连续的情况出现

从末尾开始匹配，i 和 j 分别代表当前长度

```python
def lcs(s1, s2):
    def _lcs(s1, s2, i, j):
        if i == 0 or j == 0:
            return 0
        
        if s1[i-1] == s2[j-1]:
            return 1 + _lcs(s1, s2, i-1, j-1)
    
        return max(_lcs(s1, s2, i-1, j), _lcs(s1, s2, i, j-1))     
    cnt = _lcs(s1, s2, len(s1), len(s2))
    return cnt
```


使用一个矩阵保存计算过的状态

```python
def lcs_m(s1, s2):
    def _lcs(s1, s2, i, j, memo):
        if i == 0 or j == 0:
            return 0
        
        if memo[i][j] != -1:
            return memo[i][j]
        
        if s1[i-1] == s2[j-1]:
            memo[i][j] = 1 + _lcs(s1, s2, i-1, j-1, memo)
            return memo[i][j]
        memo[i][j] = max(_lcs(s1, s2, i-1, j, memo), _lcs(s1, s2, i, j-1, memo))  
        return memo[i][j]
    
    memo = [[-1 for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]
    
    cnt = _lcs(s1, s2, len(s1), len(s2), memo)

    return cnt
```


### 栈的递归排序

[How to Sort a Stack using Recursion - GeeksforGeeks](https://www.geeksforgeeks.org/sort-a-stack-using-recursion/)

```python
def sort_stack(stack: list):
    if len(stack) == 0:
        return
    # 弹出栈顶元素
    top = stack.pop()

    sort_stack(stack)

	# 保存大于top的栈顶元素
    temp = []

    while len(stack) > 0 and stack[-1] > top:
        temp.append(stack.pop())
    
    stack.append(top)

    while len(temp) > 0:
        stack.append(temp.pop())
```


### 翻转双向链表

[Reverse a Doubly linked list using recursion - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-doubly-linked-list-using-recursion/)


### N-皇后问题

[N Queen Problem - GeeksforGeeks](https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/)

[N Queen Problem using Branch And Bound - GeeksforGeeks](https://www.geeksforgeeks.org/n-queen-problem-using-branch-and-bound/)

可以考虑使用三个布尔数组来表示某一行、对角线和反对角线是否已经被占用了。具体做法是为每一行，每个对角线和反对角线都设置相同的数。

反对角线

![](https://media.geeksforgeeks.org/wp-content/uploads/king.jpg)

对角线
![](https://media.geeksforgeeks.org/wp-content/uploads/kingqueen.jpg)


```python
def solve(N):
    board = [[0 for i in range(N)] for i in range(N)]

    slashCode = [[0 for i in range(N)] for i in range(N)]
    backslashCode = [[0 for i in range(N)] for i in range(N)]

    # 初始化对角线和反对角线
    for i in range(N):
        for j in range(N):
            slashCode[i][j] = i + j
            backslashCode[i][j] = i - j + N - 1
    # True 表示该位置可以放
    slashLookUp = [True] * (2 * N - 1)
    backslashLookUp = [True] * (2 * N - 1)
    rowLookUp = [True] * N

    def isSafe(r, c):
        return slashLookUp[slashCode[r][c]] \
            and backslashLookUp[backslashCode[r][c]] \
                and rowLookUp[r]

    def _solve(board, c):
        if c == N:
            print(board)
            return True
        
        for r in range(N):
            if isSafe(r, c):
                # 该位置已经放置
                slashLookUp[slashCode[r][c]] = False
                backslashLookUp[backslashCode[r][c]] = False
                rowLookUp[r] = False
                board[r][c] = 1
                # 如果需要打印所有的解法，这里可以不返回True
                if  _solve(board, c+1):
                    return True
                # _solve(board, c+1)  # 如果需要打印所有的解法
	            
                # 该位置不可行，删除
                slashLookUp[slashCode[r][c]] = True
                backslashLookUp[backslashCode[r][c]] = True
                rowLookUp[r] = True
                board[r][c] = 0
        return False
    _solve(board, 0)
```


### 数独问题

[Algorithm to Solve Sudoku | Sudoku Solver - GeeksforGeeks](https://www.geeksforgeeks.org/sudoku-backtracking-7/)

[37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/)

采用回溯进行求解，用三个矩阵标记每行，每列和每个小方块是否包含了1-9这9个数字

```python
def solveSudoku(board: List[List[str]]) -> None:
	n = 9
	def solve(i, j):
		if i == 8 and j == 9:
			return True
		
		if j == 9:
			i += 1
			j = 0

		if board[i][j] == ".":
			for k in range(1, 10):
				if row[i][k-1] == col[j][k-1] == block[i//3][j//3][k-1]==False:
					row[i][k-1] = col[j][k-1] = block[i//3][j//3][k-1] = True
					board[i][j] = str(k)
					if solve(i, j+1):
						return True
					board[i][j] = "."
					row[i][k-1] = col[j][k-1] = block[i//3][j//3][k-1] = False
		else:
			return solve(i, j+1)
		
		return False

	row = [[False] * 9 for _ in range(9)]   # 标记行
	col = [[False] * 9 for _ in range(9)]   # 标记列
	block = [[[False] * 9 for _ in range(3)] for _ in range(3)]  # 标记 3x3 方块

	for i in range(9):
		for j in range(9):
			if board[i][j] != ".":
				k = int(board[i][j]) - 1
				row[i][k] = col[j][k] = block[i//3][j//3][k] = True
	solve(0, 0)
```


### 国王旅行问题

[The Knight's tour problem - GeeksforGeeks](https://www.geeksforgeeks.org/the-knights-tour-problem/)


## 矩阵


### 矩阵计算斐波那契数列

对于广义斐波那契数列 $g(n)=a*g(n-1)+b*g(n-2)+c$ ，使用迭代方法时间复杂度为 $O(n)$，使用矩阵计算可以将时间复杂度降为 $O(\log_2n)$

矩阵计算可以表示成

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = \left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]\left[ \matrix{
  g(n - 1) \hfill \cr 
  g(n - 2) \hfill \cr 
  c \hfill \cr}  \right]
$$
这样$g(n)$ 可以这样计算

$$
\left[ \matrix{
  g(n) \hfill \cr 
  g(n - 1) \hfill \cr 
  c \hfill \cr}  \right] = {\left[ {\matrix{
   a & b & 1  \cr 
   1 & 0 & 0  \cr 
   0 & 0 & 1  \cr 

 } } \right]^{n - 2}}\left[ \matrix{
  g(2) \hfill \cr 
  g(1) \hfill \cr 
  c \hfill \cr}  \right]
$$

等式右侧的幂次矩阵可以一次算两个，甚至可以先算好两次方，直接用也行

具体实现如下

```python
mat = [[0 for i in range(3)] for j in range(3)]
res = [[0 for i in range(3)] for j in range(3)]

def mul(self, res, mat, m):
	res1 = [[0 for i in range(3)] for j in range(3)]
	for i in range(3):
		for j in range(3):
			for k in range(3):
				res1[i][j] += (res[i][k]*mat[k][j]) # Multiplying matrices element-wise and summing
				res1[i][j] %= m # Taking modulo m to avoid overflow
	
	for i in range(3):
		for j in range(3):
			res[i][j] = res1[i][j] # Updating the resultant matrix

def mat_exp(self, n, m):
	while n>0:
		if n&1:  
			self.mul(self.res, self.mat, m) # Multiplying the result matrix with the current matrix
		self.mul(self.mat,self.mat,m) # Squaring the current matrix
		n //= 2 # Halving the power of the matrix
```


### 搜索二维矩阵

[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/)

给定一个矩阵，每行元素从左到右升序排列，每列元素从上到下排列

最简单的算法是对每行进行二分查找

还有一种时间复杂度更低的方法，Z 字查找

我们可以从矩阵 matrix 的右上角 `(0,n−1)` 进行搜索。在每一步的搜索过程中，如果我们位于位置 `(x,y)`，那么我们希望在以 matrix 的左下角为左下角、以 `(x,y)` 为右上角的矩阵中进行搜索，即行的范围为 `[x,m−1]`，列的范围为 `[0,y]`：

如果 `matrix[x,y]=target`，说明搜索完成；

如果 `matrix[x,y]>target`，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 y 列的元素都是严格大于 target 的，因此我们可以将它们全部忽略，即将 y 减少 1；

如果 `matrix[x,y]<target`，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 x 行的元素都是严格小于 target 的，因此我们可以将它们全部忽略，即将 x 增加 1。

在搜索中如果超出矩阵边界，就证明不存在target


### 验证井字棋

[Validity of a given Tic-Tac-Toe board configuration - GeeksforGeeks](https://www.geeksforgeeks.org/validity-of-a-given-tic-tac-toe-board-configuration/)

先列举所有的获胜情况，然后对 `X` 和 `O` 分别验证获胜情况


### 名人问题

[The Celebrity Problem - GeeksforGeeks](https://www.geeksforgeeks.org/the-celebrity-problem/)

假设有n个人，他们之间是否相互认识通过一个矩阵给定，找出其中所有人都认识的人，但这个人不认识其他人。

该问题可以转变为找到一列全为1，但对应行只有对角线元素为1，使用双指针解决这一问题

左指针 `l` 指向 0，右指针 `r` 指向 n-1

```python
def solve(mat, ):
    n = len(mat)
    l, r = 0, n-1

    while l < r:

        # 如果 l 不知道 r，那么r不是名人
        if mat[l][r] == 0:
            r -= 1
        # 如果 r 不知道 l，那么l不是名人
        if mat[r][l] == 0:
            l += 1
        
        # r 和 l 之间知道或者不知道，l 和 r 都不是名人
        if mat[r][l] == mat[l][r] and l != r:
            r -= 1
            l += 1
    if l > r:
        return -1
    else:
        for i in range(n):
            if mat[l][i] == 1 and i != l:
                return -1
            if mat[i][l] == 0 and i != l:
                return -1
    return l
```


### 矩阵旋转

[Rotate Matrix Clockwise by 1 - GeeksforGeeks](https://www.geeksforgeeks.org/rotate-matrix-elements/)

```python
def solve(mat):
    n = len(mat)
    m = len(mat[0])
    if n == 1:
        return
    
    left = 0
    right = m - 1
    top = 0
    down = n - 1

    while left < right and top < down:
        # 旋转最左侧
        tl = mat[top][left]
        for i in range(top, down):
            mat[i][left] = mat[i+1][left]

        mat[down][left] = mat[down][left+1]

        # 旋转最上方
        tr = mat[top][right]
        for i in range(right, left+1, -1):  # 1, n-1
            mat[top][i] = mat[top][i-1]
        
        mat[top][left+1] = tl

        # 旋转最右边
        dr = mat[down][right]

        for i in range(down, top+1, -1):
            mat[i][right] = mat[i-1][right]
        mat[top+1][right] = tr

        # 旋转最下边
        for i in range(left, right-1):
            mat[down][i] = mat[down][i+1]
        mat[down][right-1] = dr

        left += 1
        right -= 1
        top += 1
        down -= 1
```


### 被 X 包围的最大边界

[Largest Cross Bordered Square - GeeksforGeeks](https://www.geeksforgeeks.org/given-matrix-o-x-find-largest-subsquare-surrounded-x/)

最一般的方法是对矩阵的每个元素，从大小为1开始，判断边界是否全为 `X`

另一种方法，先创建一个right和down矩阵，`right[i][j]` 表示从 `(i,j)` 这个点到右侧有多少个连续的 `X`，`down[i][j]` 表示从 `(i,j)` 这个点到下侧有多少个连续的 `X`

因此对于左上角的 `[i,j]` 而言，其边界均为`X`的最大长度为 `right[i][j]` 和 `down[i][j]` 中的最小值。同时对长度进行遍历，判断左下和右上是不是也满足至少有若干个连续的 `X`

```python
def solve(mat):
    n = len(mat)

    right = [[0 for _ in range(n)] for _ in range(n)]
    down = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n-1, -1, -1):
        for j in range(n-1, -1, -1):
            if mat[i][j] == "X":
                right[i][j] = 1 if j+1 == n else right[i][j+1]+1
                down[i][j] = 1 if i+1 == n else down[i+1][j] + 1
    maxSize = 0
    for i in range(n):
        for j in range(n):
            maxSide = min(right[i][j], down[i][j])

            for side in range(maxSide, 0, -1):
                if down[i][j+side-1] >= side \
                      and right[i+side-1][j] >= side:
                    maxSize = max(maxSize, side)
                    break
    return maxSize
```


### 最大全 1 方阵

[Maximum size square sub-matrix with all 1s - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/)

回溯法，如果一个点为0，那么返回0，如果为1，看其右、下和右下方的全1方阵大小。

```python
def solve(mat):
    def _solve(mat, i, j, ans):
        if i >= len(mat) or j >= len(mat[0]):
            return 0
        right = _solve(mat, i, j + 1, ans)
        down = _solve(mat, i + 1, j, ans)
        rd = _solve(mat, i + 1, j + 1, ans)

        if mat[i][j] == 0:
            return 0
        nv = 1 + min(min(right, down), rd)
        ans[0] = max(nv, ans[0])
        return nv

    ans = [0]
    _solve(mat, 0, 0, ans)
    print(ans)
```

动态规划

```python
def solve_dp(mat):
    n = len(mat)
    m = len(mat[0])

    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
    ans = 0
    for i in range(n-1, -1, -1):
        for j in range(m-1, -1, -1):
            if mat[i][j] == 1:
                dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1])
            else:
                dp[i][j] = 0
            ans = max(ans, dp[i][j])
    print(ans)
```


### 矩阵相等的最小转换次数

只允许每次在矩阵的某行某列加1，问这样的操作能否使得两个矩阵相等，如果可以求出最小转换次数

如何判断两个矩阵能否通过加1相等，有下面的推到


```
a * b        a * b       a * b - d + c
* * *   =>   * * *   =>  * * *          => a + d = b + c
c * d        0 * d-c     0 * 0
```


只需要判断 `a[0][j]+a[i][0]==a[i][j]+a[0][0]`是否成立即可

求最小转换次数时，先将第一列的每行元素转为0，由于 `d-c=b-a`，再减去 `abs(a[0][j]-a[0][0])`

```python
def countOperations(a, b):
    n = len(a)
    m = len(a[0])

    # 创建差异矩阵
    for i in range(n):
        for j in range(m):
            a[i][j] -= b[i][j]

    # 如果 a[i][j] - a[i][0] - a[0][j] + a[0][0] 为0，那么可以转换
    for i in range(1, n):
        for j in range(1, m):
            if a[i][j] - a[i][0] - a[0][j] + a[0][0] != 0:
                return -1

    result = 0

    # 第一列需要的加操作
    for i in range(n):
        result += abs(a[i][0])

    # 第一行（除了 a[0][0]） 需要的加操作
    for j in range(m):
        result += abs(a[0][j] - a[0][0])

    return result
```


### 计算行排序矩阵的中位数

[Find median in row wise sorted matrix - GeeksforGeeks](https://www.geeksforgeeks.org/find-median-row-wise-sorted-matrix/)

如果矩阵的行和列都是奇数，即肯定能在矩阵中找到一个点为中位数，可以使用二分搜索的方法进行搜索

```python
from bisect import bisect_right

def median(mat):
	r = len(mat)
	c = len(mat[0])

	minVal = float('inf')
	maxVal = float('-inf')

	# 找到矩阵中的最小值和最大值
	for i in range(r):
		minVal = min(minVal, mat[i][0])
		maxVal = max(maxVal, mat[i][c - 1])

	desired = (r * c + 1) // 2
	lo = minVal
	hi = maxVal

	# 二分搜索找到中位数
	while lo <= hi:
		mid = lo + (hi - lo) // 2
		place = 0

		# 通过 bisect_right 找到小于等于中位值的元素的位置
		for i in range(r):
			place += bisect_right(mat[i], mid)

		if place < desired:
			lo = mid + 1
		else:
			hi = mid - 1

	return lo
```


### 矩阵连乘问题

[Matrix Chain Multiplication - GeeksforGeeks](https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/)

若干个矩阵相乘，求最小的矩阵乘法次数

回溯法

将矩阵连乘分解到两两相乘的地步

```python
def solve(chains):

    def _solve(chains, i, j):

        # 已经分解成单个矩阵了        
        if i + 1 == j:
            return 0
        
        ans = float("inf")

        # 在 i，j 之间寻找一个点分成两个矩阵
        for k in range(i+1, j):
            res = _solve(chains, i, k) + _solve(chains, k, j) + chains[i] * chains[k] * chains[j]
            ans = min(ans, res)
        return ans

    if len(chains) == 2:
        return 0
    res = _solve(chains, 0, len(chains) - 1)
    return res
```

对应的动态规划

```python
def solve_dp(arr):

    n = len(arr)
    if n == 2:
        return 0
    
    dp = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n-1, -1, -1):
        for j in range(i+2, n, 1):
            ans = float("inf")
            for k in range(i+1, j):
                res = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]
                ans = min(ans, res)
            dp[i][j] = ans
    
    return dp[0][n-1]
```



### 最大全1矩阵

[Maximum size rectangle binary sub-matrix with all 1s - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/)

第一种解法：参考数组问题中的计算直方图的最大面积问题。从上到下，对每一行，统计每一列的连续1个数，如果该列为0，就是0，将其作为一个直方图，计算最大面积

```python
def getMaxArea(arr):
    n = len(arr)

    prev = [-1] * n
    next = [n] * n

    st = []
    # 找到后一个较小值和前一个较小值
    for i in range(n):
        # 如果 i 比栈中最后一个元素要小
        while st and arr[i] < arr[st[-1]]:
            next[st.pop()] = i
        if st:
            prev[i] = st[-1]
        st.append(i)

    maxArea = 0
    for i in range(n):
        twidth = next[i] - prev[i] - 1
        maxArea = max(arr[i] * twidth, maxArea)
    return maxArea

def maxArea(mat):
    n = len(mat)
    m = len(mat[0])

    # 统计到目前行时有多少个连续个 1
    arr = [0] * m

    ans = 0

    for i in range(n):
        for j in range(m):
            if mat[i][j] == 1:
                arr[j] += 1
            else:
                arr[j] = 0

        ans = max(ans, getMaxArea(arr))

    return ans
```


动态规划：统计以每个点`(i,j)` 结尾的 1 的宽度，然后从下向上遍历每一行，找到最小宽度，乘上高度

```python
def maxArea(mat):
    n, m = len(mat), len(mat[0])

    # 以每个元素结尾的 1 的宽度
    memo = [[0] * m for _ in range(n)]
    ans = 0

    for i in range(n):
        for j in range(m):
            if mat[i][j] == 0:
                continue

            if j == 0:
                memo[i][j] = 1
            else:
                memo[i][j] = 1 + memo[i][j - 1]

            width = memo[i][j]

            # 遍历之前的行，找到最小宽度，计算区域
            for k in range(i, -1, -1):
                width = min(width, memo[k][j])
                area = width * (i - k + 1)

                ans = max(ans, area)

    return ans
```


### 二叉树构造祖先矩阵

[Construct Ancestor Matrix from a Given Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/construct-ancestor-matrix-from-a-given-binary-tree/)

给定二叉树，构造一个祖先矩阵，即若 i 是 j 的祖先，则有 `arr[i][j]=1`

```python
def solve(node: Node, n):

    def _solve(node: Node, anc, mat):
        if node is None:
            return
        
        x = node.data
		
        for a in anc:
            mat[a][x] = 1

        anc.append(x)

        _solve(node.left, anc, mat)
        _solve(node.right, anc, mat)

        anc.pop()
    
    anc = []   # 保存当前节点的祖先
    mat = [[0 for _ in range(n)] for _ in range(n)]

    _solve(node, anc, mat)
    print(mat)
```


### 找到最多的+型矩阵

[Find size of the largest '+' formed by all ones in a binary matrix - GeeksforGeeks](https://www.geeksforgeeks.org/find-size-of-the-largest-formed-by-all-ones-in-a-binary-matrix/)

构造四个矩阵，分别计算上下左右的连续1个数

主要看如何一次性构造四个矩阵


### 走二进制迷宫

在一个二进制矩阵中，1 表示可以走，0表示不可以走，给定起点和终点，求出一条最短矩阵

回溯法：注意使用一个矩阵保存已经访问过的节点，避免重复访问

```python
def solve(mat, x, y):

    def isSafe(mat, i, j, visited, m, n):
        if i >=0 and j >=0 and i < m and j < n \
        and mat[i][j] == 1 and not visited[i][j]:
            return True
        return False

    def _solve(mat, i, j, x, y, visited, m, n):
        
        if i == x and j == y:
            return 0
        
        res = m * n
        visited[i][j] = True
        if isSafe(mat, i - 1, j, visited, m, n):
            res = min(res, 1 + _solve(mat, i-1, j, x, y, visited, m, n))

        if isSafe(mat, i + 1, j, visited, m, n):
            res = min(res, 1 + _solve(mat, i+1, j, x, y, visited, m, n))

        if isSafe(mat, i, j - 1, visited, m, n):
            res = min(res, 1 + _solve(mat, i, j-1, x, y, visited, m, n))
        
        if isSafe(mat, i, j + 1, visited, m, n):
            res = min(res, 1 + _solve(mat, i, j+1, x, y, visited, m, n))
        
        visited[i][j] = False
        return res
    
    m = len(mat)
    n = len(mat[0])
    visited = [[False for _ in range(n)] for _ in range(m)]
    res = _solve(mat, 0, 0, x, y, visited, m, n)
    print(res)
```

这样的复杂度过高，可以采用bfs的方法进行遍历

```python
def solve_bfs(mat, x, y):
    class Node:
        def __init__(self, x, y, d):
            self.p = (x, y)
            self.d = d

    def isSafe(mat, i, j, visited, m, n):
        if i >=0 and j >=0 and i < m and j < n \
        and mat[i][j] == 1 and not visited[i][j]:
            return True
        return False
    
    def _solve(mat, i, j, x, y, m, n):
        if mat[i][j] != 1 or mat[x][y] != 1:
            return -1
        
        q = []
        s = Node(i, j, 0)
        q.append(s)
        
        visited[i][j] = True

        while len(q) != 0:
            curr = q.pop(0)
            if curr.p[0] == x and curr.p[1] == y:
                return curr.d

            for i in range(4):
                row = curr.p[0] + rowNum[i]
                col = curr.p[1] + colNum[i]

                if isSafe(mat, row, col, visited, m, n):
                    visited[row][col] = True
                    adj = Node(row, col, curr.d + 1)
                    q.append(adj)
        return -1
    m = len(mat)
    n = len(mat[0])
    visited = [[False for _ in range(n)] for _ in range(m)]
    rowNum = [-1, 0, 0, 1]
    colNum = [0, -1, 1, 0]

    res = _solve(mat, 0, 0, x, y, m, n)
    print(res)
```


### 矩阵的最大和矩形

[Maximum sum rectangle in a 2D matrix | DP-27 - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/)

只讨论时间复杂度最低的第三种算法，由于需要求的是矩形，所以可以先遍历确定左右边界，然后对左右边界之间的元素按行求和得到一维数组，然后使用kadane算法求最大和

```python
def kadaneAlgorithm(temp):
    rows = len(temp)

    currSum = 0
    maxSum = float('-inf')

    for i in range(rows):
        currSum += temp[i]

        # 如果当前和更大，更新最大和
        if maxSum < currSum:
            maxSum = currSum

        # 当前和小于0，将其置为0
        if currSum < 0:
            currSum = 0

    return maxSum


def maxSumRectangle(mat):
    rows = len(mat)
    cols = len(mat[0])

    maxSum = float('-inf')

    # 遍历左右边界
    for left in range(cols):
        # 重置临时数组
        temp = [0] * rows

        for right in range(left, cols):
            # 用当前列的元素更新当前行的和
            for row in range(rows):
                temp[row] += mat[row][right]

            # 找到当前列边界之间的最大和
            sumValue = kadaneAlgorithm(temp)

            # 更新全局最大值
            maxSum = max(maxSum, sumValue)

    return maxSum
```


## 栈


栈：先入先出


### 使用栈实现队列

[Queue using Stacks - GeeksforGeeks](https://www.geeksforgeeks.org/queue-using-stacks/)

使用两个栈，有两种算法可以选择

1、在入队列时，将stack1中的元素全部pop，并push到stack2，再将新元素push到stack1，再将stack2的元素全部push回stack1；在出队列时，直接pop即可

2、在入队列时，直接将元素push到stack1；出队列时，如果两个栈都为空报错，如果stack2为空，将stack1的所有元素塞入stack2，从stack2 pop出元素。

算法2比算法1好，因为算法2的出栈和入栈次数少。

### 队列实现栈

[Implement Stack using Queues - GeeksforGeeks](https://www.geeksforgeeks.org/implement-stack-using-queue/)

使用两个队列时，有两种算法可选

1、在入栈时，直接将元素入队列queue1；出栈时，将queue1中的元素（除了最后一个）全部送入queue2中，然后queue1的最后一个元素出队列，完成后，交换queue1和queue2的名字

2、在入栈时，将元素送入queue2的队列，将queue1中的所有元素送入queue2中，交换queue1和queue2；出栈时，直接从queue1出队列即可

```python
class MyStack:
    def __init__(self):
        self.queue1 = deque()
        self.queue2 = deque()
        self.isNowQueue1 = True

    def push(self, x):
        if self.isNowQueue1:
            self.queue1.append(x)
        else:
            self.queue2.append(x)
    
    def empty(self):
        return len(self.queue1) == 0 and len(self.queue2) == 0

    def pop(self):
        if self.empty():
            return None
        if self.isNowQueue1:
            while len(self.queue1) > 1:
                v = self.queue1.popleft()
                self.queue2.append(v)
            v = self.queue1.popleft()
            self.isNowQueue1 = False
        else:
            while len(self.queue2) > 1:
                v = self.queue2.popleft()
                self.queue1.append(v)
            v = self.queue2.popleft()
            self.isNowQueue1 = True
        return v
    
    def top(self):
        if self.empty():
            return None
        if self.isNowQueue1:
            while len(self.queue1) > 1:
                v = self.queue1.popleft()
                self.queue2.append(v)
            v = self.queue1[0]
        else:
            while len(self.queue2) > 1:
                v = self.queue2.popleft()
                self.queue1.append(v)
            v = self.queue2[0]
        return v
```

如果只有一个队列，当第一个元素到来时，将元素送入队列，当第二个元素到来时，直接塞进去，但是再将第一个元素送入，将原本的第一个元素弹出

单队列实现

```python
class MyStack:
    def __init__(self):
        self.queue = deque()

    def push(self, x):
        n = len(self.queue)
        self.queue.append(x)
        for i in range(n):
            self.queue.append(self.queue.popleft())
        
    def empty(self):
        return len(self.queue) == 0

    def pop(self):
        if self.empty():
            return None
        v = self.queue.popleft()
        return v
    
    def top(self):
        if self.empty():
            return None
        return self.queue[0]
```



### 使用优先队列实现栈

[geeksforgeeks.org/implement-stack-using-priority-queue-or-heap/](https://www.geeksforgeeks.org/implement-stack-using-priority-queue-or-heap/)

入栈时，不仅让元素入队列，还加上元素的序号，如第一个元素 a 以 `(0, a)` 的方式入队列，由于python中没有最大堆，所以可以在序号前加上负号，来让最后一个元素优先出队列。

### 基础计算器

下面实现了一个支持加减乘除的计算器，还支持括号

使用两个栈分别保存数字和操作符，只要操作符栈顶元素的优先级大于当前操作符的优先级并且数字栈还有足够的元素就计算。遇到左括号就保存，遇到右括号就计算。

```python
def solve(s):
    st = []
    dst = []
    num = 0
    lastNum = False
    lastLeft = True
    s = "(" + s + ")"

    def cal():   # 直接计算
        op = st.pop()
        num2 = dst.pop()
        num1 = dst.pop()
        if op == "+":
            return num1 + num2
        elif op == "-":
            return num1 - num2
        elif op == "^":
            return num1 ** num2
        elif op == "*":
            return num1 * num2
        elif op == "/":
            return num1 // num2

    def prior(op):
        if op == "^":
            return 3
        elif op == "*" or op == "/":
            return 2
        elif op == "+" or op == "-":
            return 1
        else:
            return -1

    for i in range(len(s)):
        c = s[i]
        if c.isdigit():
            num = 10 * num + int(c)
            lastNum = True
            lastLeft = False
        else:
            if c == " ":
                continue
            else:
                if lastNum:   # 如果之前是数字就把结果保存下来
                    dst.append(num)
                    num = 0
                if c == '(':
                    st.append('(')
                    lastLeft = True
                elif c == ')':
                    while st[-1] != "(":
                        res = cal()
                        dst.append(res)
                    st.pop()
                    lastLeft = False
                else:
                    if c == "-" and lastLeft:
                        dst.append(0)  # 处理负号为单操作符时的情况

                    while len(dst) >= 2 and prior(st[-1]) >= prior(c):
                        res = cal()
                        dst.append(res)
                    st.append(c)
                    lastLeft = False
                    
                lastNum = False
    return dst[-1]
```

对于不包含括号的可以参考：[227. 基本计算器 II - 力扣（LeetCode）](https://leetcode.cn/problems/basic-calculator-ii/)


### 表达式互转

[Convert Infix expression to Postfix expression - GeeksforGeeks](https://www.geeksforgeeks.org/convert-infix-expression-to-postfix-expression/)

遇到操作符，比较操作符和目前栈顶的操作符的优先级顺序（`(`的运算级顺序设为最低），如果大于压入栈，小于等于就出栈，遇到操作数就放入结果中，遇到 `(` 直接入栈，遇到 `)` 出栈直到遇到 `(`

[Postfix to Infix - GeeksforGeeks](https://www.geeksforgeeks.org/postfix-to-infix/)

从左到右，遇到操作数直接入栈，遇到操作符，弹出两个元素合成一个子表达式（加上括号），再将子表达式压入栈中


[Prefix to Postfix Conversion - GeeksforGeeks](https://www.geeksforgeeks.org/prefix-postfix-conversion/)

[Postfix to Prefix Conversion - GeeksforGeeks](https://www.geeksforgeeks.org/postfix-prefix-conversion/)


### 最小栈

[155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/)

在push的时候用一个栈保存目前最小的值，在pop时如果pop的值和最小栈中的栈顶元素相等时，需要同时pop最小栈。

```python
class MinStack:
    def __init__(self):
        self.stack1 = []  # 普通栈
        self.stack2 = []  # 最小栈

    def push(self, x):
        self.stack1.append(x)
        if len(self.stack2) == 0:
            self.stack2.append(x)
        else:
        # 如果当前值小于最小栈的栈顶元素，入栈
            if x <= self.stack2[-1]:
                self.stack2.append(x)
    
    def empty(self):
        return len(self.stack1) == 0
    
    def top(self):
        return self.stack1[-1]
    
    def getMin(self):
        return self.stack2[-1]

    def pop(self, x):
        if self.empty():
            return None
        v = self.stack1.pop()
        if v == self.getMin(): # 弹出最小元素，最小栈也需要出栈
            self.stack2.pop()
        return v
```

### 翻转栈

[How to Reverse a Stack using Recursion - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-a-stack-using-recursion/)

使用递归进行处理，数据出栈，处理剩下的stack，最后将数据塞入栈的最下方

```python
def reverse_stack(stack):
    # 将元素放在最底部
    def insert(stack, item):
        if len(stack) == 0:
            stack.append(item)
        else:
            top = stack.pop()
            insert(stack, item)
            stack.append(top)
    
    if len(stack) == 0:
        return
    # 弹出最开始的元素
    top = stack.pop()
    reverse_stack(stack)  # 反转剩下来的元素
    insert(stack, top)   # 插入弹出的元素
```


基于链表翻转栈
[Reverse a stack without using extra space in O(n) - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-stack-without-using-extra-space/)

使用单向链表实现一个栈

```python
class LinkedList:
    def __init__(self):
        self.head = None

    def push(self, data):
        if self.head is None:
            self.head = Node(data)
            return
        
        temp = Node(data)
        temp.next = self.head
        self.head = temp
    
    def pop(self):
        temp = self.head
        self.head = self.head.next
        return temp

    def reverse(self):
        if self.head is None:
            return
        prev = self.head
        curr = self.head.next
        prev.next = None

        while curr is not None:
            next = curr.next   # 保存下一个节点
            curr.next = prev   # 翻转当前节点
            prev = curr
            curr = next
        self.head = prev
```


### 移掉K位数字

[402. 移掉 K 位数字 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-k-digits/solutions/484940/yi-diao-kwei-shu-zi-by-leetcode-solution/)

给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

这里的K位是按顺序移除的k个数字，不需要连续。

解决方法：将每位数字压入栈中，如果当前数字小于栈顶数字就从栈顶移除一个数字（这里需要使用while持续进行），将该数字塞入栈中

```python
def removeKdigits(num: str, k: int) -> str:
    if len(num) == k: return "0"
    stack = []
    for i in range(len(num)):
        # 栈顶元素较大删除栈顶元素
        while k and len(stack) > 0 and stack[-1] > num[i]:
            stack.pop()
            k -= 1
        stack.append(num[i])
    # 还没删除k个元素，继续删除
    while k > 0:
        stack.pop()
        k -= 1
    
    res = "".join(stack).lstrip("0")
    if res == "": res = "0"
    return res
```



### 可合并栈

[How to create mergeable stack? - GeeksforGeeks](https://www.geeksforgeeks.org/create-mergable-stack/)

如何创建一个可以合并的栈

使用双向链表实现，下面简单给出pop的代码

```python
def pop(self):
         
	if (self.head == None):
		print("Stack underflow")

	if (self.head == self.tail):
		self.head = None
		self.tail = None

	else:
		node = self.tail
		self.tail = self.tail.prev
		del node
		self.tail.next = None
```


### 前一个更小值和后一个更大值

[Nearest smaller numbers on left side in an array - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/)

[Next Greater Element (NGE) for every element in given Array - GeeksforGeeks](https://www.geeksforgeeks.org/next-greater-element/)

在求前一个更小值时，遍历数组，如果栈非空且栈顶元素大于等于当前元素，就弹出这个元素，反之这个元素的更小值就是栈顶元素。

在求后一个更大值时，同样用一个栈保存元素索引和值，遍历数组，如果栈顶元素的值小于当前元素，就弹出栈顶元素，栈顶元素对应的后一个更大值便是当前元素


前一个更小值代码

```python
def solve(arr):
    n = len(arr)
    smaller = [-1] * n
    stack = []
    
    for i in range(n):

        while len(stack) != 0 and stack[-1][1] >= arr[i]:
            stack.pop()
        
        if len(stack)!=0 and stack[-1][1] < arr[i]:
            smaller[i] = stack[-1][1]
        
        stack.append((i+1, arr[i]))

    print(smaller)
```


下一个更大值的代码

```python
def solve(arr):
    n = len(arr)
    greater = [-1] * n
    stack = []
    
    for i in range(n):
        while len(stack)!=0 and stack[-1][1] < arr[i]:
            p,v = stack.pop()
            greater[p] = arr[i]
        
        stack.append((i, arr[i]))
    print(greater)
```


同时求前一个更大值和后一个更大值，用一个栈保存大于 `arr[i]` 的索引

```python
def bigger(arr):
    n = len(arr)
    next = [n] * n
    prev = [-1] * n

    st = []

    for i in range(n):
        while len(st) and arr[st[-1]] < arr[i]:
            next[st.pop()] = i
        
        if len(st):
            prev[i] = st[-1]
        st.append(i)
```

### 所有子数组的最大值

[Sum of Max of Subarrays - GeeksforGeeks](https://www.geeksforgeeks.org/sum-of-maximum-elements-of-all-possible-sub-arrays-of-an-array/)

用一个数组记录数组中每个数的左边界距离和右边界距离，从左到右，使用一个单调栈记录每个元素的左边界（左侧更大的值所处的位置），从右到左用一个单调栈记录每个元素的右边界（右侧更大的值所处位置）。左右边界相乘就是该元素作为最大值出现的次数

考虑数组 10 8 5 7 3 9，元素7的左边界（`arr[1]=8`）和右边界（`arr[5]=9`）的距离都是2，这样元素7所能取得最大值的子数组只能在 5 7 3 这个范围取，子数组的数量为 2 * 2 = 4，即 `{5,7}`、`{7,3}`、`{7}` 和 `{5,7,3}`。


### 每个窗口大小的最小值的最大值

[Maximum of minimums of every window size in a given array - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-maximum-of-minimums-for-every-window-size-in-a-given-array/#expected-approach-using-stack-on-time-and-on-space)

对每个元素找到前一个和后一个较小值，然后计算两个较小值之间的距离，这样可以确定该元素取为最小值时的范围。

```python
def maxOfMins(self, arr):
        n = len(arr)
        res = [0] * n
    
        lenArr = [0] * n
        prev = [-1] * n
        next = [n] * n
        stack = []
        
        # 计算上一个和下一个较小值
        for i in range(n):
            while stack and arr[stack[-1]] >= arr[i]:
                next[stack.pop()] = i
            if len(stack):
                prev[i] = stack[-1]
            stack.append(i)
            
        # 计算上一个和下一个较小值之间的距离
        for i in range(n):
            lenArr[i] = next[i] - prev[i] - 1
    
        # 注意这里的windowSize减一是因为数组从0开始
        # 即 res[0] 为长度为1的窗口的结果
        for i in range(n):
            windowSize = lenArr[i] - 1
            res[windowSize] = max(res[windowSize], arr[i])
    
        # 
        for i in range(n - 2, -1, -1):
            res[i] = max(res[i], res[i + 1])
    
        return res
```



## 队列


### BFS

[Breadth First Search or BFS for a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)

BFS 算法如下：对于一个给定的邻接矩阵进行遍历，创建一个queue来存储访问到的节点，用一个 visited 存储已经访问过的节点

时间复杂度为 $O(V+E)$，V 和 E 分别是顶点和边的数量，空间复杂度为 $O(V)$


```python
def bfs(adj, node): # 从顶点node开始遍历
    n = len(adj)
    queue = deque()
    queue.append(node)
    visited = [False] * n
    
    while len(queue) != 0:
        curr = queue.popleft()
        print(f"now: {curr}")
        visited[curr] = True
        for neigh in adj[curr]:
            if not visited[neigh]:
                queue.append(neigh)
                visited[neigh] = True
```


如果图中存在无连接的情况，可以从每个顶点开始进行bfs。

#### BFS检测无向图中的环


[Detect cycle in an undirected graph using BFS - GeeksforGeeks](https://www.geeksforgeeks.org/detect-cycle-in-an-undirected-graph-using-bfs/?ref=rp)

从每个节点开始遍历，维持一个访问数组，已经访问过的节点不再访问，对于每个节点，访问其邻接节点。如果一个节点已经访问过了，并且还不是父节点，那么就是存在环。

如果是树结构，就不需要访问数组了，因为可以通过左右节点向下传递，不会重新访问到父节点

#### BFS搜索节点的level

[Find the level of given node in an Undirected Graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-level-of-given-node-in-an-undirected-graph/)

在搜索时保存节点和level

```python
def nodeLevel(V, adj, X):
	queue = deque()
	if X == 0:
		return 0
	# 从节点0开始
	queue.append((0, 0))
	visited = [False] * V
	while len(queue) != 0:
		curr, level = queue.popleft()
		for neigh in adj[curr]:
			if not visited[neigh]:
				if X == neigh:
					return level + 1
				visited[neigh] = True
				queue.append((neigh, level+1))
	return -1
```


#### 到达数组末尾的最小跳跃次数

[Minimum jumps to same value or adjacent to reach end of Array - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-jumps-to-same-value-or-adjacent-to-reach-end-of-array/)

每次只能跳到同一个值或者左右

自己的解法，不一定正确，先遍历数组，根据只能跳到同一个值和左右两个值这一条件，确定每个节点的邻接点，然后用bfs进行搜索

```python
def solve(arr):
    n = len(arr)
    adj = [[] for _ in range(n)]

    for i in range(n):
        if i < n - 1:
            adj[i].append(i+1)
        
        if i > 0:
            adj[i].append(i-1)
        for j in range(n):
            if j != i:
                if arr[i] == arr[j]:
                    adj[i].append(j)
    
    queue = deque()
    visited = [False] * n
    queue.append((0, 0))  # 初始化最大跳跃次数为0
    min_jumps = n
    while queue:
        curr, jumps = queue.popleft()
        visited[curr] = True
        for neigh in adj[curr]:
            if not visited[neigh]:
                visited[neigh] = True
                queue.append((neigh, jumps+1))
            
            if neigh == n - 1:
                min_jumps = min(min_jumps, jumps + 1)
    return min_jumps
```

>注意官方给出的代码中各种实现的结果有些不同


#### 可移除k个墙壁的最短路径

[Shortest path by removing K walls - GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-by-removing-k-walls/)

创建一个三维数组，保存已经访问过的节点和该节点时还能移除的墙壁数 k，一个queue保存当前的坐标和还能移除的墙壁数，

在循环中，从queue中弹出最前面的元素，探索当前点四个方向

如果当前点为0且未访问，探索所有的方向，将这些方向的点放入queue中，标记当前点已经访问

如果当前点为1且未访问，如果还能移除墙壁，可以移除这个墙壁并探索所有的方向，将所有的未探索的点放入queue中

```python
m = len(mat)
n = len(mat[0])

if m == 1 and n == 1 and (mat[0][0] == 0 or k >= 1):
	return 0

visited = [[[False for _ in range(k+1)] for _ in range(n)] for _ in range(m)]

steps = 0

queue = deque()

queue.append((0, 0, k))

dir1 = [1, -1, 0, 0]
dir2 = [0, 0, 1, -1]

while queue:
	steps += 1
	size = len(queue)
	while size:  # 探索完当前已经有的点
		ox, oy, ok = queue.popleft()
		visited[ox][oy][ok] = True
		for i in range(4):  # 探索四个方向上的点
			nx = ox + dir1[i]
			ny = oy + dir2[i]

			if nx >= 0 and nx < m and ny >= 0 and ny < n:
				if mat[nx][ny] == 0 and not visited[nx][ny][ok]:
					if nx == m - 1 and ny == n - 1:
						return steps
					queue.append([nx, ny, ok])
					visited[nx][ny][ok] = True
				
				elif mat[nx][ny] == 1 and ok > 0 and not visited[nx][ny][ok-1]:
					if nx == m - 1 and ny == n - 1:
						return steps
					queue.append([nx, ny, ok-1])
					visited[nx][ny][ok-1] = True
		size -= 1
return -1
```

### DFS

[Depth First Search or DFS for a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)

DFS的过程有点像递归

```python
def dfs_rec(adj, visited, s):
    visited[s] = True
    print(s, end=" ")
    for i in adj[s]:
        if not visited[i]:
            dfs_rec(adj, visited, i)   # 对每个邻接节点进行dfs
# s 为开始的点
def dfs(adj, s):
    visited = [False] * len(adj)
    dfs_rec(adj, visited, s)
```


#### dfs 判断两个点之间是否存在路径

[Find if there is a path between two vertices in a directed graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/)

```python
def dfs(start: int, end: int, visited: List[bool], V: int) -> bool:
    if start == end:
        return True
    visited[start] = True
    for x in adj[start]:
        if not visited[x]:
            if dfs(x, end, visited, V):
                return True
    return False
```


### 课程表

[207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/description/)

在完成一些课程之前需要前置课程，给定课程和前置课程，求是否能学完所有的课程

可以使用DFS来解决该问题，不过需要注意的是，为了防止出现环，需要加入一个栈递归判断，如果出现了环，证明不可能学完所有的课程

```python
def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:
	visited = [False for _ in range(numCourses)]
	rec_stack = [False for _ in range(numCourses)]

	adj = [[] for _ in range(numCourses)]

	for pre in prerequisites:
		adj[pre[1]].append(pre[0])  # 先学习pre[1]，再学习pre[0]
	
	def dfs(i):
		# 如果i已经在栈中，证明存在环，不可能学完所有的课程
		if rec_stack[i]:
			return True
		visited[i] = True
		rec_stack[i] = True
		for j in adj[i]:
			# 如果 j 未访问，但是存在环
			if not visited[j] and dfs(j):
				return True
			elif rec_stack[j]: # 如果i已经在栈中，证明存在环，不可能学完所有的课程
				return True
		rec_stack[i] = False
		return False

	for i in range(numCourses):
		if not visited[i] and dfs(i):
			return False
	return True
```


另一种方法是使用BFS，最开始能学的课程一定是没有前置课程的，即入度为0，将入度为0的节点全部放入队列中，取出一个节点时，删除该节点相关的所有出度，如果有节点的入度变为0，再将其加入队列，如果最后所有课程都能学习，即加入过队列的节点数量等于整个图的节点数量

```python
def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:
	in_degrees = [0 for _ in range(numCourses)]
	adj = [[] for _ in range(numCourses)]
	for pre in prerequisites:
		in_degrees[pre[0]] += 1
		adj[pre[1]].append(pre[0])
	
	queue = deque()
	# 入度为0的节点入队列
	for i in range(numCourses):
		if in_degrees[i] == 0:
			queue.append(i)
	visited = 0
	while queue:
		node = queue.popleft()
		visited += 1
		for j in adj[node]:
			in_degrees[j] -= 1
			if in_degrees[j] == 0:  # 如果入度变为0，加入队列
				queue.append(j)
	return visited == numCourses
```


### 找到二叉树中所有在给定层级之间的节点

[Print all nodes between two given levels in Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/print-all-nodes-between-two-given-levels-in-binary-tree/)

使用BFS进行搜索，为了避免在queue中保存level这样的信息，可以采用内外循环的方法，BFS每遍历一遍都是将同一级的节点遍历一次，这样可以先保存节点数，每pop一次减1，这样当节点数为0时，这个层级上的节点全部被遍历了。

```python
def solve(root, l1, l2):
    queue = deque()

    queue.append(root)
    level = 1

    while queue:
        size = len(queue)
        while size > 0:
            node = queue.popleft()

            if l1 <= level <= l2:
                print(node.data, end=" ")
            if node.left != None:
                queue.append(node.left)
            if node.right != None:
                queue.append(node.right)
            size -= 1
        if (level >= l1 and level <= l2) :
            print("")
        level += 1
```


### 国王靠近目标的最小步

[Minimum steps to reach target by a Knight | Set 1 - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-steps-reach-target-knight/)

在一个二维平面上，将国王移动到目标的最小步长。因为是求最小步长，所以可以使用BFS，只要搜索到目标就是最小步长。


### 孤岛的数量

[Number of Islands - GeeksforGeeks](https://www.geeksforgeeks.org/find-the-number-of-islands-using-dfs/)

在一个二值矩阵中，1代表有孤岛，且所有相邻的1代表一个孤岛。

可以使用DFS来解决，首先遍历矩阵，当遇到1时，使用DFS来标记周围所有的1，使用一个visited矩阵来标记已经访问过的，防止重复统计孤岛

```python
def solve(grid):

    def isSafe(x, y):
        return (0 <= x < m) and (0 <= y < n)

    def _solve(grid, x, y):
        if grid[x][y] == "0":
            return
        
        visited[x][y] = True

        # 在 8 个方向上搜索，将能找到的 1 全部标记为已经访问
        for i in range(8):
            nx = x + dir1[i]
            ny = y + dir2[i]

            if isSafe(nx, ny) and not visited[nx][ny]:
                _solve(grid, nx, ny)
            

    dir1 = [-1, -1, -1, 0, 0, 1, 1, 1]
    dir2 = [-1, 0, 1, -1, 1, -1, 0, 1]
    m = len(grid)
    n = len(grid[0])

    visited = [[False for _ in range(n)] for _ in range(m)]
    cnt = 0
    for i in range(m):
        for j in range(n):

            if grid[i][j] == '1' and not visited[i][j]:
                _solve(grid, i, j)
                cnt += 1
    return cnt
```

也可以使用BFS，只需要修改 `_solve` 函数即可

```python
# BFS 的搜索过程
def _solve(grid, x, y):
	queue = deque()
	queue.append((x, y))
	
	while queue:
		x, y = queue.popleft()
		visited[x][y] = True
		for i in range(8):
			nx = x + dir1[i]
			ny = y + dir2[i]

			if isSafe(nx, ny) and grid[nx][ny] == '1' and not visited[nx][ny]:
				visited[nx][ny] = True
				queue.append((nx, ny))
```

这种问题的变体还有 [Flood Fill Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/flood-fill-algorithm/)（每次只搜索前后左右四个方向）


### 生成二进制数1-n的快速方法

[An Interesting Method to Generate Binary Numbers from 1 to n - GeeksforGeeks](https://www.geeksforgeeks.org/interesting-method-generate-binary-numbers-1-n/)

```python
from collections import deque

n  = 10

queue = deque()

queue.append("1")
while n > 0:
    n -= 1
    s1 = queue.popleft()
    print(s1)
    queue.append(s1 + "0")
    queue.append(s1 + "1")
```


### 从起点到终点至多k个中间点的最大cost路径

[Maximum cost path from source node to destination node via at most K intermediate nodes - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-cost-path-from-source-node-to-destination-node-via-at-most-k-intermediate-nodes/)

通过层次遍历保证至多k个中间点

```python
from collections import deque

def findShortestPath(n, edges, src, dst, K):

    adjlist = [[] for i in range(n)]

    q = deque()

    mp = {}  # 记录到达每个顶点的最大cost
	
    ans = -10**9 # 最终结果
    
	# edge：起点，终点，cost
    for i in range(len(edges)):
        edge = edges[i]
        adjlist[edge[0]].append([edge[1], edge[2]])

    # 将第一个元素塞入队列中
    q.append([src, 0])

    level = 0

    # 层次遍历，如果队列为空，或者源到终点的中间节点数达到 K
    while (len(q) > 0 and level < K + 2):

        sz = len(q)

        for i in range(sz):
            
            # 弹出最前面的元素
            pr = q.popleft()
	        
            # 到达终点
            if (pr[0] == dst):
                ans = max(ans, pr[1])

            # 遍历邻接节点
            for pr2 in adjlist[pr[0]]:
                # 如果当前点未遍历，或者当前cost大于历史cost
                if ((pr2[0] not in mp) or mp[pr2[0]] < pr[1] + pr2[1]):
                    
                    # 塞入队列
                    q.append([pr2[0], pr[1] + pr2[1]])
                    mp[pr2[0]] = pr[1] + pr2[1]
        level += 1

    return ans if ans != -10**9 else -1

if __name__ == '__main__':
    
    n, src, dst, k = 3, 0, 2, 1

    edges= [ [ 0, 1, 100 ],
             [ 1, 2, 100 ],
             [ 0, 2, 500 ] ]

    print(findShortestPath(n, edges,src, dst, k))
```


### 计算起点到终点的所有路径长度为k的可行路径

[Count all possible walks from a source to a destination with exactly k edges - GeeksforGeeks](https://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/)

使用memo优化递归过程

```python
def MinimumWalk(graph, u, v, k):
	def _solve(graph, _u, _v, _k, memo):
		if _u == _v and _k == 0:   # _k 减为0，找到了一条路径
			return 1
		if _k <= 0:
			return 0
		if memo[_u][_k] != -1:
			return memo[_u][_k]
		cnt = 0

		for i in range(len(graph)):
			if graph[_u][i] == 1:
				cnt += _solve(graph, i, _v, _k-1, memo)
				cnt = cnt % (10**9 + 7)
		memo[_u][_k] = cnt 
		return cnt
	
	V = len(graph)
	memo = [[-1 for _ in range(k+1)] for _ in range(V)]
	res = _solve(graph, u, v, k, memo)

	return res
```


动态规划的方法（耗时更长）

```python
def solve_dp(graph, u, v, k):
    n = len(graph)
    dp = [[[0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]
    for e in range(0, k+1):
        for i in range(n):
            for j in range(n):
                if e == 0 and i == j:
                    dp[i][j][e] = 1
                if e == 1 and graph[i][j] == 1:
                    dp[i][j][e] = 1
                
                # 只考虑 e > 1 时的情况
                if e > 1:
                    for a in range(n):
                        if graph[i][a] == 1:
                            dp[i][j][e] += dp[a][j][e-1]
                            dp[i][j][e] %= (10 ** 9 + 7)

    return dp[u][v][k]
```



### 有向加权图的最小代价路径

[Minimum Cost of Simple Path between two nodes in a Directed and Weighted Graph - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-cost-of-simple-path-between-two-nodes-in-a-directed-and-weighted-graph/)

加权图不适合使用BFS搜索路径，使用DFS，同时这里注意要在搜索完之后，将探索完邻接节点的点给设置为未访问，使得可以搜索到其他路径。

```python
V = 5
INF = sys.maxsize

def solve(s, t, visited, graph):
    if s == t:
        return 0

    res = 1000
    visited[s] = 1
    for i in range(V):
        if graph[s][i] != INF and not visited[i]:
            cost = graph[s][i] + solve(i, t, visited, graph)
            res = min(cost, res)
    
    # 允许探索其它路径
    visited[s] = 0
    return res
```


### 有向加权图的最小代价路径（指定需要经过的节点）

[Minimum Cost Path in a directed graph via given set of intermediate nodes - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-cost-path-in-a-directed-graph-via-given-set-of-intermediate-nodes/)

使用DFS，当找到一条路径时，如果指定节点被经过（被访问），就更新最小代价。


### 天然气站问题

[Gas Station - GeeksforGeeks](https://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/)

有一个环形公路，公路上有n个天然气站，每个天然气站的天然气储量为 `gas[i]`，有一辆车从某个天然气站出发，初始天然气容量为0，从第 i 个天然气站出发到下一个天然气站所耗费的天然气为 `cost[i]`，求从哪个站出发能到达所有的天然气站，并最终返回。

最简单的方法是以每个天然气站作为起点进行尝试

另一种算法是使用贪心算法，先从第一个站点出发，记录假设从一个站点到下一个站点时的天气储量，如果储量不够，就考虑从下一站出发（之前的站点无需考虑，因为从第一个站点到这些站点时的储量一定是大于0的，如果在这种情况下都到不了下一个站，那么从这个站出发肯定也不行）。

```python
def solve(gas, cost):

    curr_gas = 0
    all_gas = 0
    start_idx = 0
    for i in range(len(gas)):
        curr_gas += gas[i] - cost[i]
        all_gas += gas[i] - cost[i]

        # 如果从第i个天然气站出发到不了之后的站，就从i+1出发
        if curr_gas < 0:
            start_idx = i + 1
            curr_gas = 0
    # 如果总的天然气不够的话，自然不存在可行的站点
    if all_gas < 0:
        return -1
    return start_idx
```


## 链表

### 常见操作

#### 统计链表长度

[Find Length of a Linked List (Iterative and Recursive) - GeeksforGeeks](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive/)

```python
def getCount(self, head):
	# code here
	
	count = 0
	curr = head
	while curr is not None:
		count += 1
		curr = curr.next
	return count
```


#### 链表插入

```python
# 插入最开始
def insert_at_front(head, data):
    new_node = Node(data)
    new_node.next = head
    return new_node

# 在key之后插入
def insert_after(head, data, key):
    new_data = Node(data)
    curr = head
    while curr is not None:
        if curr.data == key:
            break
        curr = curr.next
    # 找不到目标
    if curr is None:
        return head
    new_data.next = curr.next
    curr.next = new_data
    return head

# 在key之前插入
def insert_befor(head, data, key):
    new_data = Node(data)
    curr = head
    while curr.next is not None:
        if curr.next.data == key:
            break
        curr = curr.next
    # 找不到目标
    if curr.next is None:
        return head
    
    new_data.next = curr.next
    curr.next = new_data
    return head

# 在末尾插入
def insert_end(head, data):
    new_data = Node(data)
    curr = head
    while curr.next != None:
        curr = curr.next
    
    curr.next = new_data
    return head
```

#### 删除节点

删除指定值

```python
def delete_node(head, key):
    if head is None:
        return 
    
    if head.data == key:
        curr = head.next
        del head
        return curr
    curr = head
    prev = curr
    while curr is not None:
        if curr.data == key:
            break
        prev = curr
        curr = curr.next
    
    cnext = curr.next
    prev.next = cnext
    return head
```

> python 中删除链表可以直接将head置为None，而在C++中则需要将每个元素都删除



### 找到链表的中点

[Find Middle of the Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/)

用快慢指针，快指针每次走两步，慢指针每次走一步，快指针走到末尾时，慢指针指向中点

快慢指针还能用来检测链表中的环，如果快慢指针相等代表存在环 [Check if a linked list is Circular Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-linked-list-is-circular-linked-list/)


### 双向链表的删除

[Deletion in a Doubly Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list/)


删除当前点

```python
def del_node(head, key):
    
    curr = head

    while curr is not None:
        if curr.data == key:
            break
        curr = curr.next
    
    if curr is None:
        return head
    
    prev = curr.prev
    next = curr.next
    if prev is not None:
        prev.next = next
    if next is not None:
        next.prev = prev
    
    if head == curr:
        head = curr.next
    
    curr.prev = None
    curr.next = None
    return head
```



### 翻转链表

[Reverse a Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/reverse-a-linked-list/)

翻转单向链表，用三个指针指向prev、curr和next，最后返回prev

```python
def reverse_single(head):
    if head is None:
        return head
    prev = None
    curr = head
    next = None

    while curr is not None:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    
    return prev
```


翻转双向链表，用两个指针指向prev 和 next，返回prev.prev

```python
def reverse_r(head):
    if head is None or head.next is None:
        return head
    
    prev = None
    curr = head
    while curr is not None:
        prev = curr.prev
        # 开始翻转
        curr.prev = curr.next
        curr.next = prev
        curr = curr.prev
    return prev.prev
```

### 翻转一定范围内的链表

[92. 反转链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

假设范围为1-based索引，设置一个dummy处理需要翻转头节点的情况

```python
def solve(head: ListNode, left, right):
    dummy = ListNode(-1)
    dummy.next = head
    node = dummy

    for i in range(left-1):
        node = node.next
    i = left-1
    prev, curr, next = None, node.next, None
    while i <= right-1:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
        i += 1
    node.next = prev
    # 如果后面（next）还有节点，先遍历到当前的最后一个节点，
    if next is not None:
        while node.next is not None:
            node = node.next
        node.next = next
    return dummy.next
```


### k 翻转链表

[25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

每k个元素翻转一次链表

```python
def reverseKGroup(head, k):
	dummy = ListNode(-1)
	dummy.next = head
	count = 0
	curr, prev, next = head, dummy, None
	while head is not None:
		count += 1
		head = head.next
	
	while count >= k:
		for i in range(k-1):
			next = curr.next   # 保存下一个值
			curr.next = next.next # 将curr的next指向再下一个
			next.next = prev.next # 反转
			prev.next = next      # 
		
		prev = curr
		curr = curr.next
		count -= k
	return dummy.next
```


### 环形链表

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

[Find length of loop/cycle in given Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/find-length-of-loop-in-linked-list/)

判断环是否存在，使用快慢指针，快指针一次移动两次，慢指针一次移动一次，如果快慢指针相遇，则存在环

判断环的起点：先用快慢指针判断是否存在环，假设环的起点为 x，环的大小为r，快慢指针相遇在 y 处，则快指针走了 `x+k*r+y`，慢指针走了 `x+y` 步，由于快指针每次移动两次，则有`k*r + x + y = 2 (x + y)`，则有慢指针实际走了 `k * r` 步。慢指针每次走到起点时的步数为 `k*r + x` ，已经走了 `k*r` 步了，只需要再走 `x` 步即可，因此只需要用一个指针指向头节点，两个指针每次走一步，相遇的地方即为环的起点。

```python
def solve(head):
    slow, fast = head, head
    has_circular = False
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next
        if slow == fast:
            has_circular = True
            break
    if not has_circular:
        return None
    
    fast = head
    while slow != fast:
        slow = slow.next
        fast = fast.next

    return slow
```

判断环的节点数：如果快慢指针相遇了，只移动慢指针，并且计算慢指针的移动次数，快慢指针再次相遇时，慢指针移动次数即为环的节点数

```python
def countNodesInLoop(head):
	slow = head
	fast = head
	cnt = 0
	flag = False
	while slow is not None and fast is not None and fast.next is not None:
		slow = slow.next
		if not flag:
			fast = fast.next.next
		if flag:
			cnt += 1
		if slow == fast:
			if not flag:
				flag = True
			else:
				return cnt
	return cnt
```


### 相交链表

[160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)

给定两个单链表的头节点 `headA` 和 `headB` ，找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

一种方法是先统计两个链表的长度，然后先遍历较长的链表，直到两个指针距离尾部的长度相等，然后一起遍历即可。

第二种方法不直接统计两个链表的长度，而是隐含的让两个指针都经过两个链表，具体方法如下

1、让两个指针指向链表的头节点
2、两个指针向后遍历，如果元素相等就返回找到的交点
3、在遍历时，大概率有一个指针会先遍历到尾部，到尾部的指针指向另一个链表的头节点，这样当两个指针都重新指向另一个链表的时候，两个指针距离尾部的距离相等
4、如果能找到就返回节点，找不到则两个指针会同时指向None，循环结束


### 重排链表

[143. 重排链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reorder-list/)

将链表 L0 → L1 → … → Ln - 1 → Ln  重排为 L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

这里分为三步：首先是找到链表的中点（快慢指针），然后翻转另一半的链表，最后将翻转后的链表和原本的链表合并

```python
def reorderList(self, head) -> None:
	slow, fast = head, head
	# 需要判断 fast.next.next，否则当只有两个元素的时候会出现问题
	while fast.next is not None and fast.next.next is not None:
		slow = slow.next
		fast = fast.next.next
	
	def reverse(node):
		prev, curr, next = None, node, None
		while curr is not None:
			next = curr.next
			curr.next = prev
			prev = curr
			curr = next
		
		return prev
	
	# slow 为中点
	last: ListNode = reverse(slow.next)
	slow.next = None  # 注意将其后序置为None

	node = head
	while last is not None:
		node_next = node.next  # 保存node和last的下一个节点
		last_next = last.next
		last.next = node_next
		node.next = last
		node = node_next
		last = last_next
```

还有另一种方法，先把所有的节点拿出来放在列表中，然后再排列

```python
def solve(node):
    arr = []
    while node is not None:
        arr.append(node)
        node = node.next
    
    i = 0
    j = len(arr) - 1

    while i < j:
        arr[i].next = arr[j]
        i += 1
        if i == j:
            break
        arr[j].next = arr[i]
        j -= 1
    arr[i].next = None  # 处理中间的节点
```


### 判断链表是否回文

[234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/description/)

先使用快慢指针找到链表中点，然后逆转中点之后的链表，和前面的做对比

```python
def solve(head):

    slow, fast = head, head.next  # fast 先走一步，处理元素为2时的情况
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    def reverse_list(head):
        prev, curr, next = None, head, None
        while curr is not None:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev
    
    mid = reverse_list(slow.next)
    slow.next = None

    p1, p2 = head, mid
    while p1 and p2:
        if p1.val != p2.val:
            return False
        p1 = p1.next
        p2 = p2.next
    return True
```

### 链表的归并排序

[148. 排序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-list/description/)

```python
def sort(node):
    def merge(l1: Node, l2: Node):
        head = Node(-1)   # 一个虚拟节点可以避免许多判断
        node = head
        while l1 is not None and l2 is not None:
            if l1.val < l2.val:
                node.next = l1
                l1 = l1.next
            else:
                node.next = l2
                l2 = l2.next
            node = node.next
        
        if l1 is not None:
            node.next = l1
        if l2 is not None:
            node.next = l2
        return head.next

    def _solve(head):
        if head.next is None:
            return head

        slow, fast = head, head
        # 这里需要判断 fast.next.next，否则两个节点分不开，或者fast先走一步
        while fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next
        high = slow.next
        slow.next = None
        n1 = _solve(head)
        n2 = _solve(high)
        n = merge(n1, n2)
        return n

    head = _solve(node)
    return head
```


### 链表的快速排序

[QuickSort on Singly Linked List - GeeksforGeeks](https://www.geeksforgeeks.org/quicksort-on-singly-linked-list/)

```python
# 获取链表尾
def getTail(curr: ListNode):
    while curr and curr.next:
        curr = curr.next
    return curr

def partition(head: ListNode, tail: ListNode):
    pivot = head

    pre = head
    curr = head

    while curr != tail.next:
        if curr.val < pivot.val: # 如果当前值比pivot小，交换
            curr.val, pre.next.val = pre.next.val, curr.val
            pre = pre.next
        curr = curr.next
    
    pivot.val, pre.val = pre.val, pivot.val
    return pre

def quickSort(head):
    
    def _quickSort(head, tail):
        if head is None or head == tail:
            return
        pivot = partition(head, tail)
        _quickSort(head, pivot)
        _quickSort(pivot.next, tail)

    tail = getTail(head)
    _quickSort(head, tail)
    return head
```


### 删除链表倒数第N个节点

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

考虑使用双指针，使用一个虚拟节点作为前置，用来处理需要删除头节点的情况

先用一个指针移动 N 次，之后另一个指针指向头节点，两个指针同时移动，直到先走的指针到达尾部，此时两个指针都走了 K-N 步，后走的指针距离尾部正好 N 个节点

```python
def removeNthFromEnd(head, n):
	dummy = ListNode(-1)
	dummy.next = head
	slow, fast = dummy, dummy
	for i in range(n+1):
		fast = fast.next
	
	while fast is not None:
		fast = fast.next
		slow = slow.next
	
	slow.next = slow.next.next
	return dummy.next
```


### 旋转链表

[61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/description/)

先找到尾节点，并且计算链表长度 n，将尾节点和头节点相连，从头节点向后移动 n- k次，最终断开得到旋转 k 次后的节点

```python
def solve(head, k):
    if head is None and k == 0:
        return head
    tail = head
    count = 1
    while tail.next is not None:
        count += 1
        tail = tail.next
    
    k = k % count
    if k == 0:
        return head
    
    tail.next = head
    p = head
    prev = None
    for i in range(count - k):  # 向后访问count-k
        prev = p
        p = p.next
    prev.next = None   # 断开节点
    return p
```

### 两两交换节点

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)


是 k 翻转 k = 2 时的简化版本

```python
def solve(head):
    prev = dummy = ListNode(-1)
    dummy.next = head

    curr, next = head, None

    while curr:
        next = curr.next
        if next is None:   # 处理奇数个节点的最后一个节点
            break
        prev.next = next   # prev.next 指向 next(2)
        curr.next = next.next   # 保存下一个状态
        prev = curr             # prev指向curr (1)
        next.next = curr        # next (2) 指向 (1)
        curr = curr.next        # curr 移动到下一位 (3)
    return dummy.next
```


### 奇偶链表

[328. 奇偶链表 - 力扣（LeetCode）](https://leetcode.cn/problems/odd-even-linked-list/description/)

用两个指针分别指向第一个节点（第一个奇数索引）和第二个节点（第一个偶数索引），然后奇数索引指针获取所有的奇数索引，偶数索引指针获取所有的偶数索引，这里需要额外用一个指针保存最开始的偶数索引，最后奇数索引后面加上最开始的偶数索引

```python
def solve(head):
    if head is None:
        return head
    odd = head
    even = head.next
    evenHead = even
    
    while even and even.next:
        odd.next = odd.next.next
        even.next = even.next.next

        odd = odd.next
        even = even.next
    
    odd.next = evenHead
    return head
```


### 带随机指针的链表

[138. 随机链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/copy-list-with-random-pointer/description/)

用一个字典保存所有的节点，再在该字典设置下一个和随机指针

```python
def copyRandomList(head):
	if head is None: return head
	nodes = {}
	p = head
	while p is not None:
		node = Node(p.val)
		nodes[p] = node
		p = p.next
	
	node = head
	while node is not None:
		if node.next is not None:
			nodes[node].next = nodes[node.next]
		
		if node.random is not None:
			nodes[node].random = nodes[node.random]
		node = node.next
	return nodes[head]
```


### LRU 缓存

[146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/description/)

需要使用一个字典保存键对应的节点，节点以双向链表的方式给出，因为需要将最近访问的节点放在最开始。注意 `get` 和更新键值都属于访问，都需要将节点放在最开始

```python
class Node:

    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.nc = 0
        self.dummy = Node() 
        self.cache = {}

    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key] # 取出节点
            v = node.value
            self.put_front(node)
            return v
        else:
            return -1
    
    def put_front(self, node):
        next = node.next  # 当前节点的下一个元素
        prev = node.prev  # 当前节点的上一个元素
        next.prev = prev
        prev.next = next
        
        node.next = self.dummy.next
        self.dummy.next.prev = node
        self.dummy.next = node
        node.prev = self.dummy   # 将节点放到最前面

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self.put_front(node)
        else:
            if self.nc >= self.capacity:  # 超出容量删除
                old_node = self.dummy.prev
                prev = old_node.prev
                self.dummy.prev = prev
                prev.next = self.dummy
                del self.cache[old_node.key]
            
            node = Node(key, value)
            next = self.dummy.next
            if next is None:  # 初始情况
                self.dummy.next = node
                node.prev = self.dummy
                self.dummy.prev = node
                node.next = self.dummy
            else:
                node.next = next
                next.prev = node
                self.dummy.next = node
                node.prev = self.dummy
            
            self.cache[key] = node
            self.nc += 1
```


## 树

### 四种遍历

中序遍历 [Inorder Traversal of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/inorder-traversal-of-binary-tree/)

先遍历左子树，然后遍历根节点，然后遍历右子树

```python
def inorder_traversal(root: Node):

    if root is None:
        return
    
    inorder_traversal(root.left)
    print(root.data, end=" ")
    inorder_traversal(root.right)
```

前序遍历 [Preorder Traversal of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/preorder-traversal-of-binary-tree/)

先遍历根节点、再遍历左子树，最后遍历右子树

```python
def preorder_traversal(root: Node):
    if root is None:
        return
    
    print(root.data, end=" ")
    preorder_traversal(root.left)
    preorder_traversal(root.right)
```


后序遍历 [Postorder Traversal of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/postorder-traversal-of-binary-tree/)

先遍历左子树，再遍历右子树，最后遍历根节点

```python
def postorder_traversal(root: Node):
    if root is None:
        return
    postorder_traversal(root.left)
    postorder_traversal(root.right)
    print(root.data, end=" ")
```


层序遍历 [Level Order Traversal (Breadth First Search or BFS) of Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/level-order-tree-traversal/)

一层一层的遍历


```python
def levelOrder(root):
    if root is None:
        return []
    
    q = deque()
    res = []
    
    q.append(root)
    currLevel = 0

    while q:
        len_q = len(q)
        res.append([])

        for _ in range(len_q):
            # 获得当前节点
            node = q.popleft()
            res[currLevel].append(node.data)
            
            if node.left is not None:
                q.append(node.left)
                
            if node.right is not None:
                q.append(node.right)
        currLevel += 1

    return res
```


### 特殊遍历

#### Morris 遍历

[Morris traversal for Inorder - GeeksforGeeks](https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/)

一种空间复杂度为1的遍历，利用树中存在的大量None节点来保存


#### 锯齿形层序遍历

[103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/)

即在层序遍历时第一层pop最左端的元素，第二层先pop最右端的元素，依次类推，事实上只需要改变向结果中添加元素的顺序即可。

```python
def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]:
	if root is None:
		return []
	queue = deque()
	queue.append(root)
	flag = True
	res = []
	while queue:
		sz = len(queue)
		level = []
		for _ in range(sz):
			node = queue.popleft()
			if flag:
				level.append(node.val)
			else:
				level = [node.val] + level
			if node.left:
				queue.append(node.left)
			if node.right:
				queue.append(node.right)
		res.append(level)
		flag = not flag
	return res
```


### 生成 1 到 n 的二叉搜索树

[95. 不同的二叉搜索树 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees-ii/description/)

对于1-n的二叉搜索树，可以在 1 - n 之间任意选择 i 作为根节点，然后 `[1,i-1]` 作为左子树，`[i+1, n]` 作为右子树

```python
def generateTrees(n: int):
	def dfs(start, end):  # start 起点，end 终点
		if start > end:
			return [None,]
		allTrees = []

		for i in range(start, end+1):  # 在 [start, end] 中遍历根节点
			leftTrees = dfs(start, i-1)
			rightTrees = dfs(i+1, end)

			for l in leftTrees:  # 遍历左右子树
				for r in rightTrees:
					currTree = TreeNode(i)
					currTree.left = l
					currTree.right = r
					allTrees.append(currTree)
		return allTrees
	return dfs(1, n)
```


这道题可以用动态规划的方法求解

首先 `dp[i]` 表示 `[1,2,3,...,i]` 这些值构成的二叉搜索树，对于每个 `dp[i]`，需要遍历之前的 `j`，得到 `dp[j-1]` 和 `dp[i-j]`，这里的 `dp[i-j]` 需要加上一个偏差 `j` 以满足要求。如 `[1,100]` 构建二叉搜索树，当遍历到 98 时，需要使用 `[1,97]` 构建左子树，`[99,100]` 构建右子树

```python
def generateTrees(n: int):
	dp = [[] for _ in range(n+1)]
	dp[0] = [None]
	dp[1] = [TreeNode(1)]

	def copy_tree(node, offset):
		if node is None:
			return None
		
		root = TreeNode(node.val + offset)
		root.left = copy_tree(node.left, offset)
		root.right = copy_tree(node.right, offset)
		return root
	
	for i in range(2, n+1):
		for j in range(1, i+1):
			left = j - 1
			right = i - j
			# 遍历左右子树
			for l in dp[j-1]:
				for r in dp[i-j]:
					root = TreeNode(j)
					root.left = l
					root.right = copy_tree(r, j)
					dp[i].append(root)
	return dp[n]
```


### 二叉树中的最大路径和

[124. 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

使用递归解决这个问题，最大路径和为一个节点和其左右子树的最大子树和相加（前提是子树和大于0）

对于一颗子树而言，子树和的最大值为根节点加上左子树的最大和，或者加上右子树的最大和，或者不加，左右子树只能加一个，否则会出现多条路径。递归函数返回的是最大子树和

```python
def solve(root):
    def _solve(root, res):
        if root is None:
            return 0

        l_val = _solve(root.left, res)
        r_val = _solve(root.right, res)
        maxSubtreeSum = max(root.val + max(l_val, r_val, 0), 0)  # 最大子树和
        maxPathSum = root.val + l_val + r_val  # 最大路径和
        res[0] = max(res[0], maxPathSum)
        return maxSubtreeSum
    
    res = [-10000]
    _solve(root, res)
    return res[0]
```



### 二叉树的最大宽度

[662. 二叉树最大宽度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-width-of-binary-tree/description/)

该题也会计算None节点，所以需要考虑节点的位置，左节点 2 * i，右节点 2 * i+1

```python
def solve(root):
    queue = []
    queue.append((root, 0))
    max_size = len(queue)

    while queue:
        sz = len(queue)
        # max_size = max(max_size, sz)
        lidx = queue[0][1]
        ridx = lidx
        for i in range(sz):
            node, ridx = queue.pop(0)
            if node.left:
                queue.append((node.left, 2 * ridx))
            if node.right:
                queue.append((node.right, 2 * ridx + 1))
        max_size = max(max_size, ridx - lidx+1)
    return max_size
```


### 最近公共祖先

[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

采用递归方法，分别在左子树和右子树中寻找p和q，如果左右子树都能找到，那么该节点就是最近公共祖先，如果在左子树找到p或q，右子树没有找到，返回的结果就是p或q，即p或q自己就是最近公共祖先（递归的性质保证是最近的）

```python
def solve(root, p, q):
    if root is None or root == p or root == q:
        return root
    
    left = solve(root.left, p, q)
    right = solve(root.right, p, q)

    if left and right:
        return root
    
    if left and right is None:
        return left
    
    if left is None and right:
        return right
```




### 对称树

[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/description/)

用DFS，判断左右节点是否相等，如果相等判断左节点的左子树和右节点的右子树是否相等。

```python
def solve(root: TreeNode):
    
    def dfs(left, right):
        if left is None and right is None:
            return True
        if left and right:
            if left.val == right.val:
                return dfs(left.left, right.right) and dfs(left.right, right.left)
        return False
    
    res = dfs(root.left, root.right)
    return res
```


### 平衡树

[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/description/)

使用DFS获取左右子树的高度，需要注意的是dfs返回的是左右子树高度的较大值

```python
def solve(root):
    def dfs(node, res):
        if node is None:
            return 0
        left_height = 1 + dfs(node.left, res)
        right_height = 1 + dfs(node.right, res)
        if abs(left_height - right_height) > 1:
            res[0] = False
        return max(left_height, right_height)
        
    res = [True]
    dfs(root, res)
    return res[0]
```


### 翻转二叉树

[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/description/)

每次交换左右子树即可，注意是直接交换左右子树，而不是左右子树的值

```python
def solve(root):
    def dfs(root):
        if root is None: return
        root.left, root.right = root.right, root.left
        if root.left:
            dfs(root.left)
        if root.right:
            dfs(root.right)
    dfs(root)
```



### 已知中序遍历和后序遍历确定前序遍历

后序遍历的最后一个元素是根节点，这样可以在中序遍历的结果中确定根节点的位置，从而分出左右子树，根据左右子树的长度可以找到后序遍历的左右子树，分别对左右子树确定根节点的位置，重复这一步骤，得到前序遍历的结果。

```python
def solve(postr, inr):

    def _solve(postr, inr, res):
	    # 处理非完全二叉树
        if len(postr) == 0 or len(inr) == 0:
            return
        if len(postr) == 1:
            res.append(postr[0])
            return
        root = postr[-1]
        ridx = inr.index(root)   # 为了节约时间，可以先用一个字典保存每个元素的位置
        in_left = inr[:ridx]
        in_right = inr[ridx+1:]
        post_left = postr[:len(in_left)]
        post_right = postr[len(in_left):-1]
        res.append(root)
        _solve(post_left, in_left, res)   # 遍历左子树
        _solve(post_right, in_right, res)  # 遍历右子树
    ans = []
    _solve(postr, inr, ans)
    print(ans)
```

直接构建二叉树见 [105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)


### 二叉树展开为链表

[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)

要求链表还使用树节点实现，left始终为None，按照先序遍历的顺序排列

类似先序遍历的实现，只不过将原本的打印字符改为了链表构建

```python
def flatten(self, root):
	dummy = TreeNode(-1)
	self.prev = dummy

	def flat(root):
		if root is None:
			return
		left = root.left    # 保存左子树
		right = root.right  # 保存右子树
		root.left = None
		self.prev.right = root
		self.prev = root

		flat(left)
		flat(right)
	flat(root)
	return dummy.right
```


### 二叉搜索树和双向链表

[LCR 155. 将二叉搜索树转化为排序的双向链表 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/)

用一个DFS来中序遍历树

```python
def treeToDoublyList(self, root):
	if root is None:
		return None
	self.head = None # 最小的元素
	self.prev = None
	def dfs(root):
		if root is None:
			return
		dfs(root.left)
		if self.prev is None:
			self.head = root
		else:
			self.prev.right = root   # 处理左子树和根节点之间指针
			root.left = self.prev    # 处理右子树和根节点之间指针
		
		self.prev = root
		dfs(root.right)
	
	dfs(root)
	self.head.left = self.prev    # 此处的head是最小的元素
	self.prev.right = self.head   # 此处的prev是最大的元素

	return self.head
```


### 二叉树的插入和删除

[Insertion in a Binary Tree in level order - GeeksforGeeks](https://www.geeksforgeeks.org/insertion-in-a-binary-tree-in-level-order/)

[Deletion in a Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/deletion-binary-tree/)

插入：使用层序遍历，如果一个节点的左节点为NULL，就放在左节点，右节点为NULL，放在右节点。

```python
def InsertNode(root, data):
    if root is None:
        root = Node(data)
        return root
    q = deque()
    q.append(root)

    while q:
        curr = q.popleft()

        if curr.left is not None:
            q.append(curr.left)
        else:
            curr.left = Node(data)
            return root

        if curr.right is not None:
            q.append(curr.right)
        else:
            curr.right = Node(data)
            return root
```

删除：首先找到这个节点，将这个节点的值换成最深的节点的值，然后删除这个最深的节点，下面的代码是删除最深的节点

```python
def delete_deepest(root, dNode):  # dNode 最深的节点，最深的节点没有子树了
    queue = [root]
    while queue:
        curr = queue.pop(0)

        # 如果当前节点就是最深的节点，直接删除
        if curr == dNode:
            curr = None
            del dNode
            return

        # 检查左右子树
        if curr.right:
            if curr.right == dNode:
                curr.right = None
                del dNode
                return
            queue.append(curr.right)
            
        if curr.left:
            if curr.left == dNode:
                curr.left = None
                del dNode
                return
            queue.append(curr.left)
```


### 找到和为给定值的二叉树子树

[Subtree with given sum in a Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/subtree-given-sum-binary-tree/)

采用递归的方法，每次对当前节点计算一次子树之和，如果等于目标值则有解，否则对左右子树分别计算。

注意：这里不需要额外对左右子树进行计算，因为在用递归计算当前子树之和时，递归中已经计算了左右子树之和，如果等于目标就有解了

```python
# res 用数组保存结果
def subtreeSum(root, res, target):
    if root is None:
        return 0
	# 计算子树的和
    currentSum = (root.data +
                  subtreeSum(root.left, res, target) +
                  subtreeSum(root.right, res, target))

    # 子树之和等于目标值，则有解
    if currentSum == target:
        res[0] = True
        
    return currentSum
```


### 路径总和 Ⅲ

[437. 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/description/)

给定一个二叉树和目标值，求出有多少条父节点到子节点的路径（路径要求连续），该路径的节点值总和为目标值

一种最简单的方法是从每个节点开始遍历，判断以该节点作为父节点时到子路径中是否存在符合条件的路径

```python
def pathSum(root: Optional[TreeNode], targetSum: int) -> int:
	from collections import deque
	self.ans = 0
	def dfs(root, gt):
		if root is None:
			return
		if gt == root.val:
			self.ans += 1
		dfs(root.left, gt - root.val)
		dfs(root.right, gt - root.val)
	if root is None:
		return 0
	
	queue = deque()
	queue.append(root)
	while queue:
		node = queue.popleft()
		dfs(node, targetSum)
		if node.left:
			queue.append(node.left)
		if node.right:
			queue.append(node.right)
	
	return self.ans
```

为了避免重复计算，可以使用额外的前缀和字典来保存已经计算好的前缀和，某个节点的前缀和为从根节点到该节点路径的总和

```python
def pathSum(root: Optional[TreeNode], targetSum: int) -> int:
	from collections import defaultdict
	prefix = defaultdict(int)
	prefix[0] = 1   # 如果差值为0，那么有一条路径
	def dfs(root, curr):
		if root is None:
			return 0
		
		curr += root.val
		# 注意是当前前缀和减去 targetSum
		ret = prefix[curr - targetSum]  # 如果存在差值

		prefix[curr] += 1   # 保存根节点到当前节点的前缀和
		ret += dfs(root.left, curr)
		ret += dfs(root.right, curr)
		prefix[curr] -= 1   # 避免重复计算
		return ret
	
	ret = dfs(root, 0)
	return ret
```



### 验证二叉搜索树

[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/)

有两种解法，第一种解法使用递归，对于二叉树而言，其根节点的值大于左子树中的最大值，小于右子树中的最小值。但是我们不可能每次都计算一下左子树的最大值和右子树的最小值，一种方法是传入两个节点表示目前根节点的所能处于的范围，如对于左子树而言，其根节点的值要小于父节点的值，而右子树的根节点则要大于父节点的值

```python
def solve(root):
    def dfs(root, maxNode, minNode):
        if root is None:
            return True
        if maxNode is not None and maxNode.val <= root.val:
            return False
        if minNode is not None and minNode.val >= root.val:
            return False
        # 对于左子树而言，上限为父节点，右子树的下限为父节点
        return dfs(root.left, root, minNode) and dfs(root.right, maxNode, root)
    
    res = dfs(root, None, None)
    return res
```


另一种解决该问题的方法是先中序遍历树，对于二叉搜索树而言，中序遍历的结果是递增的，如果中序遍历的结果非递增，则证明不是二叉搜索树。

>如果需要找到二叉搜索树中第 k 大的数，有这样的解法，使用中序遍历的倒序获得从大到小的排列，在遍历如果发现已经找到第k大的数时停止后续的迭代


```python
def findTargetNode(self, root: Optional[TreeNode], cnt: int) -> int:
	def inorder(root):
		if root is None:
			return
		inorder(root.right)   # 先访问右子树
		if self.cnt == 0: return   # 避免后续的遍历
		self.cnt -= 1
		if self.cnt == 0: self.res = root.val
		inorder(root.left)
	self.cnt = cnt
	self.res = 0
	inorder(root)
	return self.res
```


### 二叉搜索树的删除

[450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/)

注意需要传入父节点，以及子节点在父节点的左子树还是右子树，否则无法更新

删除时分两种情况（也可以分为三种），如果没有右子树，父节点的后续节点为左子树

如果存在右子树，需要将左子树连接到右子树的最小值的左子树

```python
def deleteNode(root, key):

    def delete(parent, root, key, left):
        if root is None:
            return
        
        if root.val > key:
            delete(root, root.left, key, 1)
        elif root.val < key:
            delete(root, root.right, key, 0)
        else:
            if root.right is None:
                if left:
                    parent.left = root.left
                else:
                    parent.right = root.left
                del root
            else:
                rl = root.right
                while rl.left is not None:
                    rl = rl.left
                
                rl.left = root.left
                if left:
                    parent.left = root.right
                else:
                    parent.right = root.right
                del root
    dummy = TreeNode(-10000000)  # 处理删除根节点时的情况
    dummy.left = root
    delete(dummy, root, key, 1)
    return dummy.left
```


### 判断完全二叉树

[Check whether a given Binary Tree is Complete or not (Iterative Solution) - GeeksforGeeks](https://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-complete-tree-or-not/)

[958. 二叉树的完全性检验 - 力扣（LeetCode）](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/)

完全二叉树指除了最后一层，其它层全部填满，并且最后一层优先填充左子树。即如果左子树有，那么右子树也必定有。

这里可以用两个变量保存前一个节点和当前节点，如果当前节点不为None，但是前一个节点为None，证明要么有左子树，但是没有右子树，要么没有右子树，但是有左子树

```python
def isCompleteTree(root) -> bool:
	queue = deque()
	queue.append(root)
	prev = root
	curr = None
	while len(queue) > 0:
		curr = queue.popleft()
		if curr is not None and prev is None:
			return False
		if curr is not None:
			queue.append(curr.left)
			queue.append(curr.right)
		prev = curr
	return True
```


### 计算前序二叉树的深度

[Calculate depth of a full Binary tree from Preorder - GeeksforGeeks](https://www.geeksforgeeks.org/calculate-depth-full-binary-tree-preorder/)

假设存在一个字符串，字符串中 n 表示中间节点，l 表示叶节点，求前序遍历的高度


```python
def solve(s):

    def _solve(s, n, index):

        if index[0] > n or s[index[0]] == 'l':
            return 0
        
        # 左子树
        index[0] += 1
        left = _solve(s, n, index)

        # 右子树
        index[0] += 1
        right = _solve(s, n, index)

        return max(left, right) + 1

    n = len(s)
    index = [0]
    depth = _solve(s, n, index)
    return depth
```


### AVL 树

AVL 是自平衡的二叉搜索树，即任何节点的两个子树的高度差的绝对值不超过1。AVL 树的搜索、插入、删除、最大、最小等操作的时间复杂度为 `O(Log(n))`。

给定高度的AVL树最小节点满足条件 `h(n)=h(n-1)+h(n-2)`

给定高度的AVL树的不同形状的可能性为 `N(h)=2*N(h-1)*N(h-2)` [Different shapes of AVL possible at height h - GeeksforGeeks](https://www.geeksforgeeks.org/different-shapes-of-avl-possible-at-height-h/)

#### AVL 树的插入

[Insertion in an AVL Tree - GeeksforGeeks](https://www.geeksforgeeks.org/insertion-in-an-avl-tree/)

插入采用递归方法，每次插入完毕后需要判断是否需要重整子树

1、如果右子树高度过高，且插入值比右子树的值大：只需要左旋一次
2、如果右子树高度过高，且插入值比右子树的值小：先右旋右子树，再左旋根节点
3、如果左子树高度过高，且插入值比左子树的值小：只需要右旋一次
4、如果左子树高度过高，且插入值比左子树的值大：先左旋左子树，再右旋根节点

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1
    
def height(node: Node):
    if not node:
        return 0
    return node.height

def right_rotate(root: Node):
    left = root.left      # 获得根节点的左子树作为新的根节点
    leftright = left.right  # 获得左子树的右节点
    left.right = root       # 左子树的右节点赋为旧的根节点
    root.left = leftright   # 将左子树的右节点放到根节点的左侧
    root.height = 1 + max(height(root.left), height(root.right))
    left.height = 1 + max(height(left.left), height(left.right))
    return left

def left_rotate(root: Node):
    right = root.right
    rightleft = right.left
    right.left = root
    root.right = rightleft
    root.height = 1 + max(height(root.left), height(root.right))
    right.height = 1 + max(height(right.left), height(right.right))
    return right

def right_left_rotate(root: Node):
    root.right = right_rotate(root.right)
    root = left_rotate(root)
    return root

def left_right_rotate(root: Node):
    root.left = left_rotate(root.left)
    root = right_rotate(root)
    return root

def get_balance(node: Node):
    return height(node.left) - height(node.right)

def insert(root: Node, key):
    if not root:
        return Node(key)
    
    if key < root.key:
        root.left = insert(root.left, key)
    elif key > root.key:
        root.right = insert(root.right, key)
    else:
        return root
    
    root.height = 1 + max(height(root.left), height(root.right))

    balance = get_balance(root)

    if balance > 1 and key < root.left.key:
        return right_rotate(root)
    
    if balance > 1 and key > root.left.key:
        return left_right_rotate(root)
    
    if balance < -1 and key > root.right.key:
        return left_rotate(root)
    
    if balance < -1 and key < root.right.key:
        return right_left_rotate(root)

    return root

def pre_order(root):
    if root:
        print(root.key, end=" ")
        pre_order(root.left)
        pre_order(root.right)


root = None

# Constructing tree given in the above figure
root = insert(root, 10)
root = insert(root, 20)
root = insert(root, 30)
root = insert(root, 40)
root = insert(root, 50)
root = insert(root, 25)
pre_order(root)
```


> 如果存在重复数据，可以加上count属性，记录每种元素出现的次数，详见[AVL with duplicate keys - GeeksforGeeks](https://www.geeksforgeeks.org/avl-with-duplicate-keys/)


#### AVL 树删除

[Deletion in an AVL Tree - GeeksforGeeks](https://www.geeksforgeeks.org/deletion-in-an-avl-tree/)

要删除某个节点，如果该节点无子节点，则直接将该节点置为None，如果存在一个子节点，那就直接将子节点作为该节点。如果两个子节点都存在，那么再右子树中找到最小的值（在右子树中搜索左节点），然后令该节点的值为最小值，然后在右子树中删除这个最小值。

删除完之后，更新该节点的高度，如果不平衡需要进行旋转。


```python
def min_value_node(node):
    current = node
    while current.left is not None:
        current = current.left

    return current

def delete_node(root, key):
    if root is None:
        return root
    if key < root.key:
        root.left = delete_node(root.left, key)
        
    elif key > root.key:
        root.right = delete_node(root.right, key)
    # 删除根节点
    else:
        # 有一个子节点或者没有子节点
        if root.left is None or root.right is None:
            temp = root.left if root.left else root.right
            
            if temp is None:
                root = None
            else:
                root = temp
        else:
            # 右子树的最小值
            temp = min_value_node(root.right)

            root.key = temp.key
			# 删除最小值对应的节点
            root.right = delete_node(root.right, temp.key)

    if root is None:
        return root

    # 更新节点高度
    root.height = max(height(root.left), 
                      height(root.right)) + 1


    balance = get_balance(root)

    # If this node becomes unbalanced, then 
    # there are 4 cases

    # Left Left Case
    if balance > 1 and get_balance(root.left) >= 0:
        return right_rotate(root)

    # Left Right Case
    if balance > 1 and get_balance(root.left) < 0:
        root.left = left_rotate(root.left)
        return right_rotate(root)

    # Right Right Case
    if balance < -1 and get_balance(root.right) <= 0:
        return left_rotate(root)

    # Right Left Case
    if balance < -1 and get_balance(root.right) > 0:
        root.right = right_rotate(root.right)
        return left_rotate(root)

    return root
```


#### 统计AVL树比某个值大的元素的数量

[Count greater nodes in AVL tree - GeeksforGeeks](https://www.geeksforgeeks.org/count-greater-nodes-in-avl-tree/)

在生成AVL树时，加上一个属性来记录比该节点大的元素的数量


#### 有序列表转为AVL

[Sorted Array to Balanced BST - GeeksforGeeks](https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/)

对于一个有序列表，中点为根节点，中点两侧为左右子树，采用递归的方法，不断划分中点即可

```python
def sortedArrayToBSTRecur(arr, start, end):
    if start > end:
        return None

    # Find the middle element
    mid = start + (end - start) // 2

    # Create root node
    root = Node(arr[mid])

    # Create left subtree
    root.left = sortedArrayToBSTRecur(arr, start, mid - 1)

    # Create right subtree
    root.right = sortedArrayToBSTRecur(arr, mid + 1, end)

    return root
sortedArrayToBSTRecur(arr, 0, len(arr) - 1)
```

### 红黑树

[Introduction to Red-Black Tree - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-red-black-tree/)

相较于AVL树，红黑树允许节点的平衡因子大于1，红黑树具有以下5个性质

1、所有节点都是红色或者黑色

2、根节点是黑色

3、红色节点不能有红色子节点

4、从一个节点到所有的后续None节点的路径包含相同数量的黑色节点

5、所有的叶节点（None节点）为黑色

红黑树的统计性能好于 AVL树（特别是在插入和删除时）

n 个节点构成的红黑树的高度满足 $h\le 2\log_2(n+1)$

#### 红黑树的插入

[Insertion in Red-Black Tree - GeeksforGeeks](https://www.geeksforgeeks.org/insertion-in-red-black-tree/)

为了保持平衡，红黑树中引入了重填色和旋转两种方法。

在插入节点时，首先给节点涂上红色，如果该节点是根节点，将颜色改为黑色。如果不是根节点，检查其父节点的颜色，如果是黑色就不用管，否则检查叔节点，如果叔节点是红色，将父节点和叔节点改为黑色，再将祖父节点改为红色，再对祖父节点进行判断。

如果叔节点是黑色，分为四种情况


#### 红黑树的删除

[Deletion in Red-Black Tree - GeeksforGeeks](https://www.geeksforgeeks.org/deletion-in-red-black-tree/)



### 三元搜索树

[Ternary Search Tree - GeeksforGeeks](https://www.geeksforgeeks.org/ternary-search-tree/)

有三个指针，分别指向比自己小的，和自己一样大的和比自己大的。三元搜索树一般用于字符搜索，与一般的字典树相比，每个节点只需要有三个指针，而字典树需要26个。

除了三个指针，还有一个属性来标记该节点是否为某个字符串的结束点

>三元搜索树中只有和自己一样大的子节点才会存储字母


#### 插入

```python
def insert(root, word):
    if root is None:
        root = Node(word[0])

    if word[0] < root.data:
        root.left = insert(root.left, word)
    elif word[0] > root.data:
        root.right = insert(root.right, word)
    else:
        if len(word) > 1:
            root.eq = insert(root.eq, word[1:])
        else:
            root.isEndOfString = True
    return root

```

#### 遍历

```python
def traverseTST(root):
    buffer = [""] * 50

    def _traverse(root, buffer, depth):
        if root:
            _traverse(root.left, buffer, depth)
            buffer[depth] = root.data
            if root.isEndOfString:
                print("".join(buffer[:depth+1]))
            _traverse(root.eq, buffer, depth+1)
            _traverse(root.right, buffer, depth)
    _traverse(root, buffer, 0)
```


#### 搜索

```python
def searchTST(root, word):
    if word[0] < root.data:
        return searchTST(root.left, word)
    elif word[0] > root.data:
        return searchTST(root.right, word)
    else:
        if len(word) > 1:
            return searchTST(root.eq, word[1:])
        else:
            return root.isEndOfString
```

#### 删除

删除一个字符串

[Ternary Search Tree (Deletion) - GeeksforGeeks](https://www.geeksforgeeks.org/ternary-search-tree-deletion/)

```python
# 判断是否有子节点
def isFreeNode(root):
    return not (root.left or root.eq or root.right)

def delete_node(root, s, level):
    if not root:
        return False
 
    # CASE 4 Key present in TST, having atleast
    # one other key as prefix key.
    if level+1 == len(s):
        # 如果该节点是某个字符串的末尾，重置该节点，并判断是否有子节点
        if root.isleaf:
            root.isleaf = False
            return isFreeNode(root)
 
        # string not present in TST and return 0
        return False

    if s[level] < root.key:
        return delete_node(root.left, s, level)
    if s[level] > root.key:
        return delete_node(root.right, s, level)
 
    # CASE 1 Key may not be there in TST.
    if s[level] == root.key and delete_node(root.eq, s, level+1):
        # 如果查询到了，并且该节点后面没有子节点了，将后面置为 None
        root.eq = None
        return not root.isleaf and isFreeNode(root)
 
    return False
```


### 找到三元搜索树中最长的单词

[Longest word in ternary search tree - GeeksforGeeks](https://www.geeksforgeeks.org/longest-word-ternary-search-tree/)

```python
def maxLengthTST(root):
 
    if (root == None):
            return 0
    return max(maxLengthTST(root.left),
                maxLengthTST(root.eq)+1,
                maxLengthTST(root.right))
```


### B-树

[Introduction of B-Tree - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-of-b-tree-2/)

下面是一个 B 树的例子

![](https://media.geeksforgeeks.org/wp-content/uploads/20200506235136/output253.png)

m 阶的 B 树的所有叶节点有着同样的深度，
每个节点至多有m个子节点和m-1个键
B 树的一个节点（除了根节点）至少有 m / 2 - 1 个键，
所有的非叶节点都有至少 m/2 个子节点，
一个有 n-1个键的非叶节点有 n 个不为NULL的子节点。


#### 插入

[Insert Operation in B-Tree - GeeksforGeeks](https://www.geeksforgeeks.org/insert-operation-in-b-tree/)

在插入时，如果待插入节点为叶节点，则直接插入

如果待插入节点不是叶节点，检查子节点是否已经满了，如果已满，将子节点分成两部分，将子节点的中间值放回父节点（待插入节点）

![](https://media.geeksforgeeks.org/wp-content/uploads/20250114142352865981/example_btree_2.webp)



### B+树

[Introduction of B+ Tree - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-of-b-tree/)


### 二叉搜索树中第 k 小的数字

[230. 二叉搜索树中第 K 小的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/)

在中序搜索时，标记已经搜索过的数字数量，在找到答案后就返回

```python
def kthSmallest(root: Optional[TreeNode], k: int) -> int:
	self.res = 0
	self.k = k
	def inorder(root):
		if root is None:
			return
		
		inorder(root.left)
		if self.k == 0: return
		self.k -= 1
		if self.k == 0: 
			self.res = root.val 
			return
		inorder(root.right)
	
	inorder(root)
	return self.res
```


如果需要多次查找不同的k，可以先计算每个根节点左右子树中节点的数量。在搜索时，如果k大于该节点左子树中节点的数量，则在右子树中搜索；相等则就是该节点；否则在左子树中寻找

```python
class MyBst:
    def __init__(self, root: TreeNode):
        self.root = root

        # 统计以每个结点为根结点的子树的结点数，并存储在哈希表中
        self._node_num = {}
        self._count_node_num(root)

    def kth_smallest(self, k: int):
        """返回二叉搜索树中第k小的元素"""
        node = self.root
        while node:
            left = self._get_node_num(node.left)
            if left < k - 1:
                node = node.right
                k -= left + 1
            elif left == k - 1:
                return node.val
            else:
                node = node.left

    def _count_node_num(self, node) -> int:
        """统计以node为根结点的子树的结点数"""
        if not node:
            return 0
        self._node_num[node] = 1 + self._count_node_num(node.left) + self._count_node_num(node.right)
        return self._node_num[node]

    def _get_node_num(self, node) -> int:
        """获取以node为根结点的子树的结点数"""
        return self._node_num[node] if node is not None else 0
```


### 并查集

[Introduction to Disjoint Set (Union-Find Algorithm) - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-disjoint-set-data-structure-or-union-find-algorithm/)

并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。

并查集主要由一个整型数组 pre和两个函数 find( )、join( ) 构成。数组 pre 记录了每个点的前驱节点是谁，函数 find(x) 用于查找指定节点 x 属于哪个集合，函数 join(x,y) 用于合并两个节点 x 和 y 。

find函数的实现

```python
class DisjointSet:
    def __init__(self, n):
        self.pre = list(range(n))
    
    def find(self, i):
        # 如果 i 和i的上级节点相同，证明i自己就是最上级的节点（代表）
        while self.pre[i] != i:
            i = self.pre[i]
        return i

    # 合并两个不相交的集合
    def join(self, i, j):
        ir = self.find(i)  # 找到 i 的代表
        jr = self.find(j)  # 找到 j 的代表

        self.pre[ir] = jr  # i 的代表也是 j 的代表
```


在查询时，如果遇到节点是一级一级的情况会很浪费时间，这时候需要进行路径压缩，一种简单的方法是，如果节点 i 的代表节点为 k 的话，直接将 k 作为 i 的上级节点

```python
def find2(self, i):
	ip = self.pre[i]
	if self.pre[ip] != ip:
		self.pre[i] = self.find2(ip)   # 将代表节点作为上级节点
		return self.pre[i]
	return ip
```


在合并时，也有优化的算法，为所有的节点添加一个属性，表示该节点在树中的高度，在合并时，根据树的高度来判断谁是谁的上级，树高的作为上级。

```python
class DisjointSet:
    def __init__(self, n):
        self.pre = list(range(n))
        self.rank = [0] * n
    
    def find2(self, i):
        ip = self.pre[i]
        if self.pre[ip] != ip:
            self.pre[i] = self.find2(ip)
            return self.pre[i]
        return ip
    
    def join2(self, i, j):
        ir = self.find(i)
        jr = self.find(j)
        if ir == jr:
            return
        # i 的代表更高，将 i 的代表作为 j 的代表
        if self.rank[ir] > self.rank[jr]:
            self.pre[jr] = ir
        elif self.rank[ir] < self.rank[jr]:
            self.pre[ir] = jr
        else:
            # j 的代表也是 i 的代表，i 的代表高度加1
            self.pre[jr] = ir
            self.rank[ir] += 1
```


### 字典序的第 K 小数字

[440. 字典序的第K小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/description/)


给定整数 `n` 和 `k`，返回  `[1, n]` 中字典序第 `k` 小的数字。

![](https://assets.leetcode-cn.com/solution-static/440/440_1.PNG)

通过字典树的思想，每个节点下面有10个节点：`(10*i, 10 * i+9)`

```python
def findKthNumber(n: int, k: int) -> int:
	# 统计字典树以 cur 为根节点时所有的节点的个数总和
	def steps(cur):
		s, first, last = 0, cur, cur
		while first <= n:
			s += min(last, n) - first + 1
			first *= 10
			last = last * 10 + 9
		return s
	
	curr = 1
	k -= 1  # 已经考虑了 1
	while k:
		s = steps(curr)
		if s <= k:  # 直接跳过该节点的所有子节点
			k -= s
			curr += 1
		else:       # 到下一层考虑
			curr *= 10
			k -= 1
	return curr
```


该题还有排列序列的变种 [60. 排列序列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutation-sequence/description/)

该题是求 1 到 n 这 n 个数字全排列的第 k 个最小值，与求字典序的第k个最小值类似。首先先求固定前面若干位时的排列个数

```python
def getPermutation(n: int, k: int) -> str:
	facts = [1]
	i = 2
	# 计算 1 到 n - 1 个数字的排列可能性
	while i < n:
		facts.append(facts[-1] * i)
		i += 1
	wait_for_choose = [str(i) for i in range(1, n+1)]
	if k == 1:
		return "".join([str(i) for i in range(1, n+1)])
	
	res = []
	k -= 1
	level = n - 2  # 初始为n-1个数字全排列
	curr = 0
	while k:
		s = facts[level]
		if s <= k:
			k -= s
			curr += 1
		else:
			a = wait_for_choose[curr]
			res.append(a)
			wait_for_choose.remove(a)
			curr = 0
			level -= 1
	a = wait_for_choose[curr]
	res.append(a)
	wait_for_choose.remove(a)
	res.extend(wait_for_choose)
	return "".join(res)
```


## 堆

对于第 `i` 个元素，左节点为第 `2i+1` 个元素，右节点为第 `2i+2` 个元素

堆是一个完全树（除了最后一层，其他层都需要是满的），父节点的值需要大于左右节点。


### 霍夫曼编码

[Huffman Coding | Greedy Algo-3 - GeeksforGeeks](https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/)

使用堆来保存频率和其对应的节点，每次弹出两个节点，将左右节点的频率加起来形成新的节点，再放入堆中。


### 序列的最大重排

[Largest Derangement of a Sequence - GeeksforGeeks](https://www.geeksforgeeks.org/largest-derangement-sequence/)

将序列进行重排使其位置完全发生改变，求出最大的序列

```python
def largest_derangement(seq):
    n = len(seq)
    res = [0] * n
    pq = []

    for i in range(n):
        pq.append(seq[i])
    
    for i in range(n):
        pq.sort(reverse=True)   # 倒序排序

        d = pq[0]
        del pq[0]
        if (d != seq[i] or i == n - 1):    # 如果顺序不同，就直接赋值
            res[i] = d
        else:                   # 如果顺序相同，就取下一个最大值
            res[i] = pq[0]
            del pq[0]
            pq.append(d)
    return res
```


### 二叉搜索树转为最小堆

[Convert BST to Min Heap - GeeksforGeeks](https://www.geeksforgeeks.org/convert-bst-min-heap/)

先中序遍历二叉搜索树，然后在前向遍历二叉树时填入对应的值

```python
def inorder_traversal(root, arr):
    if root is None:
        return
    
    inorder_traversal(root.left, arr)
    arr.append(root.data)
    inorder_traversal(root.right, arr)

def preorder_fill(root, arr, idx):
    if root is None:
        return idx
    
    root.data = arr[idx]
    idx += 1
    idx = preorder_fill(root.left,  arr, idx)
    idx = preorder_fill(root.right, arr, idx)
    return idx

def solve(root):
    arr = []
    inorder_traversal(root, arr)
    preorder_fill(root, arr, 0)
```


### 合并两个最大堆

[Merge Two Binary Max Heaps - GeeksforGeeks](https://www.geeksforgeeks.org/merge-two-binary-max-heaps/)


直接两个堆合并在一起，然后转成最大堆。


## 图

### BFS 和 DFS

BFS 使用队列（FIFO）来存储节点，DFS 使用栈（LIFO）来存储节点

BFS 是一种遍历方法，其中我们首先遍历同一级别上的所有节点，然后再转移到下一级别。

DFS 也是一种遍历方法，遍历从根节点开始，尽可能地穿过节点，直到我们到达没有未访问的邻近节点的节点。

BFS 广泛应用于二部图、最短路径等领域。如果每个边的权重相同，则 BFS 给出从源到每个其他顶点的最短路径。

DFS 广泛应用于无圈图和求强连通分量等领域。有很多应用程序可以同时使用 BFS 和 DFS，比如拓扑排序、循环检测等等。


### DFS 检测有向图中的环

[Detect Cycle in a Directed Graph - GeeksforGeeks](https://www.geeksforgeeks.org/detect-cycle-in-a-graph/)

```python
def is_cyclic_util(adj, u, visited, rec_stack):
    
    # 如果在递归栈中已经存在该元素，就证明存在环
    if rec_stack[u]:
        return True

    # 标记当前节点被访问，并且是递归栈的一部分
    visited[u] = True
    rec_stack[u] = True

    # 对所有相邻节点遍历
    for x in adj[u]:
	    # 如果 x 未访问，且 x 构成环了返回True
        if not visited[x] and is_cyclic_util(adj, x, visited, rec_stack):
            return True
        elif rec_stack[x]:
            return True

    # 从栈中删除当前节点
    rec_stack[u] = False
    return False

def is_cyclic(adj):
    V = len(adj)
    visited = [False] * V
    rec_stack = [False] * V
    
    for i in range(V):
        if not visited[i] and is_cyclic_util(adj, i, visited, rec_stack):
            return True

    return False
```


### Dijkstras最短算法

[Find Shortest Paths from Source to all Vertices using Dijkstra’s Algorithm](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)

从一点出发，找到到其它点的最短路径，不适用于带负值的路径

1、初始化路径数组（初始化为正无穷）和访问数组（初始化为False）
2、循环：每次选择一个最短的路径，并设置该点已被访问过，更新路径数组，判断从新选择的点到该点是否会更近一点

```python
def dijkstra(src):

	dist = [sys.maxsize] * self.V
	dist[src] = 0
	sptSet = [False] * self.V
	
	for cout in range(self.V):
		# 找到最短路径
		x = minDistance(dist, sptSet)

		sptSet[x] = True
	
		# 更新路径
		for y in range(self.V):
			if self.graph[x][y] > 0 and sptSet[y] == False and \
					dist[y] > dist[x] + self.graph[x][y]:
				dist[y] = dist[x] + self.graph[x][y]
```


### Bellman-Ford 算法

[Bellman–Ford Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/)

可以用来处理负权重

初始化一个从起点到其他点的距离数组 `dist`，遍历V次（V为顶点数），每次遍历时遍历所有的边，每条边由起点`u`，终点`v`和距离`wt` 组成，如果满足 `dist[u]+wt < dist[v]`就更新 `dist[v]`。注意当遍历最后一次时，仍然存在需要更新的情况，则证明存在负边。

```python
def bellmanFord(V, edges, src):
    dist = [100000000] * V
    dist[src] = 0
    
    for i in range(V):
        for edge in edges:
            u, v, wt = edge
            if dist[u] != 100000000 and dist[u] + wt < dist[v]:
            
                if i == V - 1:
                    return [-1]

                dist[v] = dist[u] + wt
    return dist
```


### Floyd Warshall 算法

[Floyd Warshall Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/)

可以用来处理负权重边，用来求每对起点到终点之间的距离，用动态规划的方法求解

先初始化一个距离矩阵 `dist`，考虑每个顶点作为中间点，更新这种情况下的最短路径，如果一个顶点 `k` 不是 `i` 到 `j` 的中间点，则保持 `dist[i][j]`，否则如果 `dist[i][j]>dist[i][k]+dist[k][j]`

该方法需要三次循环（循环顶点数），时间复杂度为 $O(V^3)$，因此该方法适合边很多的图，不适合边很稀少的图

```python
def solve(graph):
    V = len(graph)
    
    for k in range(V):
        for i in range(V):
            for j in range(V):
                # 当 i 到 j 未更新距离，或者加入k能让路径更短时
                # 且k到j，i 到k已经更新距离时
                # 更新距离
                if (graph[i][j] == -1 \
                or graph[i][k] + graph[k][j] < graph[i][j]) \
                and (graph[k][j] != -1 and graph[i][k] != -1):
                    graph[i][j] = graph[i][k] + graph[k][j]
```


### Johnson 算法

[Johnson's algorithm for All-pairs shortest paths - GeeksforGeeks](https://www.geeksforgeeks.org/johnsons-algorithm/)

用来找到所有的成对最短路径，该方法适用于边比较稀少的图

首先在图中添加一个新节点 s，该节点可以到达所有其它节点，权重为0。通过Bellman-Ford算法求出以 s 作为起点时到所有点的最短路径，如果找到负权重环，返回。最终可以算出从 s 到其它节点的最短距离 `h`，然后用公式 `w(u,v)=w(u,v)+h(u)-h(v)` 重新分配权重。这样图中所有路径都不是负值，可以使用 Dijkstra 算法求解成对最短路径。


### 有向无环图的最短路径

[Shortest Path in Directed Acyclic Graph - GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/)

在有向无环图中有更好的最短路径求解方法，采用拓扑排序，因为没有环，可以直接用常规的DFS进行遍历

初始化一个距离数组（初始化为正无穷），从起点出发创建所有节点的拓扑排序，以拓扑排序的顺序遍历所有的节点 `u`，对于 `u` 的相邻节点 `v`，如果 `dist[v]>dist[u]+weight[u,v]`，更新 `dist[v]`


```python
class Graph:
    def __init__(self,vertices):
 
        self.V = vertices
 
        # 存储邻接矩阵
        self.graph = defaultdict(list)
 
	 def addEdge(self,u,v,w):
        self.graph[u].append((v,w))
        
def solve(g: Graph, s):

    # 拓扑排序，实际路径为 1->3->4->5 和 1->2->5
    # 拓扑排序结果为 5 4 3 2 1
    def topologicalSort(v):
        visited[v] = True
        if v in g.graph.keys():
            for n, w in g.graph[v]:
                if not visited[n]:
                    topologicalSort(n)
        stack.append(v)
        
    n = g.V
    visited = [False] * n
    stack = []

    for i in range(n):
        if not visited[i]:
            topologicalSort(s)
    dist = [float("inf")] * n
    dist[s] = 0

    while stack:
        i = stack.pop()
        for n, w in g.graph[i]:
            if dist[n] > dist[i] + w:
                dist[n] = dist[i] + w
```


### 无权图的最短路径

[Shortest path in an unweighted graph - GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-unweighted-graph/)

使用BFS，用一个数组记录距离和每个节点的父节点

```python
def bfs(graph, S, par, dist):
    q = deque()
    # S 为起点
    dist[S] = 0
    q.append(S)

    while q:
        node = q.popleft()
        for neighbor in graph[node]:
            # 判断是否未访问
            if dist[neighbor] == float('inf'):
                # 标记父节点
                par[neighbor] = node
                # 更新距离
                dist[neighbor] = dist[node] + 1
                q.append(neighbor)
```


如果权重为0或者1，也能用BFS求解

[0-1 BFS (Shortest Path in a Binary Weight Graph) - GeeksforGeeks](https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/)

如果权重为0，将节点放在队列前面，否则将节点放在队列后面

```python
def zeroOneBFS(src: int):
    dist = [INT_MAX] * V

    Q = deque()
    dist[src] = 0
    Q.append(src)

    while Q:
        v = Q.popleft()
        for i in range(len(edges[v])):
            if (dist[edges[v][i].to] > 
                dist[v] + edges[v][i].weight):
                dist[edges[v][i].to] = dist[v] + edges[v][i].weight

                # 权重为0的节点放在前面，可以优先处理
                if edges[v][i].weight == 0:
                    Q.appendleft(edges[v][i].to)
                else:
                    Q.append(edges[v][i].to)
```

### 无向图找到最小的权重环

[Find minimum weight cycle in an undirected graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-minimum-weight-cycle-undirected-graph/)

假定所有的路径的权重都大于0，遍历所有的边，尝试删除这条边之后求起点到终点的最小路径，然后加上这条边的权重，更新最小权重。

```python
class Edge:
    def __init__(self, u, v, weight) -> None:
        self.u = u
        self.v = v
        self.weight = weight

class Graph:
     
    def __init__(self, V: int) -> None:
         
        self.V = V
        self.adj = [[] for _ in range(V)]
        self.edge = []
 
    # 添加边
    def addEdge(self, u, v, w) -> None:
        self.adj[u].append((v, w))
        self.adj[v].append((u, w))
 
        e = Edge(u, v, w)
        self.edge.append(e)
 
    # 删除边
    def removeEdge(self, u, v, w) -> None:
        self.adj[u].remove((v, w))
        self.adj[v].remove((u, w))
 
    # 求最短路径（dijkstra）
    def ShortestPath(self, u: int, v: int) -> int:
         
        # 储存已经处理过的节点
        setds = set()
        
        dist = [INF] * self.V
 
        # 初始添加起点
        setds.add((0, u))
        dist[u] = 0
 
        while (setds):
             
            # 弹出父节点
            _, uu = setds.pop()
 
            # 遍历邻接节点
            for vv, weight in self.adj[uu]:
                if (dist[vv] > dist[uu] + weight):
                     
                    # 删除旧的路径
                    if (dist[vv] != INF):
                        if ((dist[vv], vv) in setds):
                            setds.remove((dist[vv], vv))
					
                    # 更新新的路径
                    dist[vv] = dist[uu] + weight
                    setds.add((dist[vv], vv))
        return dist[v]
 
    def FindMinimumCycle(self) -> int:
         
        min_cycle = maxsize
        E = len(self.edge)
        # 遍历所有的边
        for i in range(E):
            e = self.edge[i]
 
            # 删除当前边
            self.removeEdge(e.u, e.v, e.weight)
 
            # 计算最短距离
            distance = self.ShortestPath(e.u, e.v)
 
            # 更新最小权重环
            min_cycle = min(min_cycle,  distance + e.weight)
 
            # 重新添加当前边
            self.addEdge(e.u, e.v, e.weight)
        return min_cycle
```


### Prim最小生成树

[Prim’s Algorithm for Minimum Spanning Tree (MST) - GeeksforGeeks](https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/)

在一个无向连通加权图中，最小生成树是一棵包含图中所有顶点，且边的权值之和最小的树。它是原图的一个子图，具备树的性质（无回路且连通），同时在所有可能的生成树中总权值最小。

最小生成树可以用来解决：连通所有节点的最短路径

任意选择一个顶点作为开始节点，找到任意树节点和外围节点（还没有纳入树的节点）相连的边，在这些边中找到最小的，将所选的边加入最小生成树中。如此循环直到节点全部处理完。

```python
class Graph():
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for column in range(vertices)]
                      for row in range(vertices)]
    
    # 求最小键对应的索引
    def minkey(self, mstSet, key):
        mink = float("inf")
        idx = 0
        for i in range(self.V):
            if not mstSet[i]:
                if mink > key[i]:
                    idx = i
                    mink = key[i]
        return idx
    
    def solve(self):
        key = [float("inf")] * self.V
        parent = [None] * self.V

        key[0] = 0
        mstSet = [False] * self.V

        parent[0] = -1

        for _ in range(self.V):
            # 从未处理的节点中选择最小距离的节点，最开始选择的是0
            mk = self.minkey(mstSet, key)
            mstSet[mk] = True
            for v in range(self.V):
                # 更新未处理且存在边的顶点距离
                if not mstSet[v] and self.graph[mk][v] > 0:
                    if key[v] > self.graph[mk][v]:
                        key[v] = self.graph[mk][v]
                        parent[v] = mk
        for i in range(1, self.V):
            print(parent[i], "-", i, "\t", self.graph[parent[i]][i])
```

时间复杂度为 $O(V^2)$，适合边很多的图，用最小堆来实现可以进一步减少时间复杂度

```python
import heapq

def findMST(n, edges):
    adj = [[] for _ in range(n + 1)]  # 1-based indexing

    # Convert edge list to adjacency list
    for u, v, w in edges:
        adj[u].append((w, v))
        adj[v].append((w, u))

    pq = [(0, 1)]  # (weight, node), start from node 1
    inMST = [False] * (n + 1)  # 1-based indexing
    mstCost = 0

    while pq:
        w, u = heapq.heappop(pq)
        if inMST[u]:
            continue
        inMST[u] = True
        mstCost += w
		# 将邻接的节点塞入堆中，这时候也不需要更新，直接塞进去就可以了
        for weight, v in adj[u]:
            if not inMST[v]:
                heapq.heappush(pq, (weight, v))
    return mstCost
```

### Kruskal 最小生成树算法

[Kruskal’s Minimum Spanning Tree (MST) Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)

按权重大小升序排列所有的边，选择权重最小的边，并且检查和是否和已有的边形成一个环（使用并查集检测环，如果两个端点在已有的边中有相同的代表，则证明存在环），如果形成环，就不选择这条边，否则选择，直到所有的顶点都被选择。

```python
def kruskals_mst(V, edges):
    edges = sorted(edges,key=lambda x: x[2])
    dsu = DSU(V)
    cost = 0
    count = 0
    for x, y, w in edges:
        # 保证没有环
        if dsu.find(x) != dsu.find(y):
            dsu.union(x, y)
            cost += w
            count += 1
            if count == V - 1:
                break
    return cost
```

时间复杂度为 $O(E\log E)$，适合边比较少的


### 生成树的数量

[Total number of Spanning Trees in a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/total-number-spanning-trees-graph/)

有计算公式


### 拓扑排序

[Topological Sorting - GeeksforGeeks](https://www.geeksforgeeks.org/topological-sorting/)

拓扑排序用于排列有向无环图的顶点

拓扑排序的结果不唯一

初始化一个栈 stack 和已经访问过的数组 visited；对于图中每个未访问过的顶点，调用DFS，在DFS中标记该顶点已被访问，并且递归调用DFS遍历未访问过的邻接节点，当所有的邻接节点全部被访问过，将该顶点塞入栈中，栈中最上面保存的即为最靠后的节点。栈中的数组反向输出便为最终的结果。

```python
def topologicalSort(adj):
    V = len(adj)
    st = []
    visited = [False] * V

    def dfs(root):
        visited[root] = True
        for neigh in adj[root]:
            if not visited[neigh]:
                dfs(neigh)
        st.append(root)

    for i in range(V):
        if not visited[i]:
            dfs(i)
    return st[::-1]
```


### Kahn 算法实现拓扑排序

[Kahn's algorithm for Topological Sorting - GeeksforGeeks](https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/)

用一个队列保存所有入度为0的节点，当队列非空时，从队列中删除一个节点，然后将所有与该节点相连的节点的入度减1，如果有节点入度减为1，则将其入队列。

如果队列已空，而图中仍存在节点，证明存在环

队列中的节点代表拓扑排序的顺序。

```python
def solve(adj, V):
    indegree = [0] * V
    
    for i in range(V):
        for v in adj[i]:
            indegree[v] += 1

    queue = deque()
    for i in range(V):
        if indegree[i] == 0:
            queue.append(i)
    result = []
    while queue:
        node = queue.popleft()
        result.append(node)
        # 邻接节点入度减1
        for j in adj[node]:
            indegree[j] -= 1
            # 如果入度降为0，入队列
            if indegree[j] == 0:
                queue.append(j)
    # 存在环，没有拓扑排序
    if len(result) != V:
        return []
    return result
```



### 保持有向无环图的最大可添加边的数量

[Maximum edges that can be added to DAG so that it remains DAG - GeeksforGeeks](https://www.geeksforgeeks.org/maximum-edges-can-added-dag-remains-dag/)

有公式可以计算，保证有向无环图的最多的边数为 $n(n-1)/2$


### 打印所有的拓扑排序

[All Topological Sorts of a Directed Acyclic Graph - GeeksforGeeks](https://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/)

先初始化入度数组，再采用递归的方法打印所有的拓扑排序

```python
def findAllTopologicalOrders(graph, path, discovered, N):
    
    for v in range(N):
        if not discovered[v] and graph.indegree[v] == 0:
            # 设置信息
            discovered[v] = True
            path.append(v)
            for neigh in graph.adjList[v]:
                graph.indegree[neigh] -= 1
            
            findAllTopologicalOrders(graph, path, discovered, N)

            # 还原信息
            discovered[v] = False
            path.pop()
            for neigh in graph.adjList[v]:
                graph.indegree[neigh] += 1
    if len(path) == N:
        print(path)
```




### 有向无环图的最长路径

[Longest Path in a Directed Acyclic Graph - GeeksforGeeks](https://www.geeksforgeeks.org/find-longest-path-directed-acyclic-graph/)

与最短路径不同，最长路径没有所谓的最优子结构，一般图的最长路径是NP-hard问题。但是有向无环图的最长路径有线性的时间复杂度解法

首先初始化一个距离数组 dist（初始化为正无穷），假设起点为 s，令 `dist[s]=0`。

对于所有的顶点进行拓扑排序，按照拓扑排序的顺序遍历所有的节点 u

对于节点 `u` 的邻接节点 `v`，如果 `dist(v)<dist(u)+weight(u,v)`，就更新 `dist(v)`

```python
def solve(V, adj, s):
	# kahn 算法排序
    def topological_sort(adj):
        result = []

        indegree = [0] * V

        for i in range(V):
            for v, w in adj[i]:
                indegree[v] += 1
        
        queue = deque()
        for i in range(V):
            if indegree[i] == 0:
                queue.append(i)
        
        while queue:
            node  = queue.popleft()
            result.append(node)
            for neigh, w in adj[node]:
                indegree[neigh] -= 1
                if indegree[neigh] == 0:
                    queue.append(neigh)
        return result
    
    dist = [-float("inf")] * V
    dist[s] = 0
    # 拓扑排序
    topo = topological_sort(adj)

    for i in topo:
        if dist[i] == -float("inf"):
            continue
        for v, w in adj[i]:
            if dist[v] < dist[i] + w:
                dist[v] = dist[i] + w
    print(dist)
```


### 图中关节点的数量

[Articulation Points (or Cut Vertices) in a Graph - GeeksforGeeks](https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/)

关节点指如果去掉这个点，图会被分成多个不相连的子图

一种简单的方法是尝试每个节点，然后对图进行DFS，一次DFS之后，如果还有节点没有被访问过，证明存在多个图

```python
def solve(adj, V):
    res = []

    def dfs(i, curr):
        vis[curr] = True
        for neigh in adj[curr]:
            # 保证不经过关节点 i
            if neigh != i:
                if not vis[neigh]:
                    dfs(i, neigh)

    for i in range(V):
        components = 0
        vis = [0] * V

        # dfs判断子图数
        for j in range(V):
            if j != i:
                if not vis[j]:
                    components += 1
                    dfs(i, j)
        # 如果存在多个子图
        if components > 1:
            res.append(i)
    print(res)
```


使用 Tarjan 算法求解关节点的数量，在 DFS 树中，如果一个顶点 u 为关键点，则有下面两个条件

+ u 是 DFS 树的根，并且至少有两个子节点
+ u 不是DFS树的根，有一个子节点 v，使得以 v 为根的子树中没有一个节点存在与 u 的祖先节点相连的边。

![](https://media.geeksforgeeks.org/wp-content/uploads/20230801170641/example-1drawio.png)
借助上面的条件，

+ 在DFS 遍历时，维持一个parent数组，`parent[u]` 保存 `u` 节点的父节点
+ 如果当前访问到的节点 u 的`parent[u]` 为NULL，并且有两个以上的子节点，则该节点为关键点
+ 为了处理第二个条件，维持一个数组 `disc` 保存节点的发现时间
+ 对于每个节点 `u`，找到以 `u` 为根节点的子树中最近访问的节点（最小发现时间的节点），所以需要维持一个额外的数组 `low`，`low[u]=min(disc[u],disc[w]))`，这里的 `w` 时 u 的一个祖先，

```python
def findPoints(adj, u, visited, disc, low, time, parent, isAP):
    # 计算DFS 树的子节点
    children = 0
    visited[u] = 1
    
    # 初始化发现时间和最小发现时间
    time[0] += 1
    disc[u] = time[0]
    low[u] = time[0]
    
    # 遍历所有邻接节点
    for v in adj[u]:
        # 如果 v 还未被访问，标记其为 u 的子节点
        if visited[v] == 0:
            children += 1
            findPoints(adj, v, visited, disc, low, time, u, isAP)
            
            # 如果子节点能够被更小发现时间的节点
            low[u] = min(low[u], low[v])
            
            # 如果 u 不是根节点，并且存在子节点的low值大于 u 的发现时间
            if parent != -1 and low[v] >= disc[u]:
                isAP[u] = 1
                
        # 更新 u 的low值
        elif v != parent:
            low[u] = min(low[u], disc[v])
    
    # 如果 u 为根节点，且有多个子节点，则为关键点
    if parent == -1 and children > 1:
        isAP[u] = 1

def articulationPoints(adj):
    V = len(adj)
    disc = [0] * V   # 记录顶点的发现时间
    low = [0] * V   # 保存子树中最早访问到的节点
    visited = [0] * V
    isAP = [0] * V  # 标记关键点，1 表示为关键点
    time = [0]  # 存储时间和父节点
    par = -1
    
    # 遍历所有节点，防止出现非联通图
    for u in range(V):
        if visited[u] == 0:
            findPoints(adj, u, visited, disc, low, time, par, isAP)

    return isAP
```


### 查找集群中的关键连接

该问题相当于求割边。只有环路中的边删除才能保持连接，非环路的边为割边。为了求出非环路的边，给所有的节点赋一个初始ID，一个回路的所有节点共享一个ID，并取最小值，因此环路中的所有节点和入环的节点的ID相同，如果父节点 `p` 到入环节点 `i` 的路径不构成一条边，那么入环节点ID和其初始ID是相同的，所以 `(p,i)` 是一条割边

```python
def criticalConnections(n: int, connections):
	adj = [[] for _ in range(n)]
	# 构建无向图
	for conn in connections:
		adj[conn[0]].append(conn[1])
		adj[conn[1]].append(conn[0])
	ids = [-1] * n
	res = []

	def findPoints(i, id, parent):
		ids[i] = id   # 先假定节点的 id
		for j in adj[i]:
			if j == parent:
				continue
			elif ids[j] == -1:  # 如果邻接节点的id未求解
				ids[i] = min(ids[i], findPoints(j, id+1, i))
			else:  # 已经求解
				ids[i] = min(ids[i], ids[j])
		# 如果 ids[i] == id 证明这段路径不构成一个环路
		if ids[i] == id and parent != -1:
			res.append([parent, i])
		return ids[i]
	findPoints(0, 0, -1)
	return res
```


### 最短的桥

[934. 最短的桥 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-bridge/description/)

已知在一张图中包含两个岛，每个岛由相连（上下左右）的 1 组成，可以转变一些0为1，求出使这两座岛相邻的最小转变次数

先记录下一座岛屿的全部点，然后逐层向外扩张，直至四周出现另一座岛，为了避免重复访问，将先记录的岛全部变为2。

```python
def shortestBridge(self, grid: List[List[int]]) -> int:
	from collections import deque
	m = len(grid)
	n = len(grid[0])
	dirs = [[0, 1], [0,-1], [1, 0], [-1, 0]]
	queue = deque()   # 记录第一个岛屿的组成点的位置

	def dfs(x, y):
		queue.append((x, y))
		grid[x][y] = 2
		for d0, d1 in dirs:
			nx, ny = x + d0, y + d1
			if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
				dfs(nx, ny)
	# 找到第一个 1 对应的 i 和 j
	i, j = next((i, j) for i in range(n) for j in range(n) if grid[i][j])
	dfs(i, j)
	steps = 0
	while True:
		size = len(queue)
		for i in range(size):
			i, j = queue.popleft()
			for d0, d1 in dirs:
				ni, nj = i + d0, j + d1
				if 0 <= ni < m and 0 <= nj < n:
					if grid[ni][nj] == 1:
						return steps
					if grid[ni][nj] == 0:  # 周围是0，扩张
						grid[ni][nj] = 2
						queue.append((ni, nj))
		steps += 1
```

### 计算图中树的数量

[Count number of trees in a forest - GeeksforGeeks](https://www.geeksforgeeks.org/count-number-trees-forest/)

对每个未访问的节点都进行DFS，计数加1，表示存在一个树

如果只有一棵树，那么一次DFS就能找到；如果有多棵树，那么一次DFS后还有未访问的节点，这时候再DFS一次


### 克隆无向图

[Clone an Undirected Graph - GeeksforGeeks](https://www.geeksforgeeks.org/clone-an-undirected-graph/)


传入一个节点，克隆整个图，需要创建一个字典来记录所有已经创建过的节点

```python
from collections import deque

class GraphNode:
	def __init__(self, val=0, neighbors=[]):
		self.val = val
		self.neighbors = neighbors

def cloneGraph(src: GraphNode) -> GraphNode:
	# m 用来记录所有已经创建的节点
	m = {}
	q = deque()
	
	q.append(src)
	node = None

	# 创建克隆的节点
	node = GraphNode(src.val)

	# 记录初始节点
	m[src] = node
	while q:
		u = q.popleft()
		for neighbor in u.neighbors:
			# 检查该节点是否已被创建
			if neighbor not in m:
				# 没有的话需要创建
				node = GraphNode()
				node.val = neighbor.val
				m[neighbor] = node
				q.append(neighbor)

			# 添加邻接节点
			m[u].neighbors.append(m[neighbor])

	return m[src]
```


### 图顶点涂色问题

[Introduction to Graph Coloring - GeeksforGeeks](https://www.geeksforgeeks.org/graph-coloring-applications/)

用m种颜色为图顶点涂色，要求相邻顶点不同色，采用回溯法，注意求最少颜色是一个NP完全问题

```python
def graph_coloring(graph, m):
    n = len(graph)
    colors = [-1] * n  # 初始涂色
    def issafe(idx, nc):
        for i in range(n):
            if graph[idx][i] == 1 and colors[i] == nc:
                return False
        return True

    def color(idx):
        if idx == n:
            return True
        res = False
        # 尝试m种颜色
        for i in range(m):
            if issafe(idx, i):
                colors[idx] = i  # 填上第 i 种颜色
                if color(idx+1):
                    return True
                colors[idx] = -1  # 去除颜色
        return res
    
    res = color(0)
    if res:
        print(colors)
```


用贪心算法求解图顶点涂色问题，不能保证最小解

```python
def greedy_solve(adj, V):
    result = [-1] * V
    result[0] = 0 # 先涂第一个顶点

    available = [True] * V  # 可用的颜色

    for i in range(1, V):
        
        for n in adj[i]:
            if result[n] != -1:  # 已经涂过色的顶点
                available[result[n]] = False
        
        cc = 0
        while not available[cc]:
            cc += 1
        
        result[i] = cc

        # 重置可用的颜色
        for n in adj[i]:
            if result[n] != -1:  # 已经涂过色的顶点
                available[result[n]] = True
        
    print(result)
```


### 找到最终的安全状态

[802. 找到最终的安全状态 - 力扣（LeetCode）](https://leetcode.cn/problems/find-eventual-safe-states/description/)

在一个有 `n` 个节点的有向图，节点按 `0` 到 `n-1` 编号，如果一个节点没有连出的有向边，则该节点是终端节点。如果从该节点开始的所有可能路径都通向终端节点，则该节点为安全节点，找到所有的安全节点（包括终端节点）。

解决该问题，需要用三种颜色标记节点，分别为 0（白色）：尚未被访问，1（灰色）：位于递归栈中，或者在某个环上，2（黑色）：搜索完毕是安全节点

首次访问一个节点时，将其标记为灰色，并继续搜索与其相邻的节点；如果遇到了一个灰色节点，证明找到一个环，此时退出搜索，栈中的节点仍然是灰色。如果搜索过程中没有遇到灰色节点，说明没有遇到环，递归返回前，将其标记从灰色改为黑色

```python
def eventualSafeNodes(graph: List[List[int]]) -> List[int]:
	n = len(graph)
	# 标记节点的状态, 0 表示未访问, 1表示在一个环中，2表示安全节点
	node_attributes = [0] * n  
		
	def dfs(i):
		if node_attributes[i] > 0:
			return node_attributes[i] == 2
		node_attributes[i] = 1  # 首次遇到标记为1
		for j in graph[i]:   # 遍历邻接节点
			if not dfs(j):
				return False
		# 没有遇到环
		node_attributes[i] = 2  # 所有可能路径都通向终端节点，标记为安全节点
		return True
	
	for i in range(n):
		if node_attributes[i] == 0:
			dfs(i)
	return [i for i in range(n) if node_attributes[i]==2]
```


### 颜色交替的最短路径

[1129. 颜色交替的最短路径 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/)

给定一个图，图中包含两种颜色的边，求从节点0到其它节点的颜色交替出现的最小路径是多大

可以使用层序遍历，注意在生成邻接矩阵时需要将边的颜色也加入

```python
def shortestAlternatingPaths(n: int, redEdges, blueEdges):
	from collections import deque

	adj = [[] for _ in range(n)]
	for edge in redEdges:
		adj[edge[0]].append((edge[1], 0))  # 0 表示红色
	for edge in blueEdges:
		adj[edge[0]].append((edge[1], 1))  # 1 表示蓝色
	queue = deque()
	level = 0
	queue.append((0, 0))
	queue.append((0, 1))
	res = [-1] * n
	visited = {(0, 0), (0, 1)}
	while queue:
		size = len(queue)
		for _ in range(size):
			node = queue.popleft()
			if res[node[0]] == -1:
				res[node[0]] = level
			for n in adj[node[0]]:
				# 如果边的颜色不一致，且该节点没有被访问过
				if n[1] != node[1] and n not in visited: 
					visited.add(n)
					queue.append(n)
		level += 1
	return res
```



### TSP问题

[Travelling Salesman Problem using Dynamic Programming - GeeksforGeeks](https://www.geeksforgeeks.org/travelling-salesman-problem-using-dynamic-programming/#using-recursion-on-time-and-on-space)

TSP是NP-Hard问题，没有几何时间复杂度的解

```python
def tsp(cost):
    n = len(cost)
    def _tsp(mask, idx):
	    # 全部访问过了
        if mask == (1 << n) - 1:
            return cost[idx][0]  # 返回起点的距离
        ans = float("inf")
        for i in range(n):
            # 第 i 点未访问
            if (i != idx) and (mask & (1<<i)) == 0:
                ans = min(ans, cost[idx][i] + _tsp(mask | (1 << i), i))
        return ans
    res = _tsp(1, 0)   # 刚开始访问了第一个节点
    return res
```


最小生成树可以求一个近似解，先求出最小生成树，TSP的最小解绝不会小于最小生成树的权重之和


### K 中心问题

[Greedy Approximate Algorithm for K Centers Problem - GeeksforGeeks](https://www.geeksforgeeks.org/greedy-approximate-algorithm-for-k-centers-problem/)

在一个二维平面的n个点，找到k个中心，使得所有点到中心的距离的最大值最小。这是一个NP-Hard问题。

下面介绍一个近似算法

首先任意选择一个点作为中心，剩下的k-1个中心选择准则为：
1、假设 c1，c2，... 是已经选择的中心
2、第 i + 1个中心 p 应该距离这些已经选择的中心最远（使得 min(dist(p, c1), dist(p, c2), ...) 最大）

```python
def maxIndex(dist, n):
    mi = 0
    for i in range(n):
        if dist[i] > dist[mi]:
            mi = i
    return mi

def solve(n, weights, k):
    dist = [10**9] * n
    max = 0
    centers = []
    for i in range(k):
        centers.append(max)
        # 更新距离
        for j in range(n):
            dist[j] = min(dist[j], weights[max][j])
        # 求距离最大的点
        max = maxIndex(dist, n)
    
    return dist[max]
```

### 求有向图的欧拉回路

[Hierholzer's Algorithm for directed graph - GeeksforGeeks](https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/)

一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数，且该图是连通图。

一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。

```python
def solve(adj):
    n = len(adj)

    if n == 0:
        return []
    currPath = [0]
    circuit = []

    while len(currPath) > 0:
        currNode = currPath[-1]

        # 如果当前顶点还存在边
        if len(adj[currNode]) > 0:
            nextNode = adj[currNode].pop()
            currPath.append(nextNode)
        # 弹出当前的路径
        else:
            circuit.append(currPath.pop())

    circuit.reverse()
    return circuit
```


### 生成给定度的图

[Construct a graph from given degrees of all vertices - GeeksforGeeks](https://www.geeksforgeeks.org/construct-graph-given-degrees-vertices/)

给定图顶点的度，生成一个图

先创建一个邻接矩阵，外部循环起点，内部循环终点，判断是否能构建一条边

```python
def solve(degseq, n):

    mat = [[0] * n for i in range(n)]

    for i in range(n):
        for j in range(i+1, n):
            # 如果能构建一条边
            if degseq[i] > 0 and degseq[j] > 0:
                degseq[i] -= 1
                degseq[j] -= 1
                mat[i][j] = 1
                mat[j][i] = 1
```


### 判断有向图是否存在一个共同的终点


[Determine whether a universal sink exists in a directed graph - GeeksforGeeks](https://www.geeksforgeeks.org/determine-whether-universal-sink-exists-directed-graph/)


采用删除法，如果一条边 `adj[i][j]` 存在，则 i 不是终点，如果不存在，则 j 不是终点。

```python
def solve(V, adj):
    i, j = 0, 0

    def issink(i):
        for j in range(V):
            if adj[i][j] == 1:
                return False
            
            if adj[j][i] == 0 and j != i:
                return False
        return True
    
    while i < V and j < V:
        if adj[i][j] == 1:  # i 是起点
            i += 1 
        else:           # j 不是 i 的终点
            j += 1

    if i > V:
        return -1
    elif not issink(i):
        return -1
    else:
        return i
```


### 统计图中终点的数量

[Number of sink nodes in a graph - GeeksforGeeks](https://www.geeksforgeeks.org/number-sink-nodes-graph/)


统计每个点的出度，出度为0，即为终点。


### 通知所有员工需要的时间

[1376. 通知所有员工所需的时间 - 力扣（LeetCode）](https://leetcode.cn/problems/time-needed-to-inform-all-employees/description/)

公司里有 `n` 名员工，每个员工的 ID 都是独一无二的，编号从 `0` 到 `n - 1`。公司的总负责人通过 `headID` 进行标识。在 `manager` 数组中，每个员工都有一个直属负责人，其中 `manager[i]` 是第 `i` 名员工的直属负责人。对于总负责人，`manager[headID] = -1`。题目保证从属关系可以用树结构显示。

公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。第 `i` 名员工需要 `informTime[i]` 分钟来通知它的所有直属下属（也就是说在 `informTime[i]` 分钟后，他的所有直属下属都可以开始传播这一消息）。求通知所有员工这一紧急消息所需要的**分钟数** 。


这个问题可以采用DFS的方法解决，一个重点在如何建树

```python
def numOfMinutes(n: int, headID: int, manager, informTime):
	max_time = 0
	queue = [headID]
	# 建树
	adj = [[] for _ in range(n)]
	for i in range(n):
		adj[manager[i]].append(i)

	visited = [False] * n
	def dfs(i):
		visited[i] = True
		res = 0
		for j in adj[i]:
			# 每个节点向下传
			if not visited[j]:
				res = max(res, informTime[i]+dfs(j))
		return res
	res = dfs(headID)
	return res
```

此外还可以考虑自底向上，用记忆化搜索的方法，尝试每一个节点

```python
def numOfMinutes(self, n: int, headID: int, manager, informTime):
	@cache   # 缓存装饰器，避免重复计算 dfs 的结果
	def dfs(i):
		if i == headID:
			return informTime[i]
		return dfs(manager[i]) + informTime[i]
	return max([dfs(i) for i in range(n)])
```



### 最小基因变化

[433. 最小基因变化 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-genetic-mutation/description/)

使用BFS搜索

```python
def minMutation(startGene: str, endGene: str, bank: List[str]) -> int:
	from collections import deque
	n = len(startGene)
	bank_set = set(bank)
	if endGene not in bank_set:
		return -1
	
	q = deque()
	q.append((startGene, 0))  # 塞入目前的基因序列和变化次数
	while q:
		cur, step = q.popleft()
		for i, x in enumerate(cur):
			for y in "ACGT":   # 尝试每种基因
				if y != x:
					nxt = cur[:i] + y + cur[i+1:]
					if nxt in bank_set:
						if nxt == endGene:
							return step + 1
						bank_set.remove(nxt)
						q.append((nxt, step + 1))  # 添加新的基因
	return -1
```


### 01矩阵

[542. 01 矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/01-matrix/description/)

一个矩阵中只有0和1，求所有元素到1的距离。

该问题为多源BFS，定义一个dist矩阵，遍历原矩阵将所有的0塞入队列中，并设置`dist[i][j]` 为0，然后进行多源的BFS，对于所有的 0 遍历上下左右四个方向，更新到 1 的距离

```python
def updateMatrix(mat: List[List[int]]) -> List[List[int]]:
	from collections import deque
	m = len(mat)
	n = len(mat[0])
	dist = [[-1 for _ in range(n)] for _ in range(m)]
	dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]
	queue = deque()
	# 获取所有的 0 元素
	for i in range(m):
		for j in range(n):
			if mat[i][j] == 0:
				dist[i][j] = 0
				queue.append((i, j, 0))
	while queue:
		x, y, d = queue.popleft()
		for dx, dy in dirs:
			nx, ny = x + dx, y + dy
			if 0 <= nx < m and 0 <= ny < n:
				if dist[nx][ny] == -1:  # 如果未设置距离
					if mat[nx][ny] == 1:  
						dist[nx][ny] = d + 1
						queue.append((nx, ny, d+1))
	return dist
```

该问题也能通过动态规划求解，不过需要规划两次，分别为水平向左和向上运动，向右和向下运动

```python
def updateMatrix(mat: List[List[int]]) -> List[List[int]]:
	from collections import deque
	m = len(mat)
	n = len(mat[0])
	dist = [[m + n for _ in range(n)] for _ in range(m)]
	for i in range(m):
		for j in range(n):
			if mat[i][j] == 0:
				dist[i][j] = 0
	
	# 水平向左和竖直向上移动
	for i in range(m):
		for j in range(n):
			if i - 1 >= 0:
				dist[i][j] = min(dist[i][j], dist[i-1][j]+1)
			if j - 1 >= 0:
				dist[i][j] = min(dist[i][j], dist[i][j-1]+1)
	# 水平向右和竖直向下移动
	for i in range(m-1, -1, -1):
		for j in range(n-1, -1, -1):
			if i + 1 < m:
				dist[i][j] = min(dist[i][j], dist[i+1][j]+1)
			if j + 1 < n:
				dist[i][j] = min(dist[i][j], dist[i][j+1]+1)
	
	return dist
```


### 二叉树中所有距离为 K 的结点

[863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/)

先用DFS找到所有节点的父节点，再以目标节点作为根节点，搜索左右子树和父节点的距离为 k 的节点，由于树的根节点发生变化，因此搜索时需要避免搜索到父节点。

```python
def distanceK(root: TreeNode, target: TreeNode, k: int) -> List[int]:
	parent = {}
	ans = []
	# 设置父节点
	def findParents(node):
		if node.left is not None:
			parent[node.left.val] = node
			findParents(node.left)
		if node.right is not None:
			parent[node.right.val] = node
			findParents(node.right)
	
	def findk(node, par, depth):
		if node is None:
			return

		if depth == k:
			ans.append(node.val)
			return
		if node.left != par:
			findk(node.left, node, depth+1)
		if node.right != par:
			findk(node.right, node, depth+1)
		# 如果原树中的父节点存在，且不等于目前的树中的父节点
		if node.val in parent and parent[node.val] != par:
			findk(parent[node.val], node, depth+1)
	
	findParents(root)

	findk(target, None, 0)
	return ans
```



### 获取所有钥匙的最短路径

[864. 获取所有钥匙的最短路径 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/)

这个题目和常规的BFS有一些差别，由于引入了 keys 这个变量，因此需要将keys也加入到 visited 矩阵中，为了方便表示，将keys用二进制表示，在选择下一个位置时，如果遇到钥匙，需要额外初始化一个变量来保存keys，防止四个方向出现多个key

```python
def shortestPathAllKeys(grid: List[str]) -> int:
	from collections import deque, defaultdict
	m = len(grid)
	n = len(grid[0])
	dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
	queue = deque()
	k = 0   # 先初始化 k 为没有获得key的状态
	
	# 设置 k 为全部的key都获取时的状态
	for i in range(m):
		for j in range(n):
			if grid[i][j] == "@":
				queue.append((i, j, 0, 0))
			if "a" <= grid[i][j] <= 'f':
				k |= 1 << (ord(grid[i][j]) - ord("a"))
	
	visited = [[defaultdict(bool) for _ in range(n)] for _ in range(m)]

	def isSafe(x, y, keys):
		if 0 <= x < m and 0 <= y < n and grid[x][y] != "#":
			if "A" <= grid[x][y] <= "F":
				key_idx = ord(grid[x][y].lower()) - ord("a")
				if keys & (1 << key_idx) != 0:  # 判断是否有对应的钥匙
					return True
			else:
				return True
		return False

	while queue:
		x, y, keys, steps = queue.popleft()
		visited[x][y][keys] = True
		for d in dirs:
			nx, ny = x + d[0], y + d[1]
			if isSafe(nx, ny, keys) and not visited[nx][ny][keys]:
				visited[nx][ny][keys] = True
				# 注意需要额外设置一个变量，处理上下左右四个方向出现多个钥匙的情况
				_keys = keys   
				if 'a' <= grid[nx][ny] <= 'f':
					_keys |= 1 << (ord(grid[nx][ny]) - ord("a"))
					if _keys == k:
						return steps + 1
				queue.append((nx, ny, _keys, steps+1))
	return -1

```


### 太平洋大西洋水流问题

[417. 太平洋大西洋水流问题 - 力扣（LeetCode）](https://leetcode.cn/problems/pacific-atlantic-water-flow/description/)

一个 $m\times n$ 大小的矩形岛屿，与太平洋和大西洋相邻，当岛屿一部分的高度大于等于另一部分，水就能流过去，求哪些位置的水能够流到两个大洋。

这里采用逆向求解，即水往高处流，从边界向上找，分别找到能流到两个大洋中的部分，再取相同的部分即可，这里用集合收集岛屿中的点，方便求相同部分

```python
def pacificAtlantic(self, heights) -> List[List[int]]:
	m = len(heights)
	n = len(heights[0])
	dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]
	pacificIslands = set()
	atlanticIslands = set()
	def dfs(i, j, islands):  # islands 既是结果又避免重复访问
		if (i, j) in islands:
			return
		islands.add((i, j))
		for di, dj in dirs:
			ni, nj = i + di, j + dj
			if 0 <= ni < m and 0 <= nj < n:
				if heights[ni][nj] >= heights[i][j]:
					dfs(ni, nj, islands)
	
	for i in range(m):
		dfs(i, 0, pacificIslands)
	for j in range(n):
		dfs(0, j, pacificIslands)
	
	for i in range(m):
		dfs(i, n-1, atlanticIslands)
	for j in range(n):
		dfs(m-1, j, atlanticIslands)

	return list(map(list, pacificIslands & atlanticIslands))
```


### 找到小镇的法官

[997. 找到小镇的法官 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-town-judge/description/)

该问题可以使用矩阵问题中的名人问题的解法求解，但是有一种更加简单的求法，即统计各个顶点的入度和出度，法官的入度为n-1，出度为0

```python
def findJudge(n: int, trust) -> int:
	in_degrees = Counter(y for _, y in trust)
	ou_degrees = Counter(x for x, _ in trust)

	for i in range(1, n+1):
		if in_degrees[i] == n - 1 and ou_degrees[i] == 0:
			return i
	return -1 
```


### 可以到达所有点的最少点数目

[1557. 可以到达所有点的最少点数目 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/description/)

如果是有向无环图，那么如果一个点可以到达所有点，那么其它点不会到这个点，因为一旦存在某个点 a 到这个点的一条边，就会形成环。该问题直接通过求出所有入度为 0 的点即可，入度为0的点的集合即为到达所有点的最少点集合。


### 判断二分图

[785. 判断二分图 - 力扣（LeetCode）](https://leetcode.cn/problems/is-graph-bipartite/)

用染色法判断，首先随便选一个点 `i` 进行染色，然后对于邻接节点，如果未染色，将其邻接节点染成另一个颜色，如果染了和点 `i` 相同的颜色，就证明这个图不是二分图。具体可以用DFS 或者 BFS进行遍历

```python
def isBipartite(graph: List[List[int]]) -> bool:
	n = len(graph)
	colors = [-1 for i in range(n)]
	valid = [True]
	def dfs(i, c):
		colors[i] = c
		for j in graph[i]:
			if colors[j] == -1:
				dfs(j, 1-c)
				if not valid[0]:
					return
			elif colors[j] == c:
				valid[0] = False
				return
	for i in range(n):
		if colors[i] == -1:
			dfs(i, 0)
			if not valid[0]:
				break
	return valid[0]
```


### 账户合并

[721. 账户合并 - 力扣（LeetCode）](https://leetcode.cn/problems/accounts-merge/description/)

该问题可以通过DFS算法解决，对每个账户进行编号，每个账户编号对应若干个邮箱，相当于与若干个邮箱相连，然后对每个账户进行DFS，则相连的邮箱属于同个用户

```python

def accountsMerge(accounts: List[List[str]]) -> List[List[str]]:
	email_to_idx = defaultdict(list)  # 邮箱对应账户
	for i, account in enumerate(accounts):
		for email in account[1:]:
			email_to_idx[email].append(i)

	def dfs(i: int) -> None:
		vis[i] = True
		for email in accounts[i][1:]:  # 遍历 i 的所有邮箱地址
			if email in email_set:
				continue
			email_set.add(email)
			for j in email_to_idx[email]:  
			# 遍历所有包含该邮箱地址的账户下标 j
				if not vis[j]:  # j 没有访问过
					dfs(j)

	ans = []
	vis = [False] * len(accounts)
	for i, b in enumerate(vis):
		if not b:  # i 没有访问过
			email_set = set()  # 用于收集 DFS 中访问到的邮箱地址
			dfs(i)
			ans.append([accounts[i][0]] + sorted(email_set))
	return ans
```


下面介绍一个基于并查集的算法

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
    
    def union(self, idx1, idx2): 
        self.parent[self.find(idx2)] = self.find(idx1)
    
    def find(self, idx):  # 路径压缩
        if self.parent[idx] != idx:
            self.parent[idx] = self.find(self.parent[idx])
        return self.parent[idx]
    
def accountsMerge(accounts: List[List[str]]) -> List[List[str]]:
	emailToIndex = {}
	emailToName = {}
	# 记录每个邮箱的编号和对应的名称
	for account in accounts:
		name = account[0]
		for email in account[1:]:
			if email not in emailToIndex:
				emailToIndex[email] = len(emailToIndex)
				emailToName[email] = name
	# 同一个账户中的邮箱地址一定属于同一个人
	# 因此遍历每个账户，对账户中的邮箱地址进行合并
	uf = UnionFind(len(emailToIndex))
	for account in accounts:
		fi = emailToIndex[account[1]]
		for email in account[2:]:
			uf.union(fi, emailToIndex[email])
	
	# 遍历邮箱地址，通过并查集得到该邮箱地址属于哪个合并后的账户
	indexToEmails = defaultdict(list)
	for email, index in emailToIndex.items():
		index = uf.find(index)
		indexToEmails[index].append(email)
		
	ans = []
	for emails in indexToEmails.values():
		ans.append([emailToName[emails[0]]] + sorted(emails))
	return ans
```


### 等式方程的可满足性

[990. 等式方程的可满足性 - 力扣（LeetCode）](https://leetcode.cn/problems/satisfiability-of-equality-equations/description/)

用并查集做，将所有相等的方程的元素合并到一起，再遍历所有不等的方程，如果两个不等元素有相同的父节点，证明不满足


### 按字典序排列最小的等效字符串

[1061. 按字典序排列最小的等效字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/description/)

该问题使用并查集，将等价的字符放在一起，但是需要注意的是在合并时，需要将字典序较小的字符作为代表

```python
class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
    
    def find(self, idx):
        if self.parent[idx] != idx:
            self.parent[idx] = self.find(self.parent[idx])
        return self.parent[idx]

    def union(self, idx1, idx2):
        px1 = self.find(idx1)
        px2 = self.find(idx2)
        if px1 < px2:  # 令字典序较小的作为代表
            self.parent[px2] = px1
        else:
            self.parent[px1] = px2
    
class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        n = len(s1)
        
        uf = UnionFind(26)  # 26 个字符
        for i in range(n):
            uf.union(ord(s1[i])-97, ord(s2[i])-97)

        low_order_str = ""
        for i in range(len(baseStr)):
            idx = uf.find(ord(baseStr[i]) - 97)
            low_order_str += chr(idx+97)
           
        return low_order_str
```


### 有向图中最大颜色值

[1857. 有向图中最大颜色值 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/description/)

给定有向图，图中每个节点都被染色，一共26种颜色，求一条路径中最多的颜色数量，如果存在环，返回-1

用BFS，先将所有入度为0的点（起点）塞入队列，设置一个二维数组记录在每个节点各种颜色的数量，然后搜索

```python
def largestPathValue(colors: str, edges: List[List[int]]) -> int:
	n = len(colors)
	
	adj = [[] for _ in range(n)]
	indeg = [0 for _ in range(n)]

	for e0, e1 in edges:
		indeg[e1] += 1
		adj[e0].append(e1)
	
	found = 0
	color = [[0] * 26 for _ in range(n)]
	queue = deque()

	for i in range(n):
		if indeg[i] == 0:
			queue.append(i)
		
	while queue:
		found += 1
		i = queue.popleft()
		color[i][ord(colors[i]) - ord("a")] += 1

		for j in adj[i]:
			indeg[j] -= 1
			# 入度为0，添加进队列
			if indeg[j] == 0:
				queue.append(j)
			# 可能有多条路径经过该节点，选择最大的
			for c in range(26):
				color[j][c] = max(color[j][c], color[i][c])
	if found != n: return -1  # 判断环
	ans = 0
	for i in range(n):
		ans = max(ans, max(color[i]))
	return ans
```


该问题还可以使用dfs，自底向上

```python
def largestPathValue(colors: str, edges: List[List[int]]) -> int:
	n = len(colors)
	rec_stack = [False for i in range(n)]
	visited = [False for i in range(n)]
	adj = [[] for i in range(n)]
	color = [[0] * 26 for i in range(n)]
	for edge in edges:
		adj[edge[0]].append(edge[1])
	max_color = 0
	def dfs(i):
		if rec_stack[i]: return True
		if visited[i]: return False
		rec_stack[i] = True
		visited[i] = True
		for j in adj[i]:
			if dfs(j):
				return True
		# 自底向上，color[i] = max(color[j], color[i])
		for j in adj[i]:
			for c in range(26):
				color[i][c] = max(color[j][c], color[i][c])
		color[i][ord(colors[i]) - ord("a")] += 1
		
		rec_stack[i] = False
		return False
	
	for i in range(n):
		if not visited[i]:
			if dfs(i): return -1
			max_color = max(max_color, max(color[i]))

	return max_color
```


### 项目管理

[1203. 项目管理 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/description/)

有一些项目，每个项目有对应的小组或者没有对应小组完成，一些项目有前置的项目，求出项目完成的顺序，要求同一小组的项目，排序后在列表中彼此相邻

先根据项目之间的先后关系得到组之间的先后关系，建一个组的图，再根据项目之间的关系建一个项目的图。分别对组和项目进行拓扑排序，先根据项目的拓扑顺序，项目和组之间的关系得到组对应的项目，最后根据组之间的顺序得到项目的顺序。


```python
def sortItems(n: int, m: int, group, beforeItems) -> List[int]:
	# 数据预处理，给没有归属于组的项目编上组号，为了避免冲突，从m开始编号
	for i in range(len(group)):
		if group[i] == -1:
			group[i] = m
			m += 1
	
	# 初始化组和项目的邻接表，以及入度数组
	groupAdj = [[] for _ in range(m)]
	itemAdj = [[] for _ in range(n)]
	groupIndeg = [0] * m
	itemIndeg = [0] * n

	# 建图
	for i in range(n):
		curGroup = group[i]
		# 遍历需要提前完成的项目
		for j in beforeItems[i]: 
			bg = group[j]  # 提前完成的项目所在的组
			if bg != curGroup:
				groupAdj[bg].append(curGroup)
				groupIndeg[curGroup] += 1
	
	for i in range(n):
		for j in beforeItems[i]:
			itemAdj[j].append(i)
			itemIndeg[i] += 1
	
	# 拓扑排序, n 为顶点的数量
	def topoSort(adj, indeg, n):
		res = []   # 保存排序结果
		queue = deque()
		for i, d in enumerate(indeg):
			if d == 0: queue.append(i)
		while queue:
			i = queue.popleft()
			res.append(i)
			for a in adj[i]:
				indeg[a] -= 1
				if indeg[a] == 0:
					queue.append(a)
		if len(res) == n:
			return res
		return []
	
	# 获取组和项目的拓扑排序结果
	groupList = topoSort(groupAdj, groupIndeg, m)
	if len(groupList) == 0: return []
	itemsList = topoSort(itemAdj, itemIndeg, n)
	if len(itemsList) == 0: return []

	# 根据项目的拓扑排序结果，项目和组的多对一关系，建立组到项目的一对多关系
	groups2Items = defaultdict(list)
	for item in itemsList:
		groups2Items[group[item]].append(item)
	
	# 根据组的拓扑排序结果，组到项目的一对多关系，得到结果
	res = []
	for g in groupList:
		items = groups2Items[g]
		res.extend(items)
	return res
```


## 贪心算法


### 背包问题

给定一组物品的价格和重量，一个最大重量的背包，求出能用背包装入的最大价值

允许可以任意拆分物品 [Fractional Knapsack Problem - GeeksforGeeks](https://www.geeksforgeeks.org/fractional-knapsack-problem/)

直接计算每个物品的单价（价格/重量），然后选择单价更高的物体装入就行。

```python
def fractionalKnapsack(W, prices, weights):
    pw = list(zip(prices, weights))
    pw.sort(key=lambda x: (x[0] / x[1]), reverse=True)

    value = 0
    now_weights = 0

    for price, weight in pw:
        if now_weights + weight <= W:
            value += price
            now_weights += weight
        else:
            value += price * (W - now_weights) / weight
            break
    return value
```

对于0-1背包问题，则需要采用动态规划的问题，对于第 i 个物品，背包重量为 j 时
如果背包能够装下，分成装该物品或者不装该物品：
`dp[i][j] = max(dp[i-1][j], profit[i] + dp[i-1][j-weights[i]])`

如果装不下：

`dp[i][j] = dp[i-1][j]`

```python
def solve_dp(profit, weight, N, W):
    N = len(profit)
    dp = [[0 for _ in range(W+1)] for _ in range(N+1)]

    for i in range(1, N+1):
        for j in range(1, W+1):
            if weight[i-1] <= j:
                dp[i][j] = max(dp[i-1][j], profit[i-1] + dp[i-1][j-weight[i-1]])
            else:
                dp[i][j] = dp[i-1][j]
    return dp[N][W]
```

动态规划完成后，如何根据表格找出装入的物品
[Printing Items in 0/1 Knapsack - GeeksforGeeks](https://www.geeksforgeeks.org/printing-items-01-knapsack/)

首先观察表格的最后一列，该列对应的是背包重量为 W 时的情况，反向遍历最后一列，可以发现，如果第 `i-1` 列和最后一列的值相等，就证明第 `i-1` 个物品没有被选取，否则被选取，然后再跳跃到对应的列

```python
for i in range(n, 0, -1):
	if res <= 0:
		break
	# 该物品没有被选择
	if res == K[i - 1][w]:
		continue
	else:
		# 第i个物品被选择
		print(wt[i - 1])
		 
		# 减去该物品的价值和重量，寻找下一个物品
		res = res - val[i - 1]
		w = w - wt[i - 1]
```


如果一个物品可以选择多次，只需要将动态规划中的

`dp[i][j] = max(dp[i-1][j], profit[i] + dp[i-1][j-weights[i]])`

改为

`dp[i][j] = max(dp[i-1][j], profit[i] + dp[i][j-weights[i]], profit[i] + dp[i-1][j-weights[i]])` 即可

```python
if wt[i-1] <= j:
    dp[i][j] = max(dp[i-1][j], val[i-1] + dp[i][j-wt[i-1]], 
				    val[i-1] + dp[i-1][j-wt[i-1]])
```



### 活动选择问题

[Activity Selection Problem | Greedy Algo-1 - GeeksforGeeks](https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/)

对结束时间进行排序，始终选择结束时间最早的活动

```python
def solve(start, end):

    se = list(zip(start, end))
    se.sort(key=lambda x: x[1])

    finish = -1
    cnt = 0
    for s, e in se:
        if s > finish:  # 第一个结束的活动必定选择
            finish = e
            cnt += 1
    return cnt
```


### 到达数组末尾的最小跳跃次数

[Jump Game - Minimum Jumps to Reach End - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/)

数组的每一位表示能跳到多远的距离。

判断是否能够跳到数组末尾

```python
def canJump(nums) -> bool:
	if len(nums) == 1: return True
	max_reach = 0
	for i in range(len(nums)):
		max_reach = max(max_reach, i + nums[i])

		if max_reach >= len(nums) - 1:
			return True
		
		if i == max_reach:   # 如果目前的点和最大能到达的点相同，证明无法跳到终点
			return False
	return False
```

计算跳跃所需的最小次数

```python
def solve(arr):
    n = len(arr)

    if arr[0] == 0:
        return -1
    
    max_reach = 0
    curr_reach = 0
    jumps = 0
    for i in range(n):
        # 当前点能到达的最大处
        max_reach = max(max_reach, i + arr[i])

        if max_reach >= n - 1:  
        # 如果在curr_reach 和max_reach之间存在一个点能跳到终点，那就直接跳过去
            return jumps + 1
        
        # 如果当前点和当前能到达的点相同，就更新当前能到达的点
        if i == curr_reach:
            # 如果当前点等于最大能到达的点，证明该点无法再前进
            if i == max_reach:
                return -1
            # 如果curr_reach 和max_reach之间不存在一个点能跳到终点，那就跳到当前的最大点
            curr_reach = max_reach  
            jumps += 1

    return -1
```


### 工作排序问题

[Job Sequencing Problem - GeeksforGeeks](https://www.geeksforgeeks.org/job-sequencing-problem/)

假设有一组工作、deadline 和利润，请问如何安排工作使得利润最大化，每个工作所需的时间为1。

划分一组时隙，每组时隙对应一个工作，将工作按照利润从大到小排好，遍历工作和 deadline，然后从截至日期向前搜索一个未安排工作的时隙

```python
def JobSequencing(id, deadline, profit):
	n = len(id)
	ans = [0, 0]
	
	jobs = list(zip(profit, deadline))
	
	# 按照利润从大到小排序
	jobs.sort(reverse=True)

	# 时隙
	result = [-1] * n
	for i in range(n):
		start = min(n, jobs[i][1]) - 1   # 获取完成的时间
		for j in range(start, -1, -1):
			if result[j] == -1:  # 发现一个未安排工作的时隙
				result[j] = i
				break

	for i in range(n):
		if result[i] != -1:
			ans[1] += jobs[result[i]][0]
			ans[0] += 1
	return ans
```


还有另一种方法，使用最小堆保存利润最大的若干个工作

```python
def JobSequencing(id, deadline, profit):
	n = len(id)
	ans = [0, 0]

	jobs = list(zip(profit, deadline))

	# 根据截至时间排序工作
	jobs.sort(key=lambda x: (x[1], -x[0]))

	# 最小堆
	pq = []

	for job in jobs:
		# deadline大于目前的工作数
		if job[1] > len(pq):
			heapq.heappush(pq, job[0])
		# 该工作需要提前完成，如果利润更高就需要替换
		elif pq and pq[0] < job[0]:
			heapq.heappop(pq)
			heapq.heappush(pq, job[0])

	while pq:
		ans[1] += heapq.heappop(pq)
		ans[0] += 1

	return ans
```



### 分组和差距最小

[Divide 1 to n into two groups with minimum sum difference - GeeksforGeeks](https://www.geeksforgeeks.org/divide-1-n-two-groups-minimum-sum-difference/)

先计算1到n之和，只考虑总和的一半，反向遍历，只需要把一半和分到一组即可

```python
def findTwoGroups(n):
    sum = n * (n+1) / 2

    groupSum = sum / 2

    group1 = []
    group2 = []

    for i in range(n, 0, -1):
        if groupSum - i >= 0:
            group1.append(i)
            groupSum -= i
        else:
            group2.append(i)
    print(group1)
    print(group2)
```


### 矩阵切分为正方形的最小切割

[Paper Cut into Minimum Number of Squares - GeeksforGeeks](https://www.geeksforgeeks.org/paper-cut-minimum-number-squares/)

这个问题比较复杂，但是选最大的开始切分这种方法是错的


### 给定位数和位之和的最小数

[Find smallest number with given number of digits and sum of digits - GeeksforGeeks](https://www.geeksforgeeks.org/find-smallest-number-with-given-number-of-digits-and-digit-sum/)

对于给定的各位之和 `s`，首先需要减1，保证最高位为1，然后不断用s减9，将 9 放到低位。

```python
def smallestNumber(s, d):
	if s > 9 * d:
		return -1
		
	res = ""
	s -= 1
	
	for i in range(d-1, 0, -1):
		if s > 9:
			s -= 9
			res += "9"
		else:
			res = f"{s}" + res
			s = 0
	
	if s != 0:
		res = f"{s+1}" + res
	else:
		res = "1" + res
	return res
```


### 最小化最大高度差

[Minimize the maximum difference between the heights - GeeksforGeeks](https://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/)

给定一组高度，允许对每个元素增加或减少k，计算改变后的最小最大高度差异

先对数组排序，然后遍历 i 从 1 到 n，在 i 之前加 k，在 i 和 i 之后减 k

```python
def getMinDiff(arr, k):
    n = len(arr)
    arr.sort()

    res = arr[n - 1] - arr[0]

    # 遍历所有的 i
    for i in range(1, len(arr)):
        # 如果 arr[i] < k，就不考虑在这之后减
        if arr[i] - k < 0:
            continue

        # 经过前半部分加k，后半部分减k后的最小值
        minH = min(arr[0] + k, arr[i] - k)

        # 最大值
        maxH = max(arr[i - 1] + k, arr[n - 1] - k)

        res = min(res, maxH - minH)
    
    return res
```


### 盛最多水的容器

[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/description/)

从一个整数数组中选择两个边界，采用贪心的思想，使用双指针分别指向开始和结尾，如果那一边比较小，就移动这条边。（因为如果移动较大那条边的话，情况不会变得更好，因为移动较大那条边会出现两种情况，一种情况是出现更大的一条边，但是由于较小的那一条边没动，所以盛水量只会减少，如果出现更小的一条边，盛水量就会更少。）

```python
def maxArea(height) -> int:
	n = len(height)
	l, r = 0, n - 1
	maxv = 0
	while l < r:
		nv = min(height[l], height[r]) * ( r - l)
		maxv = max(maxv, nv)

		if height[l] < height[r]:
			l += 1
		else:
			r -= 1
	return maxv 

```

## 动态规划

一般如果一个问题要求最大化或者最小化特定数量或者是计数，或是存在重叠子问题，都可以通过动态规划来解决。

动态规划问题重要的是状态和转移，建立状态之间的关系



### 数的组合

给定三个数 `{1,3,5}`，求其和为7的所有组合（允许相同的组合重复出现，如 1 1 3 和 3 1 1 视为不同的组合）

对于和为7的所有组合的数量的计算方式为

1、在所有和为 6 的组合上加 1
2、在所有和为 4 的组合上加 3
3、在所有和为 2 的组合上加 5

即有 `dp[n]=dp[n-1]+dp[n-2]`

```python
def solve(s):
    dp = [0] * (s + 1)
    dp[0] = 1

    for i in range(1, s+1):
        if 1 <= i < 3:
            dp[i] = dp[i - 1]
        elif 3 <= i < 5:
            dp[i] = dp[i-1]+dp[i-3]
        else:
            dp[i] = dp[i-1]+dp[i-3]+dp[i-5]
    return dp[s]
```



### 最小代价路径

[Min Cost Path - GeeksforGeeks](https://www.geeksforgeeks.org/min-cost-path-dp-6/)

自己的方法

```python
def solve_dp(cost):
    m = len(cost)
    n = len(cost[0])
    dirx = [1, 0, 1]
    diry = [0, 1, 1]
    def isSafe(x, y, m, n):
        return x <= m - 1 and y <= n - 1
    
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[m-1][n-1] = cost[m-1][n-1]
    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            if i == m - 1 and j == n-1:
                continue
            res = 1e3
            for k in range(3):
                nx = i + dirx[k]
                ny = j + diry[k]
                if isSafe(nx, ny, m, n):
                    res = min(res, cost[i][j]+dp[nx][ny])
            dp[i][j] = res
    return dp[0][0]
```


### 子集之和问题

[Dynamic Programming - Subset Sum Problem](https://www.geeksforgeeks.org/subset-sum-problem-dp-25/#using-recursion-o2n-time-and-on-space)

从一个集合中找到能够满足和为某个值的子集合。

使用回溯法，遍历集合，每次分为是否选择这个值作为子集合的元素

```python
def solve(arr, s):

    def _solve(arr, s, idx):

        if  s == 0:
            return True
        
        if idx >= len(arr) or s < 0:
            return False
        
        return _solve(arr, s - arr[idx], idx+1) or _solve(arr, s, idx+1)
    res = _solve(arr, s, 0)
    return res
```


动态规划，`dp[i][s]` 表示使用 `arr[0:i]` 能否找到一个子集和为 s，如果 s 为 0，那么必定可以。

```python
def solve_dp(arr, target):
    n = len(arr)
    dp = [[False for _ in range(target + 1)] for _ in range(n+1)]

    for i in range(n+1):
        dp[i][0] = True

    for idx in range(1, n+1):
        for s in range(1, target+1):
            if s >= arr[idx-1]:
	            # 选择 arr[idx-1] 或者不选择
                dp[idx][s] = dp[idx-1][s - arr[idx-1]] or dp[idx-1][s]
            else:
                dp[idx][s] = dp[idx-1][s]

    return dp[n][target]
```


### 一和零

[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/)

三维的背包问题

令 `dp[i][j][k]`表示在前 `i` 个字符串中，使用 `j` 个 0 和 `k` 个 1 的情况下最多的字符串数量

如果对于第 `i` 个字符串可以放下，则分成选择该字符串或者不选择该字符串，有 `dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-zero][k-ones]+1)`

如果第 `i` 个字符串不能放下，则有  `dp[i][j][k] = dp[i-1][j][k]`

```python
def findMaxForm(strs: List[str], m: int, n: int) -> int:
	l = len(strs)
	nums = []
	for s in strs:
		nums.append((s.count('0'), s.count('1')))
	dp = [[[0 for _ in range(n+1)] for _ in range(m+1)] for _ in range(l+1)]
	
	for i in range(1, l+1):
		for j in range(m+1):
			for k in range(n+1):
				if nums[i-1][0] <= j and nums[i-1][1]<=k:
					dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-nums[i-1][0]][k-nums[i-1][1]] + 1)
				else:
					dp[i][j][k] = dp[i-1][j][k]
	return dp[l][m][n]
```

### 最长回文子序列

[516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)

注意子序列可以不连续，只要维持原来的顺序即可

令 `dp[i][j]` 为 `[i, j]` 长度内最长回文子序列的长度，那么有如下结论

若 `s[i]==s[j]`，则有 `dp[i][j] = dp[i+1][j-1]+2`

若 `s[i]!=s[j]`，则有 `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`

注意初始化条件时，只能给 `0≤i≤j<n` 时的 `dp[i][j]` 赋值为1，其它都应该为0，由于 `i<j` 后面会计算，所以只需要给 `i=j` 时赋值为1 

```python
def longestPalindromeSubseq(s: str) -> int:
	n = len(s)
	dp = [[0 for _ in range(n)] for _ in range(n)]
	for i in range(n-1, -1, -1):
		dp[i][i] = 1
		for j in range(i+1, n):
			if s[i] == s[j]:
				dp[i][j] = dp[i+1][j-1] + 2
			else:
				dp[i][j] = max(dp[i+1][j], dp[i][j-1])
	return dp[0][-1]
```

还有另一种方法，将字符串翻转过来，求两个字符串之间的最长公共子序列。



### 乘积最大子数组

[152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/description/)

考虑最大子数组和问题，`dp[i] = max(dp[i-1]+num[i], num[i])`，此处也有类似的方程，不过由于乘积可以改变正负，所以需要考虑最大值和最小值（可能存在的负值）

```python
def maxProduct(nums: List[int]) -> int:
	maxv, minv, ans = nums[0], nums[0], nums[0]
	n = len(nums)
	for i in range(1, n):
		xv, nv = maxv, minv
		maxv = max(xv * nums[i], nums[i], nv * nums[i] )
		minv = min(nv * nums[i], nums[i], xv * nums[i])
		ans = max(maxv, ans)

	return ans
```


### 编辑距离

[Edit Distance - GeeksforGeeks](https://www.geeksforgeeks.org/edit-distance-dp-5/)

一个字符串允许对其进行修改、插入和删除这三个操作，请问最少需要多少次操作使得两个字符串相等。

用两个指针 i 和 j 分别指向 s1 和 s2，从 0开始，不需要对两个字符串进行修改

```python
def solve(s1, s2):

    def _solve(s1: str, s2, i, j):
        
        if i == len(s1):
            return len(s2) - j
        
        if j == len(s2):
            return len(s1) - i
        
        if s1[i] == s2[j]:
            return _solve(s1, s2, i+1, j+1)
        else:
            # _solve(s1, s2, i, j+1) 表示s1增加一个元素 s2[j]
            # _solve(s1, s2, i+1, j) 表示s1删除一个元素 s1[i]
            # _solve(s1, s2, i+1, j+1) 表示替换s1 中的一个值
            return 1 + min(_solve(s1, s2, i, j+1), _solve(s1, s2, i+1, j), 
                           _solve(s1, s2, i+1, j+1))

    res = _solve(s1, s2, 0, 0)
    return res
```


动态规划，需要注意初始化边界条件

```python
def solve_dp(s1, s2):
    n1 = len(s1)
    n2 = len(s2)
	# s1[0:i] 和 s2[0:j] 之间的编辑距离
    dp = [[0 for i in range(n2+1)] for _ in range(n1+1)]

    # 初始化边界条件
    for i in range(n1+1):
        dp[i][0] = i
    
    for j in range(n2+1):
        dp[0][j] = j

    for i in range(1, n1+1):
        for j in range(1, n2+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])
    return dp[n1][n2]
```

### 切木头问题

[Rod Cutting - GeeksforGeeks](https://www.geeksforgeeks.org/cutting-a-rod-dp-13/)

给定一个从1 开始索引的数组，数组的每一项代表该长度的木头可以卖出的价格，求如何切分使得利润最大，数组的长度即为木头的长度

自己的解法（即使用了memo也会超时）

```python
def solve(price):
    n = len(price)

    def _solve(price, s, idx):
        if s < idx:
            return 0
        
        res = max(price[idx-1] + _solve(price, s - idx, idx), _solve(price, s, idx+1))
        return res
    
    res = _solve(price, n, 1)
    return res
```

官方解法（将memo的大小降低到 O(n)）

在迭代函数中设置一个循环，这样可以将memo的大小降到 `O(n)`，减少内存访问

```python
def solve2(price):
    n = len(price)

    def _solve(price, s):
        if s == 0:
            return 0
        res = 0
        for j in range(1, s + 1):
            res = max(res, price[j-1] + _solve(price, s-j))
        return res
    
    res = _solve(price, n)
    return res
```

动态规划

```python
def cutRod(price):
	n = len(price)

	# dp[i] 表示木头长度为 i 时的利润 
	dp = [0] * (n+1)

	for i in range(1, n+1):
		res = 0
		for j in range(1, i+1):
			res = max(res, price[j-1] + dp[i - j])
		dp[i] = res
	return dp[n]
```


### 爬楼梯问题

[Climbing stairs to reach the top - GeeksforGeeks](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)

最基础的爬楼梯问题为 `s[n] = s[n-1]+s[n-2]`

带权重的爬楼问题 [Minimum cost to reach the top of the floor by climbing stairs - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-cost-to-reach-the-top-of-the-floor-by-climbing-stairs/)

`s[n] = cost[n] + min(s[n-1), s[n-2])`

```python
def solve(cost):
    n = len(cost)
    dp = [0] * (n+2)
    dp[0] = 0
    dp[1] = cost[0]
    # dp[2] = cost[1]
    for i in range(2, n+1):
        dp[i] = cost[i-1] + min(dp[i-1], dp[i-2])
    # 获取爬到第n个楼梯和第n-1个楼梯时的代价
    return min(dp[n], dp[n-1])
```


### 硬币之和问题

[Coin Change - Count Ways to Make Sum - GeeksforGeeks](https://www.geeksforgeeks.org/coin-change-dp-7/)


```python
def count_dp(coins, sum):
    n1 = len(coins) + 1
    dp = [[0  for _ in range(sum + 1)] for _ in range(n1)]

    # sum 为 0 有一种方法（什么都不取）
    for i in range(n1):
        dp[i][0] = 1
    
    for i in range(1, n1):
        for j in range(1, sum+1):
	        # 不使用当前硬币的方法数
            dp[i][j] = dp[i-1][j]
            # 使用当前硬币的方法数
            if j - coins[i-1] >= 0:
                dp[i][j] += dp[i][j - coins[i-1]]
    
    return dp[len(coins)][sum]
```

[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/description/)

该问题还可以优化空间

```python
def change(amount: int, coins: List[int]) -> int:
	dp = [0] * (amount + 1)
	dp[0] = 1
	for c in coins:
		for i in range(c, amount+1):
			dp[i] += dp[i-c]
	return dp[-1]
```

注意需要在外侧循环中迭代硬币，否则会出现重复的方案。先迭代硬币，相当于默认在该方案中包含了该硬币，这样可以避免重复的方案。

将内外循环反过来，就能找到下标不同的方案了。


### 最长公共子序列

[Longest Common Subsequence (LCS) - GeeksforGeeks](https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/)

令 `dp[i][j]` 为 `s1[...i]` 和 `s2[...j]` 之间的最长公共子序列的长度，如果 `s1[i]==s2[j]`，那么加1，否则取较大值

```python
def lcs_dp(s1, s2):
    n1 = len(s1)
    n2 = len(s2)
    dp = [[0 for _ in range(n2+1)] for _ in range(n1 + 1)]

    for i in range(1, n1+1, 1):
        for j in range(1, n2+1, 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[n1][n2]
```


上面的dp还可以使用一个一维数组来替代，节约空间

```python
def lcs_dp2(s1, s2):
    n1 = len(s1)
    n2 = len(s2)
    dp = [0] * (n2 + 1)
	for i in range(1, n1+1):
        prev = dp[0]
        for j in range(1, n2+1):
            temp = dp[j]
            if s1[i-1] == s2[j-1]:
                dp[j] = 1 + prev
            else:
                dp[j] = max(dp[j-1], dp[j])
            prev = temp
    return dp[n2]
```

最长公共子序列会以其它形式出现，如不相交的连线 [1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/description/)

还有让字符串成为回文串的最少插入次数 [1312. 让字符串成为回文串的最少插入次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/) 该问题可以改为找到原字符串的最长回文子字符串，或者是原字符串和原字符串的逆转字符串的最长公共子序列。


### 两个字符串的最小ASCII删除和

[712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/)

参考最长公共子字符串的求法

`dp[i][j]` 为 `s1[0..i]` 和 `s2[0..j]` 之间的删除和

```python
def minimumDeleteSum(s1: str, s2: str) -> int:
	res = []
	n1 = len(s1)
	n2 = len(s2)
	dp = [[0 for i in range(n2+1)] for _ in range(n1+1)]
	res = [[0 for i in range(n2+1)] for _ in range(n1+1)]

	for i in range(1, n2+1):
		dp[0][i] = dp[0][i-1] + ord(s2[i-1])
	for i in range(1, n1+1):
		dp[i][0] = dp[i-1][0] + ord(s1[i-1])
	
	for i in range(1, n1+1):
		for j in range(1, n2+1):
			if s1[i-1] == s2[j-1]:
				dp[i][j] = dp[i-1][j-1]
			else:
			# 选择删除s1中第i-1个字符，或者删除 s2 中第j-1个字符
				dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
	return dp[n1][n2]
```


### 最大完美切分

[Maximize the number of segments of length x, y and z - GeeksforGeeks](https://www.geeksforgeeks.org/maximize-the-number-of-segments-of-length-p-q-and-r/)

给定一段绳子，将其切分为 x, y, z 的组合，不能有剩余。注意必须要切分为 x, y, z 这种形式，求切分的最大数量


```python
def segment(n, x, y, z):

    dp = [0] * (n + 1)

    for i in range(1, n+1):
        dp[i] = 0
        if i >= x and dp[i-x] != -1:
            dp[i] = max(dp[i], 1 + dp[i-x])
        
        if i >= y and dp[i-y] != -1:
            dp[i] = max(dp[i], 1 + dp[i-y])
        
        if i >= z and dp[i-z] != -1:
            dp[i] = max(dp[i], 1 + dp[i-z])
        
        # 如果该值不存在切分，就不要考虑这个值了（剩余部分不能再被切分）
        if dp[i] == 0:
            dp[i] = -1

    return dp[n]
```


### 包括N个值的BST的数量

[Number of Unique BST with N Keys - GeeksforGeeks](https://www.geeksforgeeks.org/number-of-unique-bst-with-a-given-key-dynamic-programming/)

一个BST有N个值，为 1到 n，请问有多少种可能性

假设以第 i 个值作为根节点，那么 1 到 i-1 为左子树，i + 1 到 n 为右子树，设左右子树的可能性分别为 `C(i-1)` 和 `C(n-i)`，则第 i 个值作为根节点时，可能性为 `C(i-1) * C(n-i)`，再进行求和即可

$$
C(n) = \sum_{1}^n C(i-1)*C(n-i)
$$

### 有效括号的数量

[Find the number of valid parentheses expressions of given length - GeeksforGeeks](https://www.geeksforgeeks.org/find-number-valid-parentheses-expressions-given-length/#using-recursion-o2-n-time-and-o1-space)

可以参考回溯问题中生成平衡括号问题的解法，只需要在符合条件时加1即可

有效括号问题可以看成是卡特兰数问题，左括号和右括号可以看成是出栈入栈，只有左括号大于右括号，才能加上右括号


### 最长有效括号

[32. 最长有效括号 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-valid-parentheses/description/)

在一个只有 `(` 和 `)` 的字符串中，求最长的有效连续括号的长度

动态规划方法，考虑以第 `i` 个字符结尾的字符串的最长有效括号的长度，首先必须满足第 i 个字符为右括号。此时分为两种情况，第 `i-1` 个字符为 `(` 和 第 `i-1` 个字符为 `)`。

如果第 `i-1` 个字符为 `(`，则有 `dp[i] = dp[i-2]+2`

如果第 `i-1` 个字符为 `)`，这时候需要判断 `dp[i-dp[i-1]-1]` 是否为 `(`，则有 `dp[i] = dp[i-1] + dp[i-dp[i-1]-2]+2`，其中 `dp[i-dp[i-1]-1]` 为 `dp[i-1]` 对称过去的字符串

```python
def solve(s):
    max_len = 0
    n = len(s)
    dp = [0] * n
    for i in range(1, n):
        if s[i] == ")":
            if s[i-1] == "(":
                if i - 2 >= 0:
                    dp[i] = dp[i-2] + 2
                else:
                    dp[i] = 2
            else:
                if i - dp[i-1] - 1 >= 0 and s[i-dp[i-1]-1] == "(":
                    if i - dp[i-1] - 2 >= 0:
                        dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2
                    else:
                        dp[i] = dp[i-1] + 2
        max_len = max(max_len, dp[i])
    return max_len
```


用栈保存下标，始终保持栈底元素为当前遍历过的元素的最后一个没有被匹配的右括号的下标，具体来说，保存所有 `(` 的下标，同时遇到 `)`，先弹出栈顶元素，表示匹配了当前右括号，如果栈为空，表明没有匹配，将其下标放入栈中，即没有被匹配的有括号的下标；如果栈不为空，当前有括号的下标减去栈顶元素即为以该右括号为结尾的最长有效括号的长度。

```python
def solve_s(s):
    max_len = 0
    n = len(s)
    stack = []
    stack.append(-1)     # 处理第一个括号为右括号时的情况

    for i in range(n):
        if s[i] == "(":
            stack.append(i)
        else:
            stack.pop()   # 匹配了一个左括号
            if len(stack) == 0:  # 出现失配
                stack.append(i)  # 未匹配的右括号
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len
```



### 卡特兰数

[Program for nth Catalan Number - GeeksforGeeks](https://www.geeksforgeeks.org/program-nth-catalan-number/)

下面介绍一下卡特兰数

第 n 个卡特兰数的定义为

$$
{H_n} = \left\{ \matrix{
  \sum\nolimits_{i = 1}^n {{H_{i - 1}}{H_{n - i}}\quad n \ge 2,n \in {N_ + }}  \hfill \cr 
  1\quad n = 0,1 \hfill \cr}  \right.
$$

这个递推关系的解为

$$
{H_n} = {{C_{2n}^n} \over {n + 1}}\quad n \ge 2,n \in {N_ + }
$$
还有两个常见公式

$$
{H_n} = {{{H_{n - 1}}\left( {4n - 2} \right)} \over {n + 1}}\quad {H_n} = \left( \matrix{
  2n \hfill \cr 
  n \hfill \cr}  \right) - \left( \matrix{
  2n \hfill \cr 
  n - 1 \hfill \cr}  \right)
$$


卡特兰数可以用于计算

1、合法括号匹配数

2、含有k个值的可能二叉搜索树

3、从 （0，0）走到 （n，n），可以向上走，向右走，但是向右走的次数不能少于向上走的次数，一共有多少种走法

4、多边形被分割为若干个三角形 [Number of ways of Triangulation for a Polygon - GeeksforGeeks](https://www.geeksforgeeks.org/number-of-ways-a-convex-polygon-of-n2-sides-can-split-into-triangles-by-connecting-vertices/)
（该问题相当于先画一条线，将大多边形分为两个小多边形，然后分别求这两个小多边形的分割次数）


假设有一个栈的进栈顺序为1，2，3，...，n，求有多少种出栈顺序

假设第一个出栈的数 k 将 1 - n 的序列分成两个序列，其中一个序列为 1 到 k-1，另一个序列为 k+1 到 n，假设 1 到 k - 1 有 C(k-1) 种可能性，k+1 到 n 有 C(n-k) 种可能性，则对于第一个出栈的数 k 有 C(k-1) * C(n-k) 种可能性。将所有的可能性相加可得

$$
C(n) = \sum_{1}^n C(k-1)*C(n-k)
$$

当 n 为 0 时，设置为1，当 n 为 1 时，自然只有1 种可能。



### 统计可能的解码序列

[Count Possible Decodings of a given Digit Sequence - GeeksforGeeks](https://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/)

在递归过程中，如果当前位不为 `0`，则问题变为从下一位开始有多少种可能

同时如果两位在10和26之间，同样也是一种可能

若当前位为 1 且下一位为 5，则可能的分组为 `{.., 1, ...}` 和 `{..., 15, ...}` 这两种

```python
def solve(digits):
    def _solve(digits, idx):
        if idx >= len(digits):
            return 1
        ways = 0
        # 如果当前点不为0，则当前点可以作为一种可能
        if digits[idx] != "0":
            ways = _solve(digits, idx+1)
        if idx + 1 < len(digits) and (digits[idx] == '1' and digits[idx+1] <= '9') \
        or (digits[idx] == '2' and digits[idx+1] <= '6'):
            ways += _solve(digits, idx+2)
        
        return ways
```

动态规划

```python
def solve_dp(digits):
    n = len(digits)
    dp = [0] * (n + 1)
    # 空字符串有一个合法的
    dp[n] = 1
    
    for i in range(n-1, -1, -1):
        if digits[i] != '0':
            dp[i] = dp[i+1]   # 将第i个字符单独放置
	    # 将 i 和 i + 1 这两个字符合在一起
        if i + 1 < n and (digits[i] == '1' and digits[i+1] <= '9') \
        or (digits[i] == '2' and digits[i+1] <= '6'):
            dp[i] += dp[i+2]
    return dp[0]
```

从前到后，并且优化空间

```python
def numDecodings(s: str) -> int:
	n = len(s)
	if s[0] == "0": return 0
	f0 = 1  # dp[i-2]
	f1 = 1  # dp[i-1]
	for i in range(1, n+1):
		f = 0
		if s[i-1] != "0":  # 当前的字母独立分组
			f = f1
		if (s[i-2] > "2" and s[i-1] == "0") or (s[i-2] == "0" and s[i-1] == "0"):
			return 0
		# 当前字母和前一个字母分在一起
		if i > 1 and (s[i-2] == "1" or (s[i-2] == "2" and "0" <= s[i-1] <= "6")):
			f += f0   
		f0, f1 = f1, f
	return f1
```


### k 次置换的数量

[Number of permutation with K inversions - GeeksforGeeks](https://www.geeksforgeeks.org/number-of-permutation-with-k-inversions/)


### 四个键按出最多的 A

[How to print maximum number of A's using given four keys - GeeksforGeeks](https://www.geeksforgeeks.org/how-to-print-maximum-number-of-a-using-given-four-keys/)

基本思路是先按A，此后只有按一次全选和复制，按多次粘贴这种操作，关键是找到从什么时候开始全部按粘贴

```python
def solve(n):
    if n <= 6:
        return n
    res = 0
    for i in range(n-3, 0, -1):
        # 按了 n - i - 1 次粘贴，之前按了 i 次 A
        cnt = (n - i - 1) * solve(i)
        res = max(res, cnt)
    return res
```


### 水溢出问题

[Program to find amount of water in a given glass - GeeksforGeeks](https://www.geeksforgeeks.org/find-water-in-a-glass/)

许多水杯堆成一个帕斯卡三角，向最上方的水杯倒入k单位的水，如果溢出只会向其左右两边溢出，求第R行第C列的杯子的水量

```python
def solve(k, r, c):

    dp = [[0 for i in range(r+1)] for _ in range(r+1)]
    # 初始情况下最上面的杯子装了k单位水
    dp[0][0] = k

    for i in range(r):  # 然后开始逐层溢出
        for j in range(i+1):
            # i,j 位置的杯子溢出的水的单位
            excess = max(0.0, dp[i][j] - 1.0)

            if excess > 0:
                dp[i][j] = 1.0
                dp[i+1][j] += excess / 2.0   # 左右两个杯子所接收的水的单位
                dp[i+1][j+1] += excess / 2.0
    return min(1.0, dp[r-1][c-1])
```



### 最大增长子序列

[Longest Increasing Subsequence (LIS) - GeeksforGeeks](https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/)

[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

对于每一位元素，都检查之前的元素，如果比之前的元素`arr[j]`大，就取`1+arr[j]`

`dp[i]` 表示第 i 个点大于之前的点的数量，即包含第 i 个点的最大增长子序列

```python
def solve(arr):
    n = len(arr)
    dp = [1] * n
    dp[0] = 1
    maxv = 1
    for i in range(n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], 1+dp[j])
                maxv = max(dp[i], maxv)
    return maxv
```


另一种解法是基于贪心算法，首先如果想求最长子序列，那么该子序列需要增长的慢一些。维护一个栈，将数组中的数据塞入栈中，如果数据大于栈顶元素，那就直接塞入，否则在栈中进行二分查找，找到小于该值的下界，然后再赋值。

```python
from bisect import bisect_left
def solve(nums):
    stack = []
    n = len(nums)
    stack.append(nums[0])
    for i in range(1, n):
        if nums[i] > stack[-1]:
            stack.append(nums[i])
        else:
            lb = bisect_left(stack, nums[i])  # 找到小于等于nums[i]的位置
            stack[lb] = nums[i]
    return len(stack)
```

如果不要求严格递增，则为

```python
from bisect import bisect_right
def solve(nums):
    stack = []
    n = len(nums)
    stack.append(nums[0])
    for i in range(1, n):
        if nums[i] >= stack[-1]:
            stack.append(nums[i])
        else:
            lb = bisect_right(stack, nums[i])  # 找到大于nums[i]的位置
            stack[lb] = nums[i]
    return len(stack)
```

如果需要得到每个点对应的最长增长子序列的长度，则如下所示

```python
from bisect import bisect_left
def solve(nums):
    stack = []
    n = len(nums)
    stack.append(nums[0])
    dp = [1]
    for i in range(1, n):
        if nums[i] > stack[-1]:
            stack.append(nums[i])
            dp.append(len(stack))
        else:
            lb = bisect_left(stack, nums[i])  # 找到更小的位置
	        dp.append(lb+1)
            stack[lb] = nums[i]
    return len(stack)
```


### 最长定差子序列

[1218. 最长定差子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/)

用一个字典作为dp，从前向后遍历，`dp[v]=dp[v-diff]+1`

```python
def longestSubsequence(arr, difference: int) -> int:
	from collections import defaultdict
	dp = defaultdict(int)
	for v in arr:
		dp[v] = dp[v-difference] + 1
	
	return max(dp.values())
```


### 俄罗斯套娃信封问题

[354. 俄罗斯套娃信封问题 - 力扣（LeetCode）](https://leetcode.cn/problems/russian-doll-envelopes/description/)

给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。


首先需要对数组进行排序，排序的原则是首个元素按照大小顺序排列，第二个元素反向排列，排好之后。为了保证不超时，使用二分查找的方法根据第二个元素找到符合要求的子序列

```python
def maxEnvelopes(envelopes: List[List[int]]) -> int:
	from bisect import bisect_left

	envelopes.sort(key = lambda x: (x[0], -x[1]))

	n = len(envelopes)
	stack = [envelopes[0][1]]
	for i in range(1, n):
		if stack[-1] < envelopes[i][1]:
			stack.append(envelopes[i][1])
		else:
			idx = bisect_left(stack, envelopes[i][1])  # 找到更小的元素对应的位置
			stack[idx] = envelopes[i][1]
	return len(stack)
```



### 最长递增子序列的个数

[673. 最长递增子序列的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/)

用一个数组统计当前最长递增子序列的个数

```python
def findNumberOfLIS(nums: List[int]) -> int:
	from collections import defaultdict
	n = len(nums)
	dp = [1] * n
	cnt = [0] * n
	maxv = 1
	ans = 0
	for i in range(n):
		cnt[i] = 1
		for j in range(i):
			if nums[j] < nums[i]:
				if dp[j] + 1 > dp[i]:  # 最长子序列需要更新
					dp[i] = dp[j] + 1
					cnt[i] = cnt[j]
				elif dp[j] + 1 == dp[i]:  # 又出现了一组长度为dp[i]的递增子序列
					cnt[i] += cnt[j]
		# 在之前的部分完成遍历后再更新结果
		if dp[i] > maxv:  
			maxv = dp[i]
			ans = cnt[i]
		elif dp[i] == maxv:
			ans += cnt[i]
	return ans
```



### 最大可除子集

[Largest divisible subset in array - GeeksforGeeks](https://www.geeksforgeeks.org/largest-divisible-subset-array/)


### 带权重的工作规划

[Weighted Job Scheduling - GeeksforGeeks](https://www.geeksforgeeks.org/weighted-job-scheduling/)

递归解法如下，先对工作按照起始时间排序，重点是传入last来记录最后完成的时间

```python
def solve(jobs):
    def _solve(jobs, idx, last):
        if idx == len(jobs):
            return 0
        res = _solve(jobs, idx+1, last)
        if jobs[idx][0] >= last:
            res = max(res, jobs[idx][2] + _solve(jobs, idx+1, jobs[idx][1]))
        return res

    jobs.sort()
    ans = _solve(jobs, 0, -1)
```

在使用memo来减小时间复杂度时，需要注意如果将memo设置为二维矩阵，会耗费大量存储空间，考虑如下的实现方法，只在能选择工作时返回memo中存储的值

```python
def maxProfitRecur(jobs, ind, last, memo):
    if ind == len(jobs):
        return 0

    # if the job can be taken
    if jobs[ind][0] >= last:

        # if the value is not calculated
        if memo[ind] == -1:

            # take the job
            memo[ind] = jobs[ind][2] + \
                maxProfitRecur(jobs, ind + 1, jobs[ind][1], memo)

            # leave the job and find max
            memo[ind] = max(memo[ind],
                      maxProfitRecur(jobs, ind + 1, last, memo))

        return memo[ind]

    # if the job can't be taken
    return maxProfitRecur(jobs, ind + 1, last, memo)
    
def maxProfit(jobs):
    # Sort the jobs based on start time
    jobs.sort()
    memo = [-1] * len(jobs)
    return maxProfitRecur(jobs, 0, -1, memo)
```

动态规划的方法如下，将工作按照起始时间排序后，从后向前遍历，`dp[i]` 表示 `i` 至 `n-1` 范围内的最大利润，用一个指针 `j` 遍历 `i+1` 到 `n-1`，如果第 `j` 个工作的起始时间大于第 i 个工作的结束时间，就将 `dp[i] = profit[i]+dp[j]`

```python
def solve_dp(jobs):
    n = len(jobs)
    dp = [0] * n
    res = 0
    for i in range(n-1, -1, -1):
        dp[i] = jobs[i][2]  # 选择该工作
        for j in range(i+1, n):
	         # 第 j 个工作的起始时间大于第i个工作的结束时间
            if jobs[j][0] >= jobs[i][1]: 
                dp[i] = max(dp[i], dp[j] + jobs[i][2])
        res = max(res, dp[i])
    return res
```


上述方法还可以优化为使用二分查找搜索满足要求的工作 `j`


### 正则表达式匹配

[Regular Expression Matching - GeeksforGeeks](https://www.geeksforgeeks.org/implementing-regular-expression-matching/)

[10. 正则表达式匹配 - 力扣（LeetCode）](https://leetcode.cn/problems/regular-expression-matching/description/)

判断一个字符串是否满足一个模式

令 `dp[i][j]` 表示`s[:i]` 和 `p[:j]` 之间是否能匹配。初始条件：两个字符串都为空能匹配。

对于模式字符串，如果遇到 `*`，那么分为两种情况，一种是不匹配之前的字符，即判断 `s[:i]` 和 `p[:j-2]` 之间是否匹配：`dp[i][j] |= dp[i][j-2]`

另一种情况是判断字符串是否和模式字符串之前的字符匹配：如果匹配有`dp[i][j] != dp[i-1][j]`

如果遇到`.`，直接匹配下一个字符，`dp[i][j] |= dp[i-1][j-1]`

如果遇到字母，判断两个字母是否相等，`dp[i][j] != dp[i-1][j-1]`

```python
def isMatch(s: str, p: str) -> bool:
	m = len(s)
	n = len(p)

	dp = [[False for _ in range(n+1)] for _ in range(m+1)]
	dp[0][0] = True  # 两个字符串为空

	def match(i, j):
		if i == 0:  # 如果 s 为空字符串，并且模式还需要匹配，则返回False
			return False
		if p[j-1] == ".":  # 如果字符为 . ，直接匹配
			return True
		return s[i-1] == p[j-1]

	for i in range(m+1):
		for j in range(1, n+1):
			if p[j-1] == "*":
				dp[i][j] |= dp[i][j-2]
				if match(i, j-1):
					dp[i][j] |= dp[i-1][j]
			else:
				if match(i, j):
					dp[i][j] |= dp[i-1][j-1]
	return dp[m][n]
```


另外一种变种问题：[44. 通配符匹配 - 力扣（LeetCode）](https://leetcode.cn/problems/wildcard-matching/description/)

该问题中的 `*` 可以匹配任意子序列（包括空序列），在初始化的时候需要注意当模式字符串中前面若干个元素为 `*`时，`dp[0][j]` 为 True。

若第 j 个元素为 `*` 时，则可以匹配空序列 `dp[i][j-1]`，或者匹配任意序列 `dp[i-1][j]`，即

`dp[i][j] = dp[i][j-1] | dp[i-1][j]`

```python
def isMatch(s: str, p: str) -> bool:
	m = len(s)
	n = len(p)

	dp = [[False for _ in range(n+1)] for _ in range(m+1)]

	dp[0][0] = True

	for j in range(1, n+1):
		if p[j-1] == "*":
			dp[0][j] = True
		else:
			break

	def match(i, j):
		if i == 0: return False
		if p[j-1] == "?": return True
		return s[i-1] == p[j-1]
	last_i = 0
	for i in range(m+1):
		for j in range(1, n+1):
			if p[j-1] == "*":
				dp[i][j] = dp[i][j-1] | dp[i-1][j]
			else:
				if match(i, j):
					dp[i][j] |= dp[i-1][j-1]
	return dp[m][n]
```




### 形成回文字符串的最小插入次数

[Minimum insertions to form a palindrome - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-insertions-to-form-a-palindrome-dp-28/)

采用递归解法

```python
def solve(s):
    def _solve(s, l, h):
        if l > h:
            return float("inf")
        if l == h:
            return 0
        if l == h - 1:
            return 0 if s[l] == s[h] else 1
        
        if s[l] == s[h]:
            return _solve(s, l+1, h-1)
        
        else:
            return min(_solve(s, l+1, h), _solve(s, l, h-1)) + 1
    
    res = _solve(s, 0, len(s)-1)
    return res
```

采用动态规划的解法

```python
def solve_dp(s):
    n = len(s)
    dp = [[n for i in range(n)] for _ in range(n)]
	# 初始化
    for i in range(n):
        dp[i][i] = 0
        if i + 1 < n:
            dp[i][i+1] = 0 if s[i] == s[i+1] else 1
        if i - 1 >= 0:
            dp[i-1][i] = 0 if s[i-1] == s[i] else 1

    for i in range(n-1, -1, -1):
        for j in range(i+2, n):   # 长度从 2 开始
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1]
            else:
                dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1
    
    return dp[0][n-1]
```


### 鸡蛋滚落测试

[Egg Dropping Puzzle | DP-11 - GeeksforGeeks](https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/)

用n个鸡蛋测试k个台阶，求找到会摔碎的台阶的最小步骤数

当鸡蛋从台阶 x 上滚落时，会出现两种情况

1、会摔碎：用一个鸡蛋检查比 x 小的台阶
2、不会摔碎：用一个鸡蛋检查比 x 大的台阶

首先主要注意的是如果只有一颗鸡蛋，那么需要 k 个步骤才能检查出来

```python
def solve(n, k):
    def _solve(n, k):
        if k == 0 or k == 1:
            return k
        # 一个鸡蛋直接返回 k
        if n == 1:
            return k

        cnt = k
        # 从 1 到 k 个台阶开始尝试
        for i in range(1, k+1):
	        # _solve(n-1, i-1) 摔碎了一个鸡蛋，用剩下的n-1个鸡蛋测试比 i 小的台阶
	        # 没摔碎，用n个鸡蛋测试比 i 大的台阶
            cnt = min(cnt, 1 + max(_solve(n-1, i-1), _solve(n, k-i)))
        return cnt
    res = _solve(n, k,)
    return res
```

若有两个鸡蛋用于测试时，则有如下测法，将一个鸡蛋每隔 x 个台阶滚一次，如果碎了，就测试剩下的x-1个台阶，这样测试次数为 `k / x + x - 1`





### 回文子字符串计数

[Palindrome Substrings Count - GeeksforGeeks](https://www.geeksforgeeks.org/count-palindrome-sub-strings-string/)

统计所有长度大于1的回文子字符串，这里需要生成所有长度大于1的子字符串，在判断子字符串是否回文时可以采用memo的方法

```python
def solve(s):
    n = len(s)
    memo = [[False for _ in range(n)] for _ in range(n)]

    for i in range(n):
        memo[i][i] = True

    # 先初始化回文矩阵
    for i in range(n-1, -1, -1):
        for j in range(i+1, n):
            if s[i] == s[j]:
                if i + 1 <= j - 1:
                    memo[i][j] = memo[i+1][j-1]
                else:
                    memo[i][j] = True
            else:
                memo[i][j] = False

    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if memo[i][j]:
                cnt += 1
    return cnt
```


### 游戏的最优策略

[Optimal Strategy for a Game - GeeksforGeeks](https://www.geeksforgeeks.org/optimal-strategy-for-a-game-dp-31/)

一组不同面值的硬币，两名用户取硬币，每一回合只能取一次硬币，求先出手的玩家能获得的最大数量硬币

```python
def solve(arr):
    def _solve(arr, l, r):
        if l > r:
            return 0

        # 玩家选择最开始的硬币，对手会选择使我们利润最小的硬币
        cnt1 = arr[l] + min(_solve(arr, l+1, r-1), _solve(arr, l+2, r))
       
        # 玩家选择最后面的硬币
        cnt2 = arr[r] + min(_solve(arr, l, r-2), _solve(arr, l+1, r-1))

        return max(cnt1, cnt2)
    res = _solve(arr, 0, len(arr)-1)
    return res
```


### 画家分割问题

[The Painter's Partition Problem - GeeksforGeeks](https://www.geeksforgeeks.org/painters-partition-problem/)

该问题相当于求将数组顺序分成若干份，并求出每种分法中的最大值和最小值

```python
def minimizeTime(curr, n, arr, k):
    if curr >= n:
        return 0
    # 没有画家，不可能实现
    if k == 0:
        return float('inf')  
        
    # 当前画家需要画的
    currSum = 0  
    
    res = float('inf')  

    # 分割剩下来的板子
    for i in range(curr, n):
        currSum += arr[i]

	    # 找到分配 arr[curr..i] 给当前画家时的最大时间（指后面的画家画的时间）
        remTime = minimizeTime(i + 1, n, arr, k - 1)
        maxTime = max(currSum, remTime)

        # 更新结果
        res = min(res, maxTime)

    return res
```


### 美丽子集的数目

[2597. 美丽子集的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/the-number-of-beautiful-subsets/description/)

在一个集合中找到子集，子集中的所有元素之间差距不等于k，求出所有不同的子集数量（索引不同即认为不同）

如果集合中的数比较少的话，可以直接暴力求解，先通过二进制mask的方式求出所有可能的子集，然后验证每个子集是否可行。这种方法耗时很长

```python
def beautifulSubsets(nums, k: int) -> int:
	n = len(nums)
	cnt = 0
	for mask in range(1, 1 << n):
		arr = [nums[i] for i in range(len(nums)) if (mask >> i) & 1==1]
		flag = False
		for i in range(len(arr)):
			for j in range(i+1, len(arr)):
				if abs(arr[i] - arr[j]) == k:
					flag = True
					break
			if flag:
				break
		if not flag:
			cnt += 1
	return cnt
```


使用回溯法，同时用一个字典保存可以选择的元素

```python
def beautifulSubsets(self, nums: List[int], k: int) -> int:
	n = len(nums)
	self.ans = 0
	cnt = defaultdict(int)  # 保存当前选择的元素
	def dfs(idx):
		if idx == n:
			return
		dfs(idx+1) # 不选择当前元素
		
		# 选择当前元素，排除差距相差k的元素
		if cnt[nums[idx] - k] == 0 and cnt[nums[idx]+k] == 0:
			cnt[nums[idx]] += 1
			dfs(idx+1)
			self.ans += 1 # 可以找到一个子集合
			cnt[nums[idx]] -= 1
		
	dfs(0)
	return self.ans
```


最后介绍一下动态规划的方法

首先将每个数根据模 k 的结果进行分组，如果模k不同余，那么一定不相差k，将这些分组好之后，每组之间不会相差k，所以只需要考虑组内元素的选择方法，然后将这些组的选择方法相乘即可。

对于一个组内的元素，将其排序去重后，只需要考虑相邻元素不能同时选取，令 `f(i,0)` 表示第 `i` 个元素不加入子集，`f(i,1)` 表示第`i`个元素加入子集，则有 

当不选择第 `i` 个元素：`f(i, 0)=f(i-1, 0)+f(i-1,1)`

当选择第 `i` 个元素，由于只要索引不同，就认为是不同的子集，所以如果第 `i` 个元素有 $c_i$个相同的值，那么可选择的子集合数为 $2^{c_i}-1$

如果第 `i` 个元素和第 `i - 1` 个元素相差不为 k，则有

$$
f(i,1) = \left( {f(i - 1,0) + f(i - 1,1)} \right)*\left( {{2^{{c_i}}} - 1} \right)
$$

反之如果相差为 k，则有

$$
f(i,1) = f(i - 1,0)*\left( {{2^{{c_i}}} - 1} \right)
$$
```python
def beautifulSubsetsdp(nums, k: int) -> int:
	from collections import defaultdict
	n = len(nums)
	ans = 1
	groups = defaultdict(list)
	cnt = defaultdict(int)
	for n in nums:
		rem = n % k
		if n not in groups[rem]:
			groups[n % k].append(n)
		cnt[n] += 1
	for key in groups.keys():
		arr = sorted(groups[key])
		n1 = len(arr)
		dp = [[0, 0] for _ in range(n1)]
		dp[0][0] = 1  # 空集合
		dp[0][1] = 2 ** (cnt[arr[0]]) - 1 # 选择第一个元素
		for i in range(1, n1):
			dp[i][0] = dp[i-1][0] + dp[i-1][1]
			if arr[i] - arr[i-1] == k:
				dp[i][1] = dp[i-1][0] * (2 ** cnt[arr[i]] - 1)
			else:
				dp[i][1] = (dp[i-1][0] + dp[i-1][1]) * (2 ** cnt[arr[i]] - 1)
		ans *= dp[n1-1][1] + dp[n1-1][0]

	return ans - 1   # 去除空集
```


### 删除并获得点数

[740. 删除并获得点数 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-and-earn/description/)

给定一个整数数组，可以对其中的一个元素 `num[i]` 删除，并且获得 `num[i]` 点分数，但是同时会默认删除 `num[i]-1` 和 `num[i]+1`，默认删除不会获得分数，请问怎么操作能使获得的分数最大。

该问题可以转换为打家劫舍问题，即删除了 `num[i]` 就不能删除 `num[i]` 两边的元素，因此，可以先找到原数组的最大值，然后计算每个值在 `num`中出现的总和，这样形成的新数组可以按照打家劫舍的方法求解

```python
def deleteAndEarn(nums) -> int:
	maxv = max(nums)

	arrs = [0] * (maxv+1)
	for n in nums:
		arrs[n] += n
	# 打家劫舍问题的求解方法
	f0 = arrs[0]
	f1 = max(arrs[0], arrs[1])
	for i in range(2, len(arrs)):
		f2 = max(f1, f0 + arrs[i])
		f0, f1 = f1, f2
	return f1
```


另一种方法是先排序，然后从最小的开始遍历，维持一个相邻元素差距等于1的数组，当出现更大的元素时，对该数组按照打家劫舍问题进行求解，然后重置该数组，相当于把数组分割为若干个连续的数组。

```python
def deleteAndEarn(nums: List[int]) -> int:
	nums.sort()
	n = len(nums)
	def rob(arr):
		if len(arr) == 0: return 0
		if len(arr) == 1: return arr[0]
		f0, f1 = arr[0], max(arr[0], arr[1])

		for i in range(2, len(arr)):
			f2 = max(f0+arr[i], f1)
			f0, f1 = f1, f2
		return f1
	
	res = 0
	arr = [nums[0]]
	for i in range(1, n):
		v = nums[i]
		if v == nums[i-1]:  
			arr[-1] += v    # 更新删除该元素所能获得的点数
		elif v == nums[i-1] + 1:  # 相邻元素差距为1，将其加入 arr中
			arr.append(v)
		else:   # 出现更大的元素，对 arr 进行求解
			res += rob(arr)
			arr = [v]
	res += rob(arr)
	return res
```


### 树形打家劫舍

[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/description/)

该题可以通过记忆化回溯解决

```python
def rob(root: Optional[TreeNode]) -> int:
	memo = {}
	def dfs(node, memo):
		if node is None:
			return 0
		
		if node in memo:
			return memo[node]
		
		# 不偷该节点，则可获得的最大利润为左右节点之和
		p1 = dfs(node.left, memo) + dfs(node.right, memo)

		# 偷该节点，则可获得的最大利润为当前利润和子树的子树的利润之和
		p2 = node.val
		if node.left is not None:
			p2 += dfs(node.left.left, memo) + dfs(node.left.right, memo)
		
		if node.right is not None:
			p2 += dfs(node.right.left, memo) + dfs(node.right.right, memo)
		
		memo[node] = max(p1, p2)
		return memo[node]
	
	v = dfs(root, memo)
	return v
```


下面看一下动态规划的做法，首先用两个memo `f(o)` 记录选择 `o` 节点时，`o` 节点的子树上被选择的节点的最大权值和；`g(o)` 表示不选择 `o` 节点时，子树上的最大权值和。令 `l` 和 `r` 分别为左右子树

有如下结论：

选择`o`节点时的最大权值和等于不选择 `l` 和 `r` 节点时的最大权值和  `f(o) = g(l)+g(r)`  

不选择`o`节点时的最大权值和等于是否选择 `l` 和 `r` 节点时的最大权值和：

`g(o)=max(f(l), g(l))+max(f(r),g(r))`

为了节约内存，可以使用两个变量替代 g 和 f。

```python
def rob(root: Optional[TreeNode]) -> int:
	memo = {}
	def dfs(node):
		if node is None:
			return [0,0]
		
		fl, gl = dfs(node.left)
		fr, gr = dfs(node.right)

		# 选择该节点时的最大权值和
		fn = node.val + gl + gr
		# 不选择该节点时的最大权值和
		gn = max(fl, gl) + max(fr, gr)
		return [fn, gn]
	f, g = dfs(root)
	return max(f, g)
```


### 解决智力问题

[2140. 解决智力问题 - 力扣（LeetCode）](https://leetcode.cn/problems/solving-questions-with-brainpower/description/)

打家劫舍的变形题，或者看成带权重的工作规划的变形题

对于一个问题，如果不解决，则有 `dp[i]=dp[i+1]`，如果解决则有

`dp[i] = points[i]+dp[i+brainpower[i]+1]`

```python
def mostPoints(questions: List[List[int]]) -> int:
	n = len(questions)
	
	dp = [0] * (n+1)  # dp[i] 从 i 到 n-1的最大分数
	res = 0
	
	for i in range(n-1, -1, -1):
		e = min(i+questions[i][1]+1, n)
		dp[i] = max(dp[i+1], questions[i][0] + dp[e])
	return dp[0]
```


如果看成带权重的工作规划问题，则需要在开始时间中找到大于当前问题的结束时间的问题

```python
def mostPoints(questions: List[List[int]]) -> int:
	from bisect import bisect_right
	n = len(questions)
	starts = [i for i in range(n)]
	
	dp = [0] * n  # dp[i] 从 i 到 n-1的最大分数
	res = 0
	
	for i in range(n-1, -1, -1):
		dp[i] = questions[i][0]  # 选择回答该问题
		# 在开始时间中找到大于当前问题的结束时间
		idx = bisect_right(starts, questions[i][1]+i, i+1)
		if idx < n:
			dp[i] += dp[idx]
		if i != n-1:
			dp[i] = max(dp[i], dp[i+1])
	return dp[0]
```



### 长度为3的不同回文子序列

[1930. 长度为 3 的不同回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/description/)

首先记录每个元素出现过的位置，然后遍历每个元素，如果该元素只出现一次，那么没有该元素构成的回文子序列，如果出现两次以上，找到最开始和最末尾出现的地方，然后用一个集合统计这个区间内所有的不同的元素，便是该元素在外侧构成的长度为3的回文子序列总数。

```python
def countPalindromicSubsequence(s: str) -> int:
	from collections import defaultdict
	n = len(s)
	ans = 0
	freq = defaultdict(list)
	for i, sv in enumerate(s):
		freq[ord(sv)-ord('a')].append(i)
	
	for i in range(26):
		if i in freq:
			if len(freq[i]) == 1:
				continue
			l = freq[i][0]
			r = freq[i][-1]
			if r - l < 2: # 中间没有其它元素
				continue
			charset = set()
			for j in range(l+1, r):
				charset.add(s[j])
			ans += len(charset)
	return ans
```


该问题存在一些变形的算法，如 k = 2 时，直接找到字符串中字符相同的字符对即可

```python
def solve(s):
    from collections import defaultdict
    cnt = defaultdict(int)
    res = 0
    for i in range(len(s)):
        if cnt[ord(s[i])-ord('a')] == 1:  # 相同的字符串只统计一次
            res += 1
        cnt[ord(s[i])-ord('a')] += 1
    return res
```


k = 4 时，此时一般为数字字符串，首先从后向前遍历，得到单个数字的出现次数和两个数字组合的出现次数。

```python
suf = [0] * 10
suf2 = [0] * 100
for d in map(int, reversed(s)):
	for j, c in enumerate(suf):
		suf2[d * 10 + j] += c  # suf2[d][j] += suf[j]
	suf[d] += 1
```

然后从前向后遍历，同样构建单个数字和两个数字组合的出现次数，并且同时撤销后缀

```python
pre = [0] * 10
pre2 = [0] * 100
for d in map(int, s):
	for j, c in enumerate(pre):
		pre2[d * 10 + j] += c
	pre[d] += 1
	
	suf[d] -= 1
	for j, c in enumerate(suf):
		suf2[d * 10 + j] -= c  # 撤销和 d 相关的后缀
	# 枚举所有字符组合
	ans += sum(c1 * c2 for c1, c2 in zip(pre2, suf2)) 
```


k = 5 时的计算过程基本类似，但是将更新前缀放在枚举字符组合之后

```python
def countPalindromes(s: str) -> int:
	suf = [0] * 10
	suf2 = [0] * 100
	for d in map(int, reversed(s)):
		for j, c in enumerate(suf):
			suf2[d * 10 + j] += c
		suf[d] += 1

	ans = 0
	pre = [0] * 10
	pre2 = [0] * 100
	for d in map(int, s):
		suf[d] -= 1
		for j, c in enumerate(suf):
			suf2[d * 10 + j] -= c  # 撤销
		ans += sum(c1 * c2 for c1, c2 in zip(pre2, suf2))  # 枚举所有字符组合
		for j, c in enumerate(pre):
			pre2[d * 10 + j] += c
		pre[d] += 1
	return ans % (10 ** 9 + 7)
```


### 回文子序列的个数

如果允许重复，则有以下结论

如果 `s[i]!=s[j]`，则计算不同时包含两端时的个数 `dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]`

如果 `s[i]==s[j]`，则在不同时包含两端的基础上加上同时包含两端时的个数（`dp[i+1][j-1]+1`）

```python
def countPalindromicSubsequences(s: str) -> int:
	n = len(s)
	dp = [[0 for _ in range(n)] for _ in range(n)]

	for i in range(n):
		dp[i][i] = 1

	for i in range(n-2, -1, -1):
		for j in range(i+1, n):
			if s[i] == s[j]:
				dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1
			else:
				dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]
	return dp[0][n-1]
```


如果不允许重复，并且字符集合的数量较小，可以在dp数组中另外加上一维表示以该字符开始或结尾，即 `dp[x][i][j]` 表示字符串区间`s[i:j]` 中以字符 `x` 为开始和结尾的不同回文序列总数

有如下结论：若 `s[i]=s[j]=x`，则 `dp[x][i][j]` 会多出`dp[xk][i+1][j-1]`个新的在开始和结尾加上 `x` 的字符串，以及 `xx` 和 `x` 这两个单独的回文字符串

若 `s[i]=x, s[j]≠x`，则 `dp[x][i][j]` 等于 `dp[x][i][j-1]`

若 `s[i]≠x, s[j]=x`，则 `dp[x][i][j]` 等于 `dp[x][i+1][j]`

若 `s[i]≠x, s[j]≠x`，则 `dp[x][i][j]` 等于 `dp[x][i+1][j-1]`

```python
def countPalindromicSubsequences(s: str) -> int:
	n = len(s)
	MOD = 10 ** 9 + 7
	dp = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(4)]

	for i, c in enumerate(s):
		dp[ord(c) - ord("a")][i][i] = 1

	for i in range(n-2, -1, -1):
		for j in range(i+1, n):
			for k, c in enumerate("abcd"):
				if s[i] == c and s[j] == c:
					dp[k][i][j] = 2 + sum(d[i+1][j-1] for d in dp) % MOD
				elif s[i] == c and s[j] != c:
					dp[k][i][j] = dp[k][i][j-1]
				elif s[i] != c and s[j] == c:
					dp[k][i][j] = dp[k][i+1][j]
				else:
					dp[k][i][j] = dp[k][i+1][j-1]
	return sum(d[0][n-1] for d in dp) % MOD
```


该问题还可以通过二维数组求解，不过在求解时，需要注意减去重复的字符串。当 `s[i]=s[j]` 时，并且 `s[i:j]` 区间内也有一个区间，小区间的左右端点的值和 `s[i]` 相等，需要减去这个区间。

为了快速求出这个小区间的端点，可以先预处理得到 next 和 pre 数组，`next[i][x]` 表示从 `s[i]` 开始往后下一个字符 `x` 所在的位置 `ni`，`pre[i][x]` 则表示从 `s[i]` 开始上一个位置 `pj`。

如果 `ni>pj`，证明不存在这个区间，则有`dp[i][j]=2*dp[i+1][j-1]+2`：已经有`dp[i+1][j-1]` 个字符串，再在开始和结尾加上 `s[i]` 又形成了 `dp[i+1][j-1]` 个字符串，再加上 `xx` 和 `x` 这个字符串

如果`ni=pj`，证明该区间只有一个元素，此时 `x` 重复了，需要减去1

如果 `ni>pj`，则需要删除这个区间的回文字符串


```python
def countPalindromicSubsequences(s: str) -> int:
	n = len(s)
	MOD = 10 ** 9 + 7
	dp = [[0 for _ in range(n)] for _ in range(n)]

	pre = [[0 for _ in range(4)] for _ in range(n)]
	next = [[0 for _ in range(4)] for _ in range(n)]

	pos = [-1, -1, -1, -1]
	for i in range(n):
		for c in range(4):
			pre[i][c] = pos[c]
		pos[ord(s[i]) - ord('a')] = i
	
	pos = [n, n, n, n]
	for i in range(n-1, -1, -1):
		for c in range(4):
			next[i][c] = pos[c]
		pos[ord(s[i]) - ord('a')] = i

	# 初始化，单个元素的不同回文子序列个数为1
	for i in range(n):
		dp[i][i] = 1
	for i in range(n-2, -1, -1):
		for j in range(i+1, n):
			if s[i] == s[j]:
				c = ord(s[i]) - ord('a')
				ni = next[i][c]
				pj = pre[j][c]
				if ni > pj:
					# 无需删除
					dp[i][j] = (2 * dp[i+1][j-1] + 2) % MOD
				elif ni == pj:
					# 删除 x
					dp[i][j] = (2 * dp[i+1][j-1] + 1) % MOD
				else:
					# 删除区间内的回文字符串
					dp[i][j] = (2 * dp[i+1][j-1] - dp[ni+1][pj-1]) % MOD
			else:
				dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % MOD

	return dp[0][n-1]
```


## 分治

将长数据分成两部分进行计算


### 最大子数组和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

该问题可以通过动态规划的方式求解，下面介绍基于分治的解法，该方法能求出任意分段内的子数组和。

对于一个区间，需要维护四个量：

`lsum`：表示 `[l,r]` 内以 `l` 为左端点的最大子段和

`rsum`：表示 `[l,r]` 内以 `r` 为右端点的最大子段和

`msum`：表示 `[l,r]` 内最大子段和

`isum`：表示 `[l,r]` 的区间和

首先将区间从中间不断划分，直至单个元素，对于单个元素的区间，自然四个量都和该元素相等。在区间的合并时，`isum` 直接是两个区间的 `isum` 之和；`lsum` 要么等于左区间的 `lsum`，或者是左区间的 `isum` 和右区间的 `lsum` 之和；同理，`rsum` 要么等于右区间的 `rsum`，或者是右区间的 `isum` 和左区间的 `rsum` 之和；`msum` 要么是左右区间中的一个，要么是左区间的 `rsum` 和右区间的 `lsum` 求和，三者求最大

```python
def solve_c(nums):

    class Status:
        def __init__(self, lsum, rsum, isum, msum):
            self.lsum = lsum    # 以左端点开始的最大子区间和
            self.rsum = rsum    # 以右端点结束的最大子区间和
            self.isum = isum    # 区间之和
            self.msum = msum    # 区间中的最大子区间和

    def merge(l: Status, r: Status):
        m = Status(0, 0, 0, 0)
        m.isum = l.isum + r.isum
        m.lsum = max(l.lsum, l.isum+r.lsum)
        m.rsum = max(r.rsum, l.rsum+r.isum)
        m.msum = max(l.msum, r.msum, l.rsum + r.lsum)
        return m
        
    def split(l, r):
        if l == r:
            return Status(nums[l], nums[l], nums[l], nums[l])
        mid = l + (r - l) // 2
        ls = split(l, mid)
        rs = split(mid+1, r)
        return merge(ls, rs)
    n = len(nums)
    s = split(0, n-1)
    return s.msum
```

如果将上面每个区间的结果保存下来，就能实现查询。


### 最接近目标的子序列之和


[1755. 最接近目标值的子序列和 - 力扣（LeetCode）](https://leetcode.cn/problems/closest-subsequence-sum/)

在数组中求一个子序列，使其和与目标值的之间的差值最小，求差的绝对值最小值

该题可以用递归方法解决，但是当数组较长（n>=40）时，会超时，因此可以考虑将数组分为左右两部分，分别对左右两个部分计算子序列之和并保存下来，对左右子序列之和进行排序。后边分为两种做法

1、循环左半部分，然后对右半部分进行二分查找
2、用一个指针指向左半部分开始，用另一个指针指向右半部分结尾

计算子序列之和

```python
def fillsum(arr, idx, res, sums):
	if idx == len(arr):
		sums.append(res)
		return
	
	fillsum(arr, idx+1, res+arr[idx], sums)
	fillsum(arr, idx+1, res, sums)
```

第一种方法

```python
mid = len(nums) // 2
fillsum(nums[:mid], 0, 0, left)
fillsum(nums[mid:], 0, 0, right)
left.sort()
right.sort()

for i in range(len(left)):
	nt = goal - left[i]
	idx = bisect_left(right, nt)
	if idx == len(right):
		res = min(res, abs(nt - right[-1]))
	else:
		res = min(res, abs(nt - right[idx]))
	if idx != 0:
		res = min(res, abs(nt - right[idx-1]))
	if res == 0:
		break
```

第二种方法

```python
mid = len(nums) // 2
fillsum(nums[:mid], 0, 0, left)
fillsum(nums[mid:], 0, 0, right)
left.sort()
right.sort()
i = 0
j = len(right) - 1

while i < len(left) and j >= 0:
	tmp = left[i] + right[j]
	res = min(res, abs(tmp - goal))
	if res == 0:
		break
	if tmp > goal:
		j -= 1
	else:
		i += 1
```



### 天际线问题

[The Skyline Problem | Set-1 - GeeksforGeeks](https://www.geeksforgeeks.org/the-skyline-problem-using-divide-and-conquer-algorithm/)

采用类似归并算法思路，两两分组最终得到一个元素，该元素对应的两个天际线，分别为 (起点，高度) 和 (终点，0)，然后再合并


```python
def solve(arr):
    n = len(arr)

    def merge(sky1, sky2):
        i,j, h1, h2 = 0, 0, 0,0 
        n1, n2 = len(sky1), len(sky2)
        res = []
        while i < n1 and j < n2:
            if sky1[i][0] < sky2[j][0]:
                l1, h1 = sky1[i]
                maxh = max(h1, h2)
                res.append((l1, maxh))
                i += 1
            else:
                l2, h2 = sky2[j]
                maxh = max(h1, h2)
                res.append((l2, maxh))
                j += 1
        while i < n1:
            res.append(sky1[i])
            i+=1
        
        while j < n2:
            res.append(sky2[j])
            j += 1

        return res
    
    def _solve(arr, l, r):
        if l == r:
            return [(arr[l][0], arr[l][1]), (arr[l][2], 0)]
        
        mid = l + (r - l) // 2
        rl = _solve(arr, l,mid)
        rr = _solve(arr, mid+1, r)
        res = merge(rl, rr)
        return res
    res = _solve(arr, 0, n-1)
    fres = []
    lh = 0

    for i in range(len(res)):
        if res[i][1] != lh:
            fres.append(res[i])
        lh = res[i][1]
    print(fres)
```


### 最小页数分配


[Allocate Minimum Pages - GeeksforGeeks](https://www.geeksforgeeks.org/allocate-minimum-number-pages/)

将一组书，每个书对应一个页数，将这组书顺序分给k个学生，求最小的最大分配页数

这个问题和动态规划中的画家分割问题类似，下面介绍一种二分查找的方法，该方法直接通过给出最小页数，判断该最小页数是否满足条件来确定最后的解

判断条件为

1、如果当前页数大于最小页数，则剩下的书不够分给剩下的k-1个学生
2、如果当前页数小于最小页数，则剩下的书过多


```python
def solve(arr, k):

    def check(arr, k, mp):
        cnt = 1
        pageSum = 0

        for pages in arr:
            # 加上目前的书超过了最小页数，那么就把以及分好的pageSum分给下一个学生
            if pageSum + pages > mp:
                cnt += 1
                pageSum = pages
            else:
                pageSum += pages
        return cnt <= k
    
    low = max(arr)
    high = sum(arr)
    res = 0
    while low <= high:
        mid = low + (high - low) // 2
        if check(arr, k, mid):  # 如果书不够分
            res = mid
            high = mid - 1
        else:
            low = mid + 1
    return res
```


## 分支定界

用于找到数学优化问题的最优解


### 0-1 背包问题

[0/1 Knapsack using Branch and Bound - GeeksforGeeks](https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/)

如果重量不是整数，那就不能直接用动态规划，可以考虑使用分支定界方法

先对物品按照单位利润从大到小排序，每次考虑加入当前物品和不加入当前物品时的利润，通过贪婪算法计算出当前情况的上界，如果上界大于目前的利润，将该点放入队列中考虑之后的情况。

```python
def solve(W, arr):
    # arr[i] = (weight, profit)
    # W 重量
    def bound(u):
        if u[2] >= W:
            return 0
        profit_bound = u[1]  # 利润上界
        j = u[0] + 1
        total_weight = u[2]

        while j < n and total_weight + arr[j][0] <= W:
            total_weight += arr[j][0]
            profit_bound += arr[j][1]
            j += 1
        
        # 如果还有物品剩下来，计算下一个物品的分数贡献
        if j < n:
            profit_bound += int((W - total_weight) * arr[j][1] / arr[j][0])
        return profit_bound

    n = len(arr)
    
    arr = sorted(arr, key=lambda x: x[0] / x[1]) # 按照单位利润的倒数排列
    queue = deque()
    queue.append([-1, 0, 0])   # 放入一个空节点 (level, profit, weight)
    max_profit = 0
    while queue:
        cl, cp, cw = queue.popleft()
        if cl == -1:
            v = [0, 0, 0]   # 起始点
        elif cl == n - 1:   # 跳过最后一个点
            continue
        else:               # 下一个点
            v = [cl+1, cp, cw]
        
        # 选择当前物品
        v[2] += arr[cl][0]      # weight
        v[1] += arr[cl][1]      # profit

        if v[2] < W and v[1] > max_profit:
            max_profit = v[1]
        
        v_bound = bound(v)
        if v_bound > max_profit:
            queue.append(v)
        
        # 不选择当前物品
        v = [cl + 1, cp, cw]
        v_bound = bound(v)
        if v_bound > max_profit:
            queue.append(v)
    return max_profit
```


### 8 数码问题

[8 puzzle Problem - GeeksforGeeks](https://www.geeksforgeeks.org/8-puzzle-problem-using-branch-and-bound/)

将 8 个数和一个空白区域组成的一个 3×3 网格中移动数字，使其符合某个预定的状态

可以使用DFS或者BFS解决，以BFS为例，用一个队列保存当前状态，将空白区域向四个方向移动，得到四个状态（需要用一个矩阵保存已经访问过的状态）

DFS类似，用一个栈保存状态

这两种方法的时间复杂度和空间复杂度都为 `O(n!)`。

为了避免空间占用过大，可以使用分支定界方法，用一个cost表示当前状态和最终状态之间的差距，每次选择差距最小的状态

```python
row = [1, 0, -1, 0]
col = [0, -1, 0, 1]

def solve(initial, x, y, final):
    
    def isSafe(x, y):
        if x < 3 and x >= 0 and y < 3 and y >= 0:
            return True
        return False
    # 计算当前差距
    def cal_cost(state):
        cost = 0
        for i in range(3):
            for j in range(3):
                if state[i][j] != final[i][j]:
                    cost += 1
        return cost
    
    pq = []
    cost = cal_cost(initial)
    root = Node(initial, x, y, 0, None)
    root.cost = cost
    pq.append(root)

    while pq:
        min_node = min(pq, key=lambda x: x.cost)  # 选择差距最小的
        pq.remove(min_node)
        if min_node.cost == 0:  # 差距为0，代表满足要求
            print_path(min_node)
            return
        
        for i in range(4):
            new_x, new_y = x + row[i], y + col[i]
            if isSafe(new_x, new_y):
                new_mat = [row[:] for row in min_node.mat]
                new_mat[new_x][new_y], new_mat[x][y] = \
                    new_mat[x][y], new_mat[new_x][new_y]
                child = Node(new_mat, new_x, new_y, min_node.level+1, min_node)
                child.cost = cal_cost(new_mat)
                pq.append(child)
```


### 旅行商问题

[Traveling Salesman Problem using Branch And Bound - GeeksforGeeks](https://www.geeksforgeeks.org/traveling-salesman-problem-using-branch-and-bound-2/)


### 工作分配问题

[Job Assignment Problem using Branch And Bound - GeeksforGeeks](https://www.geeksforgeeks.org/job-assignment-problem-using-branch-and-bound/)

[算法分享，匈牙利算法（Hungarian Algorithm）详解（步骤、正确性分析、时间复杂度分析） - 知乎](https://zhuanlan.zhihu.com/p/677501913)

匈牙利算法流程

在每一行找到最小值，该行元素减去该最小值

在每一列找到最小值，该列元素减去该最小值

用最小的行和列覆盖所有的 0 元素，如果行和列的数量等于 n，则可以求解，否则需要在未覆盖的元素中找到最小值，未覆盖的元素减去这个最小值，重复该步骤，直到可以求解

算法的关键是如何找到最小的行和列来覆盖0元素
