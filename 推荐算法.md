
## 传统模型


### Content-Based 算法

基于项目（物品）特征和用户历史偏好的推荐方法。根据用户过去喜欢的内容特征，推荐与之相似的内容。

#### 工作原理

对物品（如电影、书籍、商品等）进行特征化处理，例如提取类别、描述、关键词等。

分析用户历史行为（如购买、评分、浏览）中涉及的内容特征，生成用户兴趣画像。

使用相似度算法（如余弦相似度、欧几里得距离）计算用户画像与物品特征的相似性。


#### 优势

**个性化推荐** ：基于用户兴趣生成推荐，个性化程度高。

**冷启动问题（用户侧）**：对新用户，通过收集少量兴趣偏好即可生成推荐。

**可解释性强** ：推荐结果基于特征相似性，容易解释为什么推荐某物品。

#### 局限

**冷启动问题（物品侧）**：对新物品（没有用户历史数据），无法有效推荐。

**兴趣狭窄化** ：由于只基于用户过去的偏好，容易造成推荐内容单一化。

**特征依赖强**：如果物品的特征无法有效提取，推荐效果会大打折扣。


### Collaborative Filtering（协同过滤）

利用用户行为数据（如评分、浏览记录等）来发现用户之间或物品之间的相似性，从而实现推荐。与 Content-Based 不同，协同过滤不依赖于物品的特征，而是依赖用户的行为和互动数据。


#### 基于用户的协同过滤

根据用户的行为相似性来推荐。例如，如果用户 A 和用户 B 喜欢的电影有高度重合，可以将用户 B 喜欢而用户 A 未看过的电影推荐给用户 A。

- 计算用户之间的相似度（如余弦相似度、皮尔逊相关系数）。
- 找到目标用户的相似用户。
- 根据相似用户的行为预测目标用户可能感兴趣的物品。


#### 基于物品的协同过滤

根据物品的相似性来推荐。例如，如果用户对某本书 A 打了高分，而书 A 和书 B 的评分模式相似，则推荐书 B 给用户。

- 计算物品之间的相似度。
- 根据用户的历史行为找到用户曾经评分较高的物品。
- 基于这些物品的相似性推荐其他物品。


#### 优势

**无需物品特征** ：只需要用户与物品的交互数据，适用于难以提取特征的场景。

**动态调整** ：用户行为数据会不断变化，推荐结果可以随数据实时更新。

**领域适应性强**：通用性高，可广泛应用于不同领域。


#### 局限

 **冷启动问题**：（1）**用户冷启动**：新用户无历史行为，无法找到相似用户。（2）**物品冷启动**：新物品无用户交互，无法推荐。

**数据稀疏性**：用户-物品矩阵通常非常稀疏，难以计算相似性。

**扩展性差** ：在大规模数据集上，计算相似度和评分预测的效率较低。

**长尾效应**：推荐倾向于热门物品，导致冷门物品曝光率低。




### 矩阵分解模型


#### 问题阐述

假设有 $N$ 个用户和 $M$ 个物体，每个用户对于部分物体有一个评分（没有评的设置为 0），这样会生成一个 $N\times M$ 维的矩阵 $R$，这个矩阵中许多位置为0，为了预测这些位置的评分，可以使用矩阵分解算法。即初始化一个用户矩阵 $U\in R^{N\times d}$ 和物体矩阵 $P\in R^{d\times M}$，使得 $R- U\times P$ 的损失最小，优化的目标函数为

$$
\min \sum\limits_{{r_{nm}} \ne 0} {{{\left( {{r_{nm}} - u_n^T{p_m}} \right)}^2}}  + \lambda \left\| {{u_n}} \right\|_2^2
$$

其中 $\lambda \left\| {{u_n}} \right\|_2^2$ 为正则项，防止过拟合。

#### 求解方法

求解 $U$ 和 $P$ 可以通过交替最小二乘法（ALS），先固定 $U$ 优化 $P$，再固定 $P$ 优化 $U$。

（1）固定 $P$，优化 $U$

将 $P$ 当作常数，这样可以分成多个用户同时求解。目标函数为

$$
J({u_n}) = {\left( {{R_n} - P_n^T{u_n}} \right)^T}\left( {{R_n} - P_n^T{u_n}} \right) + \lambda u_n^T{u_n}
$$

其中，$R_n$ 是用户 $n$ 对 $m$ 个物体的评分构成的向量，$P_n$ 为这 $m$ 个物体向量构成的矩阵，顺序与 $R_n$ 中的物品的顺序一致。对目标函数求导，得到 $u_n$ 的解析解为

$$
{u_n} = {\left( {{P_n}P_n^T + \lambda I} \right)^{ - 1}}{I_n}{R_n}
$$

（2）固定 U，优化 P

同理可得 $p_m$ 的解析解为
$$
{p_m} = {\left( {{U_m}U_m^T + \lambda I} \right)^{ - 1}}{U_m}{R_m}
$$
其中 $R_m$ 是 n 个用户对于物品 m 的评分构成的向量，$U_m$ 为这 n 个用户的矩阵。

#### 隐式矩阵分解

隐式矩阵分解会拟合评分矩阵中的零，即没有评分也会去拟合。定义一个二值变量 $d_{nm}$ 表示用户的行为强度

$$
{d_{nm}} = \left\{ \matrix{
  1\quad {r_{nm}} > 0 \hfill \cr 
  0\quad {r_{nm}} = 0 \hfill \cr}  \right.
$$
定义一个置信度 $c_{nm}$

$$
{c_{nm}} = 1 + \alpha {r_{nm}}
$$
当 $r_{nm}>0$，$c_{nm}$ 关于 $r_{nm}$ 线性递增，即评分越高，置信度越大，而当 $r_{nm}=0$ 时，$c_{nm}$ 为 1，置信度相同。隐式矩阵分解的目标函数为

$$
\min \sum\limits_{n = 1}^N {\sum\limits_{m = 1}^M {{c_{nm}}{{\left( {{d_{nm}} - u_n^T{p_m}} \right)}^2}} }  + \lambda \left( {\sum\limits_{n = 1}^N {\left\| {{u_n}} \right\|_2^2}  + \sum\limits_{m = 1}^M {\left\| {{p_m}} \right\|_2^2} } \right)
$$
仍然可以通过交替最小二乘法求解。

#### 增量矩阵分解

为了解决新用户的问题，可以使用增量矩阵分解。只需要使用新用户的历史行为数据 $r_{nm}$ 和在训练集上学习到的物品矩阵 $P$，求解的用户向量为 $u'$

$$
\min \sum\limits_{m = 1}^M {{c_{nm}}{{\left( {{d_{nm}} - u{'^T}{p_m}} \right)}^2}}  + \lambda \left\| {u'} \right\|_2^2
$$
对于历史数据 $r_{nm}$ 要过滤掉在 $P$ 没有出现的物体，并且 $P$ 是固定的，不需要迭代。



### LightFM




```python
from lightfm import LightFM
from lightfm.datasets import fetch_movielens
from lightfm.evaluation import precision_at_k

# Load the MovieLens 100k dataset. Only five
# star ratings are treated as positive.
data = fetch_movielens(min_rating=5.0)

# Instantiate and train the model
model = LightFM(loss='warp')
model.fit(data['train'], epochs=30, num_threads=2)

# Evaluate the trained model
test_precision = precision_at_k(model, data['test'], k=5).mean()
```


