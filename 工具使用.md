
# Gradle

Gradle 是一套编译工具，可用于 java、kotlin、scala、C++ 等语言的编译构建。

在 [Gradle | Releases](https://gradle.org/releases/) 上下载 binary-only 文件，或者在腾讯 gradle 镜像[Index of /gradle/](https://mirrors.cloud.tencent.com/gradle/) 上下载。解压后在环境变量中添加 `GRADLE_HOME=D:\gradle-7.6.1`，然后在PATH中添加 `%GRADLE_HOME%\bin`

## 基本使用

### 初始化项目

**首先先创建一个文件夹，切换到该文件夹后**，执行

```sh
gradle init
```

创建的项目文件夹中会包括 `gradlew.bat` 脚本，后续的gradle操作主要依赖这个脚本来实现。


> [!NOTE] gradle 和 gradlew
> gradle 一般用于创建项目，在项目创建完成后，推荐使用 gradlew （gradle warpper） 来进行后面的操作。gradlew 不依赖本地的 gradle 安装，只和指定的 Gradle 版本绑定，方便项目移植。

项目的 gradle版本指定位于 gradle/wrapper/gradle-wrapper.properties，默认从官方下载

```
distributionUrl=https\://services.gradle.org/distributions/gradle-7.6.1-bin.zip
```

可以替换为本地位置或者镜像位置

```
distributionUrl=file:///D://work//app//gradle-7.6.1-bin.zip
distributionUrl=https://mirrors.cloud.tencent.com/gradle/gradle-7.6.1-bin.zip   
```

在 Android studio 中可以在 `Build, Execution, Deployment -> Build Tools -> Gradle` 中指定 Gradle 位置。对于在 Android studio 中 sync 项目慢的问题，可以设置 `Settings->System Setting->HTTP Proxy` 中的 Automatic proxy configuration URL 为 `mirrors.neusoft.edu.cn:80`。


### 构建项目

```sh
gradle build
```



### 兼容性

Android studio 和 Andorid Gradle 插件之间存在兼容需要，详见：[Android Gradle 插件 8.7 版本说明  |  Android Studio  |  Android Developers](https://developer.android.google.cn/build/releases/gradle-plugin?hl=zh-cn#android_gradle_plugin_and_android_studio_compatibility)。如 Android Studio Koala | 2024.1.1 适用于 3.2-8.5 版本的 Android Gradle 插件

这里的 Android Gradle 插件指的是 build.gradle 中的

```json
dependencies{
	classpath 'com.android.tools.build:gradle:8.1.0'
}
```


Android Gradle 插件和 Gradle 版本之间也存在兼容性，详见：[Android Gradle 插件 8.7 版本说明  |  Android Studio  |  Android Developers](https://developer.android.google.cn/build/releases/gradle-plugin?hl=zh-cn#updating-gradle)

一般来说，插件版本越高，需要的Gradle版本就越高。



## 常见错误

The project is using an incompatible version (AGP 8.6.0) of the Android Gradle plugin. Latest supported version is AGP 8.5.0

在 build.gradle 中的

```json
dependencies {  
     classpath 'com.android.tools.build:gradle:8.6.0'  
     classpath "io.codearte.gradle.nexus:gradle-nexus-staging-plugin:0.21.0"  
}
```

中的 `com.android.tools.build:gradle` 改为其它版本，如 8.1.0，多试几次。

# MSYS2

提供了一套较为完整的 linux 环境，可以在 Windows 系统下编译 linux 下的许多软件。

网址：[MSYS2](https://www.msys2.org/)

点击安装目录下的 msys2_shell.cmd 进入 msys2 环境


> [!NOTE]
> 取消注释 msys2_shell.cmd 中的 `set MSYS2_PATH_TYPE=inherit` 可以使用 windows 命令行的一些环境变量




# Vim

> `Esc`：进入普通模式（默认打开时的模式），后续介绍均在该模式下

> `i`：进入插入模式，插入模式中与常规文本编辑器基本一样，不做说明。

### 撤销和恢复

| 按键   | 描述                   |
| ------ | ---------------------- |
| u      | 撤销上一步的操作       |
| Ctrl+r | 恢复上一步被撤销的操作 |


### 剪切、复制和粘贴

| 按键 | 描述           |
| ---- | -------------- |
| yiw  | 复制当前单词。 |
| yy   | 复制整行。     |
| diw  | 剪切当前单词。 |
| dd   | 剪掉整行。     |
| p    | 粘贴文本。     |

**选中复制**
用 `v` 命令进入的字符可视化模式（Characterwise visual mode)。文本选择是以字符为单位的。
用 `V` 命令进入的行可视化模式（Linewise visual mode)。文本选择是以行为单位的。
用 `ctrl-V` 进入的块可视化模式（Blockwise visual mode）。可以选择一个矩形内的文本。

进入可视化模式后可以对所选的文本进行一些操作，常用的(可视模式)命令有：
+ x或d： 剪切(即删除，同时所选的文本进入剪贴板)
+ y： 复制
+ r： 所有字符替换为新字符

选择时使用方向键或者h(←)j(↑)k(↓)l(→)来选取文本。


### 设置文件为Unix格式

打开文件后，在普通模式下输入 `:set ff=unix`。


# git

## 一些指令


克隆一个项目到本地

```sh
git clone <git url>
```

拉取子模块

```sh
git submodule update --init --recursive
```


初始化本地仓库

```sh
mkdir localRepo & cd localRepo
git init
```


查看当前git状态，用于判断是否已经准备好推送分支

```sh
git status
```

添加所有的文件

```sh
git add .
```

添加推送时的描述

```sh
git commit -m "..."
```

添加远程仓库地址

```sh
git remote add origin <git url>
```


将本地分支推送至远程仓库默认分支

```sh
git push
```


推送代码至指定分支

```sh
git push -u origin <branch name>
```


强制push

```sh
git push -f origin <branch name>
```


查看当前所有分支（可查看默认分支）

```sh
git branch
```


创建一个分支

```sh
git branch <new branch name>
```

删除一个分支（不能是默认分支）

```sh
git branch -d <branch name>
```

切换目标分支

```sh
git checkout <new branch name>
```

创建一个分支并且切换至该分支

```sh
git checkout -b <new branch name>
```

查看git的提交版本和id，可用于查看需要恢复的版本号

```sh
git log
```


恢复到指定版本

```sh
git reset --hard <version number>
```


将目标分支与当前分支合并

```sh
git merge <target branch name>
```


git 分为本地仓库和远程仓库，一般情况写完代码，commit到本地仓库（生成本地仓的commit ID，代表当前提交代码的版本号），然后push到远程仓库（记录这个版本号）。

```sh
echo "# md2html" >> README.md  
git init  
git add README.md  
git commit -m "first commit"  
git branch -M main  
git remote add origin https://github.com/Xiang-M-J/md2html.git  
git push -u origin main
```


**更新本地仓库的代码**

```sh
git pull https://github.com/xxx/xx.git master
```
或者（这里的 origin 是一个别名）
```sh
git fetch origin  
git merge origin/master
```



# Fillzilla

## 使用Fillzilla与ubuntu虚拟机互相连接

### Ubuntu端

1. 设置超级用户
2. 关掉防火墙    
3. 安装openssh-server
```sh
sudo apt-get install openssh-server
```

4. 使用 ifconfig 查看网址

```
ens33 .....  
inet 192.168.40.128
```


### Windows端

需要安装 Fillzilla，主机输入网址，用户名输入xmj 密码输入 端口输入22


# WebAssembly

>一项可将其他语言编写的程序放在浏览器中运行的技术

## Emscripten

让 c/c++ 代码在浏览器中运行

### 安装步骤

```cmd
git clone https://github.com/juj/emsdk.git
cd emsdk
```

接下来执行 

```sh
emsdk install --build=Release sdk-incoming-64bit binaryen-master-64bit
```
但是大概率会报如下错误

```cmd
error: tool or SDK not found: 'sdk-incoming-64bit'
```

此时使用如下方式来进行安装

```sh
emsdk install latest
```
这一步需要从网络中下载一些资源，需要等待一段时间

然后激活环境（向当前终端写入一些环境变量）

```sh
emsdk activate latest
```

关闭当前终端后，为了重新恢复环境，可以运行下面的命令

```sh
emsdk_env.bat
```


### 编译 C/C++

示例 c 代码如下
```c
#include <stdio.h>

int main(int argc, char ** argv) {
  printf("Hello World\n");
}
```

在配置过 Emscripten 编译环境的终端窗口中，运行下列命令

```sh
emcc hello.c -s WASM=1 -o hello.html
```

对应的生成 `hello.wasm`、`hello.js` 和 `hello.html`。

> 生成的 html 不能直接在浏览器中打开，需要在本地服务器打开。

html 可以指定模板，如下所示

```sh
emcc -o hello2.html hello2.c -O3 -s WASM=1 --shell-file html_template/shell_minimal.html
```

这里的 shell_minimal.html 的位置位于 upstream/emscription/src 中（该位置可能不固定）


### 一个例子

在任意位置创建一个文件夹，存放 c 文件，如 cal.c，然后调用以下命令

```bat
set emsdk_path=E:/work/emsdk
set template_path=%emsdk_path%/upstream/emscripten/src/shell_minimal.html
set filename=cal.c
set out=gcal.html
%emsdk_path%/emsdk activate latest & emcc -o %out% %filename%  -s WASM=1 -s "EXTRA_EXPORTED_RUNTIME_METHODS=['ccall']" --shell-file %template_path%
```

官方提供了一个更加复杂的例子：[Compiling an Existing C Module to WebAssembly - WebAssembly | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/WebAssembly/existing_C_to_Wasm)

```sh
mkdir test_webp
cd test_webp
git clone https://github.com/webmproject/libwebp
```

在 test_webp 中创建一个 c 文件，命名为 webp.c

```c
#include "emscripten.h"
#include "src/webp/encode.h"

EMSCRIPTEN_KEEPALIVE
int version() {
  return WebPGetEncoderVersion();
}
```

编写 shell 脚本 run.sh

```sh
emsdk_path=E:/work/emsdk
$emsdk_path/emsdk activate latest & emcc -s WASM=1 -s EXPORTED_RUNTIME_METHODS='["cwrap"]' \
 -I libwebp  webp.c libwebp/src/{dec,dsp,demux,enc,mux,utils}/*.c  libwebp/sharpyuv/*.c
```

执行 shell 脚本

```sh
sh run.sh
```

等待一段时间，生成 a.out.js 和 a.out.wasm

创建一个 html 文件来测试

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>hello</title>
</head>

<body>

</body>
<script src="./a.out.js"></script>
<script>
    Module.onRuntimeInitialized = async () => {
        const api = {
            version: Module.cwrap("version", "number", []),
        };
        console.log(api.version());
    };
</script>

</html>
```

测试加载图片，在 webp.c 中添加以下代码

```c
#include <stdlib.h>
int result[2];
EMSCRIPTEN_KEEPALIVE
void encode(uint8_t* img_in, int width, int height, float quality) {
  uint8_t* img_out;
  size_t size;

  size = WebPEncodeRGBA(img_in, width, height, width * 4, quality, &img_out);

  result[0] = (int)img_out;
  result[1] = size;
}

EMSCRIPTEN_KEEPALIVE
void free_result(uint8_t* result) {
  WebPFree(result);
}

EMSCRIPTEN_KEEPALIVE
int get_result_pointer() {
  return result[0];
}

EMSCRIPTEN_KEEPALIVE
int get_result_size() {
  return result[1];
}


EMSCRIPTEN_KEEPALIVE
uint8_t* create_buffer(int width, int height) {
  return malloc(width * height * 4 * sizeof(uint8_t));
}

EMSCRIPTEN_KEEPALIVE
void destroy_buffer(uint8_t* p) {
  free(p);
}
```

js 代码如下

```js
async function loadImage(src) {
	// Load image
	const imgBlob = await fetch(src).then((resp) => resp.blob());
	const img = await createImageBitmap(imgBlob);
	// Make canvas same size as image
	const canvas = document.createElement("canvas");
	canvas.width = img.width;
	canvas.height = img.height;
	// Draw image onto canvas
	const ctx = canvas.getContext("2d");
	ctx.drawImage(img, 0, 0);
	return ctx.getImageData(0, 0, img.width, img.height);
}
const api = {
	version: Module.cwrap("version", "number", []),
	create_buffer: Module.cwrap("create_buffer", "number", ["number", "number"]),
	destroy_buffer: Module.cwrap("destroy_buffer", "", ["number"]),
	encode: Module.cwrap("encode", "", ["number", "number", "number", "number"]),
	free_result: Module.cwrap("free_result", "", ["number"]),
	get_result_pointer: Module.cwrap("get_result_pointer", "number", []),
	get_result_size: Module.cwrap("get_result_size", "number", []),
};

async function loadbyWasm() {
	console.time("wasm")
	const image = await loadImage("./test_webp_wasm.webp");
	// console.log(image)
	const p = api.create_buffer(image.width, image.height);
	Module.HEAP8.set(image.data, p);
	api.encode(p, image.width, image.height, 100);
	const resultPointer = api.get_result_pointer();
	const resultSize = api.get_result_size();

	const resultView = new Uint8Array(
		Module.HEAP8.buffer,
		resultPointer,
		resultSize,
	);
	const result = new Uint8Array(resultView);
	api.free_result(resultPointer);
	api.destroy_buffer(p);
	const blob = new Blob([result], { type: "image/webp" });
	const blobURL = URL.createObjectURL(blob);
	const img = document.createElement("img");
	img.src = blobURL;
	img.alt = "a useful description";
	document.body.appendChild(img);
	console.timeEnd("wasm")
}
```


> [!WARNING]
> 当编码质量过高时，会导致内存过大，所以需要在编译时设置 `-s ALLOW_MEMORY_GROWTH=1` 来允许内存增长





### 调用 C 中自定义方法


编写下面的 c 代码（直接放在 emsdk 文件夹即可）

```c
#include <stdio.h>
#include <emscripten/emscripten.h>

int main(int argc, char ** argv) {
    printf("Hello World\n");
}

#ifdef __cplusplus
extern "C" {
#endif

int EMSCRIPTEN_KEEPALIVE myFunction(int argc, char ** argv) {
  printf("我的函数已被调用\n");
}

#ifdef __cplusplus
}
#endif

```

默认情况下，Emscripten 生成的代码只会调用 `main()` 函数，其他的函数将被视为无用代码。在一个函数名之前添加 `EMSCRIPTEN_KEEPALIVE` 能够防止这样的事情发生。你需要导入 `emscripten.h` 库来使用 `EMSCRIPTEN_KEEPALIVE`。

使用下面的命令来编译程序

```sh
emcc -o hello3.html hello3.c -O3 -s WASM=1 -s "EXTRA_EXPORTED_RUNTIME_METHODS=['ccall']" --shell-file html_template/shell_minimal.html
```

虽然在本地服务器打开网页的效果与本来的相同，但是可以添加下面的元素来调用自定义方法

首先添加一个 `<button>`，放在 `<script type='text/javascript'>` 开头标签之前

```html
<button class="mybutton">运行我的函数</button>
```

再在脚本文件中加上

```js
document.querySelector(".mybutton").addEventListener("click", function () {
  alert("检查控制台");
  var result = Module.ccall(
    "myFunction", // name of C function
    null, // return type
    null, // argument types
    null,
  ); // arguments
});
```

此时点击按钮便会出现对应的结果。

假设 C 代码为

```c
#ifdef __cplusplus
extern "C" {
#endif

float EMSCRIPTEN_KEEPALIVE cal_zero_cross(float* arr, int size) {
	int zero_cross = 0;
	for (int i = 0; i < size-1; i++)
	{
		if (arr[i] * arr[i+1] < 0)
		{
			zero_cross++;
		}
	}
	return zero_cross / (size * 1.0);
}

#ifdef __cplusplus
}
#endif
```

JS 调用时的代码为

```js
var arr = Array.from([])
const size = 16000
for (let index = 0; index < size; index++) {
	arr.push(Math.sin(index) + Math.tan(index))
}
var result = Module.ccall(
	"cal_zero_cross", // name of C function
	'number', // return type
	['number', 'number'], // argument types
	[arr, size]   // arguments
); 
console.log(result)
```

参数类型支持 `number`（对应于 C 中的 `integer`, `float` 或者 `general pointer`），`string`（对应于 C 中的 `char *`），`array` （对应于 C 中的数组）



## FFmpeg-wasm

使用 webassembly 将 ffmpeg 迁移到 web 端（在运行效率上存在较大差距）

### 安装

编写 shell 脚本下载文件

```sh
NPM_URL="https://registry.npmmirror.com"
ROOT="assets"

FFMPEG_VERSION="0.12.7"
UTIL_VERSION="0.12.0"
CORE_VERSION="0.12.5"
CORE_MT_VERSION="0.12.5"

FFMPEG_TGZ="ffmpeg-${FFMPEG_VERSION}.tgz"
UTIL_TGZ="util-${UTIL_VERSION}.tgz"
CORE_TGZ="core-${CORE_VERSION}.tgz"
CORE_MT_TGZ="core-mt-${CORE_MT_VERSION}.tgz"

FFMPEG_TGZ_URL="${NPM_URL}/@ffmpeg/ffmpeg/-/${FFMPEG_TGZ}"
UTIL_TGZ_URL="${NPM_URL}/@ffmpeg/util/-/${UTIL_TGZ}"
CORE_TGZ_URL="${NPM_URL}/@ffmpeg/core/-/${CORE_TGZ}"
CORE_MT_TGZ_URL="${NPM_URL}/@ffmpeg/core-mt/-/${CORE_MT_TGZ}"


wget -P $ROOT $FFMPEG_TGZ_URL --no-check-certificate
wget -P $ROOT $UTIL_TGZ_URL --no-check-certificate
wget -P $ROOT $CORE_TGZ_URL --no-check-certificate
wget -P $ROOT $CORE_MT_TGZ_URL --no-check-certificate


if [ ! -d "${ROOT}/ffmpeg" ];then
    mkdir "${ROOT}/ffmpeg"
fi

if [ ! -d "${ROOT}/util" ];then
    mkdir "${ROOT}/util"
fi

if [ ! -d "${ROOT}/core" ];then
    mkdir "${ROOT}/core"
fi

if [ ! -d "${ROOT}/core-mt" ];then
    mkdir "${ROOT}/core-mt"
fi


tar -xf "${ROOT}/${FFMPEG_TGZ}"  -C "${ROOT}/ffmpeg"
tar -xf "${ROOT}/${UTIL_TGZ}"  -C "${ROOT}/util"
tar -xf "${ROOT}/${CORE_TGZ}"  -C "${ROOT}/core"
tar -xf "${ROOT}/${CORE_MT_TGZ}"  -C "${ROOT}/core-mt"

rm "${ROOT}/${FFMPEG_TGZ}"
rm "${ROOT}/${UTIL_TGZ}"
rm "${ROOT}/${CORE_TGZ}"
rm "${ROOT}/${CORE_MT_TGZ}"
```

下载后需要的文件位于 assets 中

### 使用

编写一个 html 用于测试

```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <title></title>  
</head>  
<body>  
<h3>Upload a video to transcode to mp4 (x264) and play!</h3>  
<video id="output-video" controls></video><br/>  
<input type="file" id="uploader">  
<p id="message"></p>  
</body>  
<script src="assets/ffmpeg/package/dist/umd/ffmpeg.js"></script>  
<script src="assets/util/package/dist/umd/index.js"></script>  
<script>  
    const { fetchFile } = FFmpegUtil;  
    const { FFmpeg } = FFmpegWASM;  
    let ffmpeg = null;  
    const transcode = async ({ target: { files } }) => {  
        const message = document.getElementById('message');  
        if (ffmpeg === null) {  
            ffmpeg = new FFmpeg();  
            ffmpeg.on("log", ({ message }) => {  
                console.log(message);  
            })  
            ffmpeg.on("progress", ({ progress, time }) => {  
                message.innerHTML = `${progress * 100} %, time: ${time / 1000000} s`;  
            });  
            await ffmpeg.load({  
                coreURL: "/assets/core/package/dist/umd/ffmpeg-core.js",  
            });  
        }  
        const { name } = files[0];  
        await ffmpeg.writeFile(name, await fetchFile(files[0]));  
        message.innerHTML = 'Start transcoding';  
        console.time('exec');  
        await ffmpeg.exec(['-i', name,  'output.mp4']);  
        console.timeEnd('exec');  
        message.innerHTML = 'Complete transcoding';  
        const data = await ffmpeg.readFile('output.mp4');  
  
        const video = document.getElementById('output-video');  
        video.src = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));  
    }  
    const elm = document.getElementById('uploader');  
    elm.addEventListener('change', transcode);  
</script>  
</html>
```


# 正则表达式

测试工具：[正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)

## 基本语法

| 字符       | 功能                            |
| -------- | ----------------------------- |
| `[\s\S]` | 匹配所有字符                        |
| `\w`     | 匹配字母、数字、下划线。等价于`[A-Za-z0-9_]` |
| `\[`     | 匹配中括号                         |
| `\S`     | 匹配任意一个非空白字符                   |
| `\s`     | 匹配任意一个空白字符                    |

## 常用功能

### 向前查找和向后查找

如果只想得到模式中间的结果，可以使用向前（`?<=`）和向后查找（`?=`）

**字符串**

```css
<style type='text/css'>html {overflow-x: initial !important;}:root { --mermaid-theme: default; --mermaid-sequence-numbers: off; --mermaid-flowchart-curve: linear; --mermaid--gantt-left-padding: 75; --sequence-theme: simple; }
</style>
```

**模式**

```text
(?<=<[sS][Tt][yY][Ll][Ee] type='text/css'>)[\s\S]*(?=</[sS][Tt][yY][Ll][Ee]>)
```

**结果**

```text
html {overflow-x: initial !important;}:root { --mermaid-theme: default; --mermaid-sequence-numbers: off; --mermaid-flowchart-curve: linear; --mermaid--gantt-left-padding: 75; --sequence-theme: simple; }
```

`re.search()`：python，查找字符



### 防止过度匹配

常用的贪婪型字符和懒惰型字符

| 贪婪型字符 | 懒惰型字符 |
| ---------- | ---------- |
| *          | *?         |
| +          | +?         |
| {n, }      | {n, }?     |

有时候匹配时会过度匹配，如下面

**字符串**

```html
<img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png"  alt="image-20231027215916527" </img> <img img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png" </img>
```

**模式（错误）**

```text
<img.*src="[\s\S]*\.png[\s]*(?=")
```

**结果（错误）**

```html
<img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png"  alt="image-20231027215916527" </img> <img img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png
```

出现匹配过度了。在贪婪型字符后面加上?

**模式（正确）**

```text
<img.*?src="[\s\S]*?\.png[\s]*(?=")
```

**结果（正确）**

```html
<img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png
<img img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png
```

注意这里由于python不支持前向查找变长，所以只有保留`<img dkkjd=""src="`。



### 替换字符串

正则替换时需要两个正则表达式，一个用来指定匹配，一个用来指定替换

**字符串**

```html
<img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png"  alt="image-20231027215916527" </img> <img img dkkjd=""src="D:\TyporaImages\image-20231027215916527.png" </img>
```

**模式（匹配）**

```text
(<img.*?src=")[\s\S]*?\\(image-.*?\.png)[\s]*(?=")'
```

用括号括起来的可以作为变量传入替换正则表达式中

**模式（替换）**

```
$1../images/$2
```

`$1`表示`(<img.*?src=")`；`$2`表示`(image-.*?\.png)`

不过很可惜python的`re.sub`并不支持这样的操作，似乎只支持使用函数作为替换模式

```python
def repl_image(mathcObj):
    match = mathcObj.group()
    image = match.split('"')[-1]
    filename = image.split("\\")[-1]
    return match[:-len(image)]+'.'+image_path+"//"+filename
```

### 可选匹配

使用`()?`声明括号内的分组是可选的

**字符串**

```html
<h2 id='hello'><\h>
<h2 id='hello-1'><\h>
```

**模式**

```
(?<=<h2 id=')[\s\S]*?(?=(-\d)?'>)
```

**结果**

```
共找到 2 处匹配：
hello
hello
```



## 应用

### html压缩

```python
compress1 = re.sub(r">\s+<", "><", raw)
compress2 = re.sub(r"\s{2,}", " ", compress1)
```

### 匹配注释

匹配`//`形式注释

```
\/\/[^\n]*
```

匹配`/**/`块级注释

```
\/\*([^\*^\/]*|[\*^\/*]*|[^\**\/]*)*\*\/
```

匹配`<!-- -->`注释

```
<!--(.|\s)*?-->
```

### 替换中文标点符号

```python
punctuation = """！？｡，＂＃＄％＆＇（）＊＋－／：；＜＝＞＠［＼］＾＿｀｛｜｝～｟｠｢｣､、〃》「」『』【】〔〕〖〗〘〙〚〛〜〝〞〟〰〾〿–—‘'‛“”„‟…‧﹏"""  # 常用中文标点符号
pattern = re.compile("[{}]+".format(punctuation))
pattern.sub("", string)
```



# Neo4j
目前最高效的图数据库，可以用于构建知识图谱。
Neo4j的各项产品可在[Neo4j Deployment Center - Graph Database & Analytics](https://neo4j.com/deployment-center/)下载，其中
`AuraDB`：云端产品，无需下载
`Graph Database`：Neo4j的核心（有社区版）
`Neo4j Desktop`：Neo4j的开发环境
`Graph Data Science`：集成了图形数据库和图算法，其中图形数据库便是`Graph Database`，图算法需要另外下载，安装至`Graph Database`中，具体安装步骤见
[Neo4j Server - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/installation/neo4j-server/)
`Drivers`：支持各种高级编程语言（GO、Java、Python、.NET、JavaScript等）
`Libraries and Connectors`：Libraries指Neo4j GraphQL库，用来为跨平台和移动应用开发api，Connectors指与一些大数据处理引擎的连接。
`Tools`：一些工具，如管理数据库的工具，执行语句的shell，可视化工具等

在控制台中启动server
```cmd
neo4j console
```
访问[http://localhost:7474/](http://localhost:7474/)便可打开Neo4j Browser
[Neo4j GraphGists - graphgists](https://neo4j.com/graphgists/)：使用示例和特定行业的图形示例

## 官方教程

一个图数据库中最基础的有两个单元，节点（Nodes）和关系（Relationships）。其中节点中有标签（Labels），如`John`节点的标签是`Person`；关系存在于一个节点和另外一个节点之间，虽然必须将关系存储在特定的方向上，但是Neo4j在两个方向上具有相同的遍历性能，所以可以在不指定方向的情况下查询关系。为了进一步描述图数据库，可以在为节点和关系定义属性。

### 建模数据

**属性还是关系**
描述一个节点时，如何选择使用属性还是关系。如描述一部电影的类别是动作片和科幻片。如果使用属性描述，
![](https://neo4j.com/docs/getting-started/_images/modeling_genre_property-arr.svg)
那么查询这部电影的类别很简单，如下

```cypher
//find the genres for a particular movie
MATCH (m:Movie {title:"The Matrix"})
RETURN m.genre;
```

但是如果要查询哪些电影是动作片和科幻片就比较复杂了
```cypher
//find which movies share genres
MATCH (m1:Movie), (m2:Movie)
WHERE any(x IN m1.genre WHERE x IN m2.genre)
AND m1 <> m2
RETURN m1, m2;
```
但是如果使用关系描述
![](https://neo4j.com/docs/getting-started/_images/modeling_genre_node-arr.svg)
此时查询哪些电影是动作片和科幻片时就更加简单了，首先，Cypher找到一部电影和它所涉及的类型，然后寻找第二部同类型的电影。

```cypher
//find the genres for a particular movie
MATCH (m:Movie {title:"The Matrix"}),
      (m)-[:IN_GENRE]->(g:Genre)
RETURN g.name;

//find which movies share genres
MATCH (m1:Movie)-[:IN_GENRE]->(g:Genre),
      (m2:Movie)-[:IN_GENRE]->(g)
RETURN m1, m2, g
```

**关系型结构和图结构**
关系型数据库依赖于索引查找和表联接以连接不同的实体。当多个表连接时，便会出现性能上的问题。图数据库则不会出现这种问题。

**关系型数据库迁移至图数据库**
表格名->节点标签
表格的一行->一个节点
表格的列->节点的属性
外键->关系
带索引的列->数组属性（如email1,email2变成数组）
联合表->关系

### 导入数据

**导入CSV数据**
```cypher
LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/neo4j-contrib/training/master/modeling/data/flights_1k.csv" AS row
MERGE (origin:Airport {code: row.Origin})
MERGE (destination:Airport {code: row.Dest})
MERGE (origin)-[connection:CONNECTED_TO {
  airline: row.UniqueCarrier,
  flightNumber: row.FlightNum,
  date: date({year: toInteger(row.Year), month: toInteger(row.Month), day: toInteger(row.DayofMonth)}),
  cancelled: row.Cancelled,
  diverted: row.Diverted}]->(destination)
ON CREATE SET connection.departure = localtime(apoc.text.lpad(row.CRSDepTime, 4, "0")),
              connection.arrival = localtime(apoc.text.lpad(row.CRSArrTime, 4, "0"))
```
+ 创建一个带有Airport标签的节点，其code属性的值来自 CSV 文件中的 Origin 列
+ 创建一个带有Airport标签的节点，该节点的code属性具有 CSV 文件中 Dest 列的值
+ 根据 CSV 文件中的列，创建 CONNECTED _ TO 类型的关系和几个属性。
上面这段代码需要使用APOC包，安装参见[Installation - APOC Documentation (neo4j.com)](https://neo4j.com/docs/apoc/current/installation/)
导入可能会遇到外部文件无法Couldn't load the external resource at的问题，将csv文件放入neo4j安装路径的import文件夹中，将导入csv文件这句改为
```cypher
LOAD CSV WITH HEADERS FROM "file:///flights_1k.csv" AS row
```
如果想要改变属性的类型，比如将CONNECTED_TO关系的cancelled和cancelled属性从字符串类型改为布尔类型，
```cypher
MATCH (:Airport)-[connectedTo:CONNECTED_TO]->(:Airport)
CALL apoc.refactor.normalizeAsBoolean(connectedTo, "diverted", ["1"], ["0"])
RETURN count(*)
```
`apoc.refactor.normalizeAsBoolean`的语法为(关系或节点，属性，可以转为true的值，可以转为false的值)，结合上面的例子，如果属性值为"1"，那么属性值转为true，如果属性值为"0"，那么属性值转为false，如果都不是，转为null。
如果更新的数据太大，可以使用`apoc.periodic.iterate`来控制更新的大小，`apoc.periodic.iterate`似乎必须要传入两条string语句。
关于导入数据更详细的说明：[Import your data into Neo4j - Getting Started](https://neo4j.com/docs/getting-started/data-import/)

### Cypher
Cypher是图查询语言。
#### 基础操作
节点包含在括号内：(variable:label)
```cypher
()                  //anonymous node (no label or variable) can refer to any node in the database
(p:Person)          //using variable p and label Person
(:Technology)       //no variable, label Technology
(work:Company)      //using variable work and label Company
```
关系包含在`-[]-`中，`-[variable:关系名]-`，一般没有variable，有方向时需要标上箭头。
```cypher
//data stored with this direction
CREATE (p:Person)-[:LIKES]->(t:Technology)
//query relationship backwards will not return results
MATCH (p:Person)<-[:LIKES]-(t:Technology)
//better to query with undirected relationship unless sure of direction
MATCH (p:Person)-[:LIKES]-(t:Technology)
// 注意关系可以不需要
MATCH (p:Person) --> (t:Technology)
```
节点和关系的属性包括在`{}`内，`{属性名: 属性值}`
```cypher
(p:Person {name: "Sally"})-[rel:LIKES]->(g:Technology {type: "Graphs"})
```

##### 创建
**创建一个节点**
```cypher
CREATE(n)    // 不带标签
CREATE(n:Movie)   // 一个标签
CREATE(n:Movie:Person)  //多个标签
```
**创建节点间的关系**
```cypher
MATCH (a:TEST),(b:TEST)
WHERE a.name = 'TEST-NAME' AND b.name = 'TEST-NAME1'
CREATE (a)-[r:RELTYPE] -> (b)
// CREATE (a)-[r:RELTYPE { name: a.name + b.name}] -> (b)  // 带属性
RETURN r
```
使用`merge`添加关系，可以避免重复数据。MERGE执行“选择或插入”操作，首先检查数据库中是否存在数据。如果存在，则 Cypher 按原样返回它，或对现有节点或关系进行任何指定的更新。如果数据不存在，那么 Cypher 将使用您指定的信息创建它。
```cypher
MATCH (a:Person {name: "张三"}),
    (b:Person {name: "李四"})
MERGE (a)-[r:FRIENDS]->(b)
```
**创建一个节点和关系**
```cypher
CREATE p = (a:TEST{name:'TEST-NAME'}) - [:rel3] -> (node) <- [:rel3] - (b:TEST{name:'TEST-NAME1'})
RETURN p
```

##### 删除
**清空数据库**
节点比较少
```cypher
match (n) detach delete n
```
节点比较多
1、停掉服务；  
2、删除 graph.db 目录；  
3、重启服务。

**删除节点和关系**
删除一个节点，就可以删除它的关系
```cypher
match(p:Person{name: 'jt'}) detach delete p
```
如果只想删除关系
```cypher
match(p:Person{name: "reba"})-[r:WORK_AT]->() delete r  // 可以删除reba节点的关系WORK_AT
```

**删除属性**
可以删除节点和关系的属性，也可以删除label，删除后label下的所有节点都会被删除，删除后的结果为null。
```cypher
match(d:Disease {name:"诊断"})
remove d.code     
return d.name, d.oid, d.code
```
##### 更新
**更新和添加一个属性**
```cypher
MATCH (n {name:'张三'}) 
SET n.name='李四'   // 更新属性
SET n.age=20       // 添加属性
RETURN n
```

**修改节点信息，覆盖节点属性**
```cypher
MATCH (n {name:'张三'}) 
SET n={age:20}
```

**修改节点信息，新增节点属性**
```cypher
MATCH (n {name:'张三'}) SET n += {age:20}
RETURN n
```

**更新节点间的关系**
```cypher
match(n)-[r:old]->(m) create(n)-[r2:new]->(m) set r2=r with r delete r
```

#### Cypher与SQL
Cypher中查询的命令为`match`，与SQL语句相比，选择时的语句不一样。
**排序**
```cypher
MATCH (p:Product)
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC
LIMIT 10;
```
**过滤语句**
```cypher
MATCH (p:Product)
WHERE p.productName = 'Chocolade'
RETURN p.productName, p.unitPrice;
```
关于SQL与Cypher语句的比较参见[Comparing Cypher with SQL - Getting Started (neo4j.com)](https://neo4j.com/docs/getting-started/cypher-intro/cypher-sql/)


#### UNION和WITH
如果要组合具有相同结果结构的两个语句的结果，可以使用`UNION`
```cypher
MATCH (actor:Person)-[r:ACTED_IN]->(movie:Movie)
RETURN actor.name AS name, type(r) AS type, movie.title AS title
UNION
MATCH (director:Person)-[r:DIRECTED]->(movie:Movie)
RETURN director.name AS name, type(r) AS type, movie.title AS title
```
这段语句与下面这段语句的功能相同
```cypher
MATCH (actor:Person)-[r:ACTED_IN|DIRECTED]->(movie:Movie)
RETURN actor.name AS name, type(r) AS type, movie.title AS title
```
`WITH`子句用于组合各个部分，并声明哪些数据从一个部分流向另一个部分。`WITH`类似于`RETURN`子句。区别在于`WITH`子句不完成查询，而是为下一部分准备输入。表达式、聚合、排序和分页可以按照与`RETURN`子句相同的方式使用。唯一的区别是所有列都必须使用别名。
```cypher
MATCH (person:Person)-[:ACTED_IN]->(m:Movie)
WITH person, count(*) AS appearances, collect(m.title) AS movies
WHERE appearances > 1
RETURN person.name, appearances, movies
```

#### 定义模式

在图形数据库中使用索引（index）的主要原因是为了找到图遍历的起点。一旦找到了起点，遍历就依赖于图内结构来实现高性能。
```cypher
CREATE INDEX example_index_1 FOR (a:Actor) ON (a.name)
```
但是这一步并不是必要的，因为查询时会自动使用合适的index

约束（Constraints）用于确保数据符合域的规则。

```cypher
CREATE CONSTRAINT constraint_example_1 FOR (movie:Movie) REQUIRE movie.title IS UNIQUE
```

#### 实践：导入数据
在import文件夹创建三个csv文件
**persons.csv**
```csv
id,name
1,Charlie Sheen
2,Michael Douglas
3,Martin Sheen
4,Morgan Freeman
```
**movies.csv**
```csv
id,title,country,year
1,Wall Street,USA,1987
2,The American President,USA,1995
3,The Shawshank Redemption,USA,1994
```
**roles.csv**
```csv
personId,movieId,role
1,1,Bud Fox
3,1,Carl Fox
2,1,Gordon Gekko
3,2,A.J. MacInerney
2,2,President Andrew Shepherd
4,3,Ellis Boyd 'Red' Redding
```

创建一个约束，使每个Person节点具有唯一的id属性
```cypher
CREATE CONSTRAINT personIdConstraint FOR (person:Person) REQUIRE person.id IS UNIQUE
```

为name属性的Country节点创建索引
```cypher
CREATE INDEX FOR (c:Country) ON (c.name)
```
导入三个csv文件
```cypher
LOAD CSV WITH HEADERS FROM "file:///persons.csv" AS csvLine
CREATE (p:Person {id: toInteger(csvLine.id), name: csvLine.name})
```
```cypher
LOAD CSV WITH HEADERS FROM "file:///movies.csv" AS csvLine
MERGE (country:Country {name: csvLine.country})
CREATE (movie:Movie {id: toInteger(csvLine.id), title: csvLine.title, year:toInteger(csvLine.year)})
CREATE (movie)-[:ORIGIN]->(country)
```
```cypher
:auto LOAD CSV WITH HEADERS FROM 'file:///roles.csv' AS csvLine
CALL {
 WITH csvLine
 MATCH (person:Person {id: toInteger(csvLine.personId)}), (movie:Movie {id: toInteger(csvLine.movieId)})
CREATE (person)-[:ACTED_IN {role: csvLine.role}]->(movie)
} IN TRANSACTIONS OF 2 ROWS
```
这三段导入数据的代码不能同时执行。
查找所有的节点和关系
```cypher
MATCH (n)-[r]->(m) RETURN n, r, m
```

## 如何使用AuraDB

AuraDB是一款在线的图数据库，网址为 [neo4j](https://console.neo4j.io/)
图数据库运行在实例（Instance）中，每次创建实例后，会生成对应的密码，用于后续的连接。
进入实例后，首先需要导入数据，进入 Import 界面，首先先创建节点，点击这个按钮来创建节点

![image-20231228194632204](D:\TyporaImages\image-20231228194632204.png)
 
选择该节点，创建节点的属性，可以直接从 csv 文件中导入。

两个节点之间可以创建关系，直接从一个节点的边缘拖到另一个节点的边缘即可自动创建关系。

导入完数据后，可以选择自动生成知识图谱，或者在explore界面输入`Show me a graph`来手动生成。



## 图数据科学

参见[Introduction - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/introduction/)

### 图算法
通用算法语法包括引用先前加载的命名图，提供了不同的执行模式
stream：以记录流的形式返回算法的结果
stats：返回汇总统计信息的单个记录，但不写入Neo4j数据库。
mutate：将算法的结果写入投影图并返回汇总统计信息的单个记录。
write：将算法的结果写入Neo4j数据库并返回汇总统计信息的单个记录。

先创建一个图数据库，利用`gds.graph.project`将图数据库转成GDS图，然后预估算法的运行成本，最后执行算法。一个完整的算法流程见[Article Rank - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/article-rank/)
GDS支持的算法有
1. **中心性算法**：用于确定网络中不同节点的重要性。[Centrality - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/centrality/)
2. **社区检测算法**：用于评估节点组是如何聚集或分割的，以及它们的增强或分离趋势。[Community detection - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/community/)
3. **相似性算法**：根据节点的邻域或属性计算节点对的相似性。可以使用几个相似性度量来计算相似性得分。[Similarity - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/similarity/)
4. **路径搜索算法**：可以找到两个或多个节点之间的路径，或者评估路径的可用性和质量。[Path finding - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/pathfinding/)
5. **DAG算法**：有向无环图(DAGs)是不包含圈的有向图。这类图通常用于对实体之间的依赖关系建模。与DAGs密切相关的规范算法是拓扑排序，GDS为此提供了有效的并行实现。运行拓扑排序是确保图是DAG的最佳方法。当范围限制在 DAGs，一般情况下难以计算解决的一些问题可以有效地解决。其中之一是最长路径问题，GDS 为此提供了一种有效的算法。[DAG algorithms - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/dag/dag-algorithms/)
6. **节点嵌入算法**：计算图中节点的低维向量表示。这些向量也称为嵌入，可用于机器学习。[Node embeddings - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/machine-learning/node-embeddings/)
7. **链路预测算法**：利用图的拓扑结构帮助确定一对节点的紧密度。计算得出的分数可以用来预测它们之间的新关系。[Topological link prediction - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/linkprediction/)
8. **Pregel API**：Pregel 是一个以顶点为中心的计算模型，可以通过用户定义的计算函数定义自己的算法。可以在计算函数中更新节点值并表示算法结果。输入图包含默认节点值或图投影中的节点值。[Pregel API - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/algorithms/pregel-api/)

### 机器学习

[Machine learning - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/machine-learning/machine-learning/)
**预处理**
1. 放缩属性：将属性值放缩到一定范围
2. one-hot编码：将类别值转为数值格式
3. 分离关系：它将关系分为一个保留集和一个剩余集。保留集分为两类: 正集，即存在关系，和负集，即不存在关系。

**节点嵌入**
使用节点嵌入算法计算节点的低维向量表示

**节点性质预测**
支持分类和回归

**连接预测**
连接预测是应用于图表的一种常见的机器学习任务: 训练一个模型来学习图表中的应该存在关系的节点对。更准确地说，机器学习模型的输入是节点对的例子。在训练期间，节点对被标记为相邻或不相邻。

**训练方法**
逻辑回归，随机森林，多层感知器，线性回归


### 一个端到端的例子：产品推荐
[FastRP and kNN example - Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/current/end-to-end-examples/fastrp-knn-example/)
1. 创建图，并将其映射到运行算法的图
2. 使用FastRP算法生成节点嵌入来捕捉图中的拓扑信息
3. 使用kNN通过节点嵌入来判断相似节点
4. 根据相似的人作出推荐

## 高级语言驱动

### Java
[Get started - Neo4j Java Driver Manual](https://neo4j.com/docs/java-manual/current/get-started/)
在Maven项目中引入[neo4j-java-driver](https://central.sonatype.com/artifact/org.neo4j.driver/neo4j-java-driver/5.15.0/overview)，具体导入方法参见[eclipse中在maven工程 的pom.xml文件中增加依赖的方法_pom.xml怎么载入依赖-CSDN博客](https://blog.csdn.net/panghuangang/article/details/130766894)
Java中的使用如下

```java
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.Session;
import org.neo4j.driver.Query;
import org.neo4j.driver.Result;

import static org.neo4j.driver.Values.parameters;

public class App {
	public static void main(String [] args) {
		Driver driver = GraphDatabase.driver("bolt://localhost:7687",
				 AuthTokens.basic("neo4j", "fv:e.Yuw8-Qf3r3"));
		Session session = driver.session();
		
		final String message = "Greeting";
		String greeting = session.executeWrite(tx -> {
			Query query = new Query("CREATE (a:Greeting) SET a.message = $message RETURN a.message + ', from node ' + id(a)", 
					parameters("message", message));
			Result result = tx.run(query);
			return result.single().get(0).asString();
		});
		System.out.println(greeting);
		driver.close();
	}
}
```




# Nginx

nginx的主页：[nginx news](https://nginx.org/)

下载页面：[nginx: download](https://nginx.org/en/download.html)

参考教程：[dunwu/nginx-tutorial: 这是一个 Nginx 极简教程，目的在于帮助新手快速入门 Nginx。 (github.com)](https://github.com/dunwu/nginx-tutorial)

[Beginner’s Guide (nginx.org)](https://nginx.org/en/docs/beginners_guide.html)

nginx是一款轻量级的Web服务器、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。

**三种代理方式的简单介绍**

**反向代理（Reverse Proxy）**：指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理可以保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击；实现负载均衡，通过反向代理服务器来优化网站的负载。

**正向代理**：指客户端因无法直接访问或者不想直接访问目标服务器，而选择访问代理服务器（该代理服务器可以访问目标服务器），正向代理需要客户端进行一些配置，比如配置代理服务器的地址。其中无法直接访问可以理解为VPN，不想直接访问目标服务器类似于下载资源时选择速度更快的服务器。

**透明代理**：客户端和服务端感知不到代理的存在，客户端无需修改目标地址，也不需要采用代理协议连接代理服务器，所有目的地址转换都是在透明代理中完成的。如A希望访问到C，但是通过透明代理服务器B，此时A发送的请求仍然是前往C，不过在经过B后，B会发送请求到C，C会认为是B发的请求，然后答复发给B，B发给A的答复中的信息仍然显示是从C发送到A的。透明代理可以用于过滤不良信息。

## 注意事项


> [!WARNING] 
> `nginx`的配置文件名字只能是`nginx.conf`
> 
> `nginx -t -c conf/nginx.conf`：在测试配置文件时**不要**在conf文件夹进行测试，否则即使配置文件编写正确也会报错
> 
> 当用脚本执行`start nginx`，应该先进入nginx所在文件夹
> 

当不设置`server`的`index`时，**不应该**还保留`index`，此时如果有`index.html`，那么默认会显示`index.html`

markdown文件的mime类型为
```
text/markdown  md;
```

## 常见问题

（1）`nginx`报如下的错

```
nginx: [error] OpenEvent("Global\ngx_reload_21564") failed (2: The system cannot find the file specified)
```

这可能是因为reload时，指定的配置文件路径不正确，**更有可能**是配置文件的文件名不是`nginx.conf`；也有可能是端口占用的问题

（2）`nginx`报如下的错

```
3 directory index of "D:\xxx\xxx" is forbidden
```

可能是因为配置文件中`index`不存在，假如根目录下没有`index.html`，那么下面的配置就会**出错**

```nginx
server {
    location / {
        root /data/www;
        index index.html;
    }
}
```
（3）报错
```
The filename, directory name, or volume label syntax is incorrect
```
可能是路径识别问题，将配置的本地路径中`\`改为`\\`。

（4）其它一切正常，但是`127.0.0.1:80`一直显示找不到 Web 地址对应的网页
可能是因为电脑中存在多个nginx，并且默认端口都为80，需要将一个nginx的默认端口修改为其它值。 

## 常用命令

```
nginx -s signal     打开nginx
nginx -s stop       快速关闭nginx，可能不保存相关信息，并迅速终止web服务。
nginx -s quit       平稳关闭nginx，保存相关信息，有安排的结束web服务。
nginx -s reload     因改变了nginx相关配置，需要重新加载配置而重载。
nginx -s reopen     重新打开日志文件。
nginx -c filename   为nginx指定一个配置文件，来代替缺省的。
nginx -t            不运行，仅仅测试配置文件。nginx将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。
nginx -v            显示 nginx 的版本。
nginx -V            显示 nginx 的版本，编译器版本和配置参数。
```

如果不想每次都敲命令，可以编写一个脚本

```cmd
@echo off
rem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程
nginx.exe -s stop

rem 测试配置文件语法正确性
nginx.exe -t -c conf/nginx.conf

rem 显示版本信息
nginx.exe -v

rem 按照指定配置去启动nginx
nginx.exe -c conf/nginx.conf
```



## Nginx官方教程

### 静态内容

假设有文件夹`/data/www`（html文件夹），`/data/images`（图片文件夹），这将需要编辑配置文件，并在 http 块中设置一个具有两个位置块的服务器块。

首先，创建`/data/www`目录并将包含任何文本内容的`index.html`文件放入其中，然后创建`/data/images`目录并将一些图像放入其中。接下来，打开配置文件。默认的配置文件已经包含了几个服务器块示例，大部分都被注释掉了。现在注释掉所有这些块并写入以下配置：

```nginx
server {
    location / {
        root /data/www;
    }
    location /images/ {
        root /data;
    }
}
```

对于第一个location，指定与来自请求的URI相比较的`/`前缀。对于匹配请求，URI将被添加指定的根路径，即`data/www`，来生成请求文件的本地路径；第二个location指定了`/images/`的根目录为`/data`。这已经是一个服务器的工作配置，该服务器在标准端口80上进行侦听，并且可以在本地计算机上进行`http://localhost/`访问。为了响应以`/images/`开头的 URI 的请求，服务器将从`/data/images`目录发送文件。例如，为了响应`http://localhost/images/example.png`请求，nginx 将发送`/data/images/example.png`文件。如果该文件不存在，nginx 将发送一个指示404错误的响应。没有以`/images/`开头的 URI 的请求将映射到`/data/www`目录。例如，为了响应`http://localhost/some/example.html`请求，nginx 将发送`/data/www/some/example.html`文件。



### 设置简单代理服务器

Nginx的一个常见用法是将其设置为代理服务器，这意味着服务器接收请求，将请求传递给代理服务器，从中检索响应，并将其发送给客户机。我们将配置一个基本的代理服务器，该服务器使用本地目录中的文件为映像请求提供服务，并将所有其他请求发送到一个代理服务器。在本例中，两个服务器都将在一个nginx实例上定义。配置文件如下：

**proxied server的配置**

```nginx
server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
```

这将是一个简单的服务器，监听端口8080（上面因为使用了标准端口80，所以没有指定listen指令），并将所有请求映射到本地文件系统上的`/data/up1`目录。创建这个目录，并将`index.html`文件放入其中。注意，根指令是放在服务器上下文中的。当为服务一个请求而选择的位置块不包括它自己的根指令时，使用这样的根指令。

**proxy server配置**

```nginx
server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
```

该服务器将过滤以`.gif`、`.jpg`或`.png`结尾的请求，并将它们映射到`/data/images`目录（通过在根指令的参数中添加URI），并将所有其他请求传递给上面配置的代理服务器。



### 设置FastCGI代理

nginx可用于将请求路由到FastCGI服务器，FastCGI服务器运行使用各种框架和编程语言(如PHP)构建的应用程序。

与FastCGI服务器一起工作的最基本的nginx配置包括使用`fastcgi_pass`指令而不是`proxy_pass`指令，以及`fastcgi_param`指令来设置传递给FastCGI服务器的参数。假设在`localhost:9000`上可以访问FastCGI服务器。以上一节的代理配置为基础，将`proxy_pass`指令替换为`fastcgi_pass`指令，并将参数更改为`localhost:9000`。在PHP中，SCRIPT_FILENAME参数用于确定脚本名称，QUERY_STRING参数用于传递请求参数。结果配置将是：

```nginx
server {
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
```


## Nginx实战

### http反向代理

`conf/nginx.conf`是nginx的默认配置文件，但可以通过指定参数`-c .conf`

```nginx
#运行用户
#user somebody;

#启动进程,通常设置成和cpu的数量相等
worker_processes  1;

#全局错误日志
error_log  D:/nginx-1.24.0/logs/error.log;
error_log  D:/nginx-1.24.0/logs/notice.log  notice;
error_log  D:/nginx-1.24.0/logs/info.log  info;

#PID文件，记录当前启动的nginx的进程ID
pid        D:/nginx-1.24.0/logs/nginx.pid;

#工作模式及连接数上限
events {
    worker_connections 1024;    #单个后台worker process进程的最大并发链接数
}

#设定http服务器，利用它的反向代理功能提供负载均衡支持
http {
    #设定mime类型(邮件支持类型),类型由mime.types文件定义
    include       D:/nginx-1.24.0/conf/mime.types;
    default_type  application/octet-stream;

    #设定日志
	log_format  main  '[$remote_addr] - [$remote_user] [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log    D:/nginx-1.24.0/logs/access.log main;
    rewrite_log     on;

    #sendfile指令指定nginx是否调用sendfile函数（zero copy 方式）来输出文件，对于普通应用，
    #必须设为on,如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.
    sendfile        on;
    #tcp_nopush     on;

    #连接超时时间
    keepalive_timeout  120;
    tcp_nodelay        on;

	#gzip压缩开关
	#gzip  on;

    #设定实际的服务器列表
    upstream zp_server1{
        server 127.0.0.1:8089;
    }

    #HTTP服务器
    server {
        #监听80端口，80端口是知名端口号，用于HTTP协议
        listen       80;

        #定义使用www.xx.com访问，如果使用www.xx.com，
        #那么需要在C:\Windows\System32\drivers\etc目录下的host文件中添加一条DNS记录
        #127.0.0.1 www.xx.com
        # server_name  www.helloworld.com;
        server_name 127.0.0.1;

		#首页
		index index.html

		#指向webapp的目录
		root D:\postgraduateLearn\first\programming\php;

		#编码格式
		charset utf-8;

		#代理配置参数
        proxy_connect_timeout 180;
        proxy_send_timeout 180;
        proxy_read_timeout 180;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarder-For $remote_addr;

        #反向代理的路径（和upstream绑定），location 后面设置映射的路径
        location / {
            proxy_pass http://zp_server1;
        }

        #静态文件，nginx自己处理
        location ~ ^/(images|javascript|js|css|flash|media|static)/ {
            root D:\postgraduateLearn\first\programming\php;
            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。
            expires 30d;
        }

        #设定查看Nginx状态的地址
        location /NginxStatus {
            stub_status           on;
            access_log            on;
            auth_basic            "NginxStatus";
            auth_basic_user_file  conf/htpasswd;
        }

        #禁止访问 .htxxx 文件
        location ~ /\.ht {
            deny all;
        }

		#错误处理页面（可选择性配置）
		#error_page   404              /404.html;
		#error_page   500 502 503 504  /50x.html;
        #location = /50x.html {
        #    root   html;
        #}
    }
}
```


### https反向代理

HTTPS的固定端口是443，不同于HTTP的80端口，同时HTTPS需要安全证书，所以要在`nginx.conf`中指定证书和对应的key，其他部分与http反向代理基本一样，只是在Server部分配置有些不同

```nginx
  #HTTP服务器
  server {
      #监听443端口。443为知名端口号，主要用于HTTPS协议
      listen       443 ssl;

      #定义使用www.xx.com访问
      server_name  www.helloworld.com;

      #ssl证书文件位置(常见证书文件格式为：crt/pem)
      ssl_certificate      cert.pem;
      #ssl证书key位置
      ssl_certificate_key  cert.key;

      #ssl配置参数（选择性配置）
      ssl_session_cache    shared:SSL:1m;
      ssl_session_timeout  5m;
      #数字签名，此处使用MD5
      ssl_ciphers  HIGH:!aNULL:!MD5;
      ssl_prefer_server_ciphers  on;

      location / {
          root   /root;
          index  index.html index.htm;
      }
  }
```



### 负载均衡

前面的例子中，代理仅仅指向一个服务器。但是，网站在实际运营过程中，大部分都是以集群的方式运行，这时需要使用负载均衡来分流。nginx也可以实现简单的负载均衡功能。

假设这样一个应用场景：将应用部署在`192.168.1.11:80`、`192.168.1.12:80`、`192.168.1.13:80`三台linux环境的服务器上。网站域名叫`www.helloworld.com`，公网IP为`192.168.1.11`。在公网IP所在的服务器上部署nginx，对所有请求做负载均衡处理（下面例子中使用的是加权轮询策略）。

```nginx
http {
     #设定mime类型,类型由mime.type文件定义
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    #设定日志格式
    access_log    /var/log/nginx/access.log;

    #设定负载均衡的服务器列表
    upstream load_balance_server {
        #weigth参数表示权值，权值越高被分配到的几率越大
        server 192.168.1.11:80   weight=5;
        server 192.168.1.12:80   weight=1;
        server 192.168.1.13:80   weight=6;
    }

   #HTTP服务器
   server {
        #侦听80端口
        listen       80;

        #定义使用www.xx.com访问
        server_name  www.helloworld.com;

        #对所有请求进行负载均衡请求
        location / {
            root        /root;                 #定义服务器的默认网站根目录位置
            index       index.html index.htm;  #定义首页索引文件的名称
            proxy_pass  http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表

            #以下是一些反向代理的配置(可选择性配置)
            #proxy_redirect off;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_connect_timeout 90;          #nginx跟后端服务器连接超时时间(代理连接超时)
            proxy_send_timeout 90;             #后端服务器数据回传时间(代理发送超时)
            proxy_read_timeout 90;             #连接成功后，后端服务器响应时间(代理接收超时)
            proxy_buffer_size 4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小
            proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
            proxy_busy_buffers_size 64k;       #高负荷下缓冲大小（proxy_buffers*2）
            proxy_temp_file_write_size 64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传

            client_max_body_size 10m;          #允许客户端请求的最大单文件字节数
            client_body_buffer_size 128k;      #缓冲区代理缓冲用户端请求的最大字节数
        }
    }
}
```

#### 负载均衡的各种策略

**轮询**

```nginx
upstream bck_testing_01 {
  # 默认所有服务器权重为 1
  server 192.168.250.220:8080
  server 192.168.250.221:8080
  server 192.168.250.222:8080
}
```

**加权轮询**

```nginx
upstream bck_testing_01 {
  server 192.168.250.220:8080   weight=3
  server 192.168.250.221:8080              # default weight=1
  server 192.168.250.222:8080              # default weight=1
}
```

**最少连接**

```nginx
upstream bck_testing_01 {
  least_conn;
  # with default weight for all (weight=1)
  server 192.168.250.220:8080
  server 192.168.250.221:8080
  server 192.168.250.222:8080
}
```

**加权最少连接**

```nginx
upstream bck_testing_01 {
  least_conn;

  server 192.168.250.220:8080   weight=3
  server 192.168.250.221:8080              # default weight=1
  server 192.168.250.222:8080              # default weight=1
}
```

**IP Hash**

```nginx
upstream bck_testing_01 {
  ip_hash;
  # with default weight for all (weight=1)
  server 192.168.250.220:8080
  server 192.168.250.221:8080
  server 192.168.250.222:8080

}
```

**普通 Hash**

```nginx
upstream bck_testing_01 {
  hash $request_uri;

  # with default weight for all (weight=1)
  server 192.168.250.220:8080
  server 192.168.250.221:8080
  server 192.168.250.222:8080
}
```

### 多个应用

假设一个站点有好几个app，访问这些应用的方式通过上下文（context）来区分：

> `www.xx.com/a`
>
> `www.xx.com/b`
>
> `www.xx.com/c`

已知http的默认端口号为80，如果在一台服务器上同时启动这3个应用，都用80端口肯定是不行的，所以需要给不同应用绑定不同端口号。用户在访问时不可能带着端口号去访问，所以需要用到反向代理。

```nginx
http {
	#此处省略一些基本配置
	# 几个应用
	upstream product_server{
		server www.helloworld.com:8081;
	}

	upstream admin_server{
		server www.helloworld.com:8082;
	}

	upstream finance_server{
		server www.helloworld.com:8083;
	}

	server {
		#此处省略一些基本配置
		#默认指向product的server
		location / {
			proxy_pass http://product_server;
		}

		location /product/{
			proxy_pass http://product_server;
		}

		location /admin/ {
			proxy_pass http://admin_server;
		}

		location /finance/ {
			proxy_pass http://finance_server;
		}
	}
}
```



### 静态站点

有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。

举例来说：如果所有的静态资源都放在了`/app/dist` 目录下，我们只需要在 `nginx.conf` 中指定首页以及这个站点的 host 即可。

```nginx
worker_processes  1;

events {
	worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    gzip on;
    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;
    gzip_vary on;

    server {
		listen       80;
		server_name  static.zp.cn;

		location / {
			root /app/dist;
			index index.html;
			#转发任何请求到 index.html
		}
	}
}
```

由于修改了`server_name`，所以需要添加HOST（在`C:\Windows\System32\drivers\etc`目录下的host文件中添加一条DNS记录）`127.0.0.1 static.zip.cn`。此时，在本地浏览器访问`static.zp.cn`，就可以访问静态站点了。

### 搭建文件服务器

有时候，团队需要归档一些数据或资料，那么文件服务器必不可少。使用Nginx可以非常快速便捷的搭建一个简易的文件服务。

Nginx中的配置要点：

- 将autoindex开启可以显示目录，默认不开启。
- 将 autoindex_exact_size 开启可以显示文件的大小。
- 将 autoindex_localtime 开启可以显示文件的修改时间。
- root 用来设置开放为文件服务的根路径。
- charset 设置为 `charset utf-8,gbk;`，可以避免中文乱码问题（windows 服务器下设置后，依然乱码，暂时没有找到解决方法）。

一个最简化的配置如下：

```nginx
autoindex on;# 显示目录
autoindex_exact_size on;# 显示文件大小
autoindex_localtime on;# 显示文件时间

server {
    charset      utf-8,gbk; # windows 服务器下设置后，依然乱码，暂时无解
    listen       9050 default_server;
    listen       [::]:9050 default_server;
    server_name  _;
    root         /share/fs;
}
```

### 跨域问题

举例：`www.helloworld.com`网站是由一个前端app，一个后端app组成的。前端端口号为9000，后端端口号为8080。前端和后端如果使用http进行交互时，请求会被拒绝，因为存在跨域问题。

首先在`enable-cors.conf`中设置cors：

```nginx
# allow origin list
set $ACAO '*';

# set single origin
if ($http_origin ~* (www.helloworld.com)$) {
  set $ACAO $http_origin;
}

if ($cors = "trueget") {
	add_header 'Access-Control-Allow-Origin' "$http_origin";
	add_header 'Access-Control-Allow-Credentials' 'true';
	add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
	add_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
}

if ($request_method = 'OPTIONS') {
  set $cors "${cors}options";
}

if ($request_method = 'GET') {
  set $cors "${cors}get";
}

if ($request_method = 'POST') {
  set $cors "${cors}post";
}
```

接下来，在服务器中`include enable-cors.conf` 来引入跨域配置：

```nginx
# ----------------------------------------------------
# 此文件为项目 nginx 配置片段
# 可以直接在 nginx config 中 include（推荐）
# 或者 copy 到现有 nginx 中，自行配置
# www.helloworld.com 域名需配合 dns hosts 进行配置
# 其中，api 开启了 cors，需配合本目录下另一份配置文件
# ----------------------------------------------------
upstream front_server{
  server www.helloworld.com:9000;
}
upstream api_server{
  server www.helloworld.com:8080;
}

server {
  listen       80;
  server_name  www.helloworld.com;

  location ~ ^/api/ {
    include enable-cors.conf;
    proxy_pass http://api_server;
    rewrite "^/api/(.*)$" /$1 break;
  }

  location ~ ^/ {
    proxy_pass http://front_server;
  }
}
```


## 实践
### 单一主机名上的多应用
如果想要设置多个应用，可以维护一个主`nginx.conf`文件，如下：
```nginx
worker_processes  1;
events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
    include ../conf.d/*.conf;  # 导入其它配置文件，相当于把其它配置直接放到这块
}
```
在server后面通过`include`包含其它配置文件，通过端口号来区分应用
其它应用如一个文件浏览器应用的配置`browser.conf`，内容如下
```nginx
server {
	listen       82;		# 注意端口号要与主nginx.conf不同
	server_name  localhost;  # 默认地址为127.0.0.1
	location / {
		root   D:\\Github.io\\Xiang-M-J.github.io\\notes;	
		autoindex on;# 显示目录
		autoindex_exact_size on;# 显示文件大小
		autoindex_localtime on;# 显示文件时间
	}
	error_page   500 502 503 504  /50x.html;
	location = /50x.html {
		root   html;
	}  
}
```
`browser.conf`的路径如下

│  nginx.exe
│
├─conf
│      fastcgi.conf
│      fastcgi_params
│      koi-utf
│      koi-win
│      mime.types
│      **nginx.conf**
│      scgi_params
│      uwsgi_params
│      win-utf
│
├─conf.d
│      **browser.conf**

### 编译nginx（安装fancyindex）
[在 Windows 平台编译 64bit Nginx | Memo von EFS (amefs.net)](https://amefs.net/archives/1834.html#%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%9A)
[Windows下编译带fancyindex的nginx_windows nginx 生成makefile-CSDN博客](https://blog.csdn.net/m0_70211701/article/details/124442010)

#### 编译环境
1. git：代码管理、bash环境
2. Microsoft Visual Studio 2022 
3. Perl：编译openssl（[Strawberry Perl for Windows](https://strawberryperl.com/)）
4. nasm（可选）：ASM汇编优化包

#### 源码

**nginx**
[nginx: tags](https://hg.nginx.org/nginx/tags)，选择最新的版本，点击左侧的`zip`下载压缩包

**PCRE**
[PCRE - Perl Compatible Regular Expressions](https://www.pcre.org/)

**zlib**
[zlib Home Site](https://zlib.net/)

**openssl**
[/source/index.html (openssl.org)](https://www.openssl.org/source/)

**fancyindex**
```bash
git clone https://github.com/aperezdc/ngx-fancyindex
```

上述源码（除了nginx）全部放在nginx的`objs/lib`文件夹（需要额外创建）。

#### 修改编译配置
##### 修改openssl的编译配置
修改`nginx\auto\lib\openssl\makefile.msvc`
```makefile
all:
	cd $(OPENSSL)

	perl Configure VC-WIN64A no-shared no-threads		\  # 这里需要修改
		--prefix="%cd%/openssl" 				\
		--openssldir="%cd%/openssl/ssl" 			\
		$(OPENSSL_OPT)

	if exist ms\do_win64a.bat (						\     # 这里也需要修改
		ms\do_win64a						\			# 这里需要修改
		&& $(MAKE) -f ms\nt.mak					\
		&& $(MAKE) -f ms\nt.mak install				\
	) else (							\
		$(MAKE)							\
		&& $(MAKE) install_sw					\
	)
```

##### 修改编译警告等级
默认的编译警告可能会导致编译过程中以外的退出，因此我们对`nginx\auto\cc\msvc`进行修改（大约在 83 行）：

```makefile
# warnings
CFLAGS="$CFLAGS -W3" # 原本是W4，改为W3
```

##### 添加msvc linker版本

```makefile
# NGX_MSVC_VER=`$NGX_WINE $CC 2>&1 | grep 'C/C++.* [0-9][0-9]*\.[0-9]' 2>&1 \
#                                | sed -e 's/^.* \([0-9][0-9]*\.[0-9].*\)/\1/'`
# echo " + cl version: $NGX_MSVC_VER"
# 上面为原始配置，下面是修改后的
NGX_MSVC_VER=19.34 # MSVC 2022  cl 19.34
echo " + cl version: $NGX_MSVC_VER"
```
##### 删除对 manpage 的操作

由于Windows的CMD或者powershell不含sed命令，因此如果不注释相关代码，则会造成报错，但不影响二进制生成。修改`nginx\objs\Makefile`：

```makefile
manpage:    objs/nginx.8
 
objs/nginx.8:   docs/man/nginx.8 objs/ngx_auto_config.h
# 注释下面这段话
    #sed -e "s|%%PREFIX%%||" \
        #-e "s|%%PID_PATH%%|/logs/nginx.pid|" \
        #-e "s|%%CONF_PATH%%|/conf/nginx.conf|" \
        #-e "s|%%ERROR_LOG_PATH%%|/logs/error.log|" \
        #< docs/man/nginx.8 > $@
```

#### 编译

首先在nginx解压路径下创建`configure.bash`文件，内容如下

```bash
auto/configure --with-cc=cl --builddir=objs --prefix= --conf-path=conf/nginx.conf --pid-path=logs/nginx.pid --http-log-path=logs/access.log --error-log-path=logs/error.log --sbin-path=nginx.exe --http-client-body-temp-path=temp/client_body_temp --http-proxy-temp-path=temp/proxy_temp --http-fastcgi-temp-path=temp/fastcgi_temp --http-scgi-temp-path=temp/scgi_temp --http-uwsgi-temp-path=temp/uwsgi_temp --with-cc-opt=-DFD_SETSIZE=1024 --with-pcre=objs/lib/pcre2-10.42 --with-zlib=objs/lib/zlib-1.3 --with-openssl=objs/lib/openssl-3.2.0 --with-select_module --with-http_ssl_module --add-module=objs/lib/ngx-fancyindex
```

注意可能需要更改依赖库（`pcre`、`openssl`等）版本，在`git bash`的环境

```bash
bash configure.bash
```

打开`64 Native Tools Command Prompt for VS 2022`，进入nginx解压的目录

```cmd
nmake /f objs/Makefile
```

等待一段时间，即可在`objs`文件夹中生成`nginx.exe`

#### 后续操作

创建一个新文件夹，将`objs/nginx.exe`复制到新文件夹中，将源码中的`conf`、`contrib`、`docs`、`misc`文件夹复制到新文件夹中，新建`temp`、`html`、`logs`文件夹，配置文件`nginx.conf`为

```nginx
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       83;			# 此处端口应该与其它的nginx的端口不同
        server_name  localhost;
	    autoindex               on;
    	autoindex_exact_size    off;
    	autoindex_localtime     on;
    	charset                 utf-8; # 如果中文有乱码，可配置为：gbk,utf-8
     
    	fancyindex              on; # 启用插件
    	fancyindex_localtime    on; # 使用本地时间
    	fancyindex_exact_size   off; # 是否使用精确的大小，on显示字节，off显示如 M 这种
 
    	fancyindex_footer       "/fancy-theme/footer.html"; # 主题页脚文件
    	fancyindex_header       "/fancy-theme/header.html"; # 主题头部文件
    	fancyindex_ignore       "example.html"; # 忽略显示的文件名称
    	fancyindex_ignore       "fancy-theme";  # 忽略显示的目录
    	fancyindex_time_format  "%Y-%m-%d %H:%M";
        location / {
            root   D:/nginxFancyIndex;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

`/fancy-theme/footer.html`和`/fancy-theme/header.html`可以在[ShaneMcC/nginx-fancyindex-theme: Simple theme for nginx fancyindex module. (github.com)](https://github.com/ShaneMcC/nginx-fancyindex-theme)找到，将代码克隆到本地，修改`footer.html`和`header.html`中样式表和js脚本的路径为
```html
<link rel="stylesheet" href="/fancy-theme/theme.css">   <!--header.html-->
<script src="/fancy-theme/script.js"></script>  <!--footer.html-->
```
部分文件路径如下：
```
│  nginx.exe
│
├─conf
│      fastcgi.conf
│      fastcgi_params
│      koi-utf
│      koi-win
│      mime.types
│      nginx.conf
│      scgi_params
│      uwsgi_params
│      win-utf
├─fancy-theme
│      footer.html
│      header.html
│      script.js
│      theme.css
```


# 命令行

## Bash（Unix命令行）

>Bash是Unix系统中最常用的一种shell

### 特殊符号说明

`\` ：用于多行书写脚本

`||`：逻辑或，可以用于连接两条命令，第一条命令运行通过就忽略第二条命令，第一条命令不通过就执行第二条命令。


### 基本命令

#### tree

`tree [-aACdDfFgilnNpqstux][-I <范本样式>][-P <范本样式>][目录...]`

`tree`：以树状图列出当前目录结构

`tree -a`：显示当前目录中所有文件和目录

`tree -A`：使用ASNI绘图字符显示树状图而非以ASCII字符组合。

`tree -s`：列出文件或目录大小

`tree -f`：在每个文件或目录之前，显示完整的相对路径名称

#### mkdir 创建目录

```sh
mkdir test
```


#### touch 创建文件

```sh
touch test.txt
```

#### rm 删除

**删除单个文件**

```cmd
rm file
```

**删除空文件夹**

```cmd
rm -d mydir
```

**删除非空文件夹**

```cmd
rm -r mydir
```


#### chmod 修改权限

**允许sh文件执行**
```cmd
chmod +x run.sh
```


#### which 查看命令路径

```sh
which ls   # 查看 ls 命令的路径
``` 

#### du/df 查看路径大小

> 虽然可以使用`ls -lh`来查看当前目录下的文件大小，但是无法查看文件夹的大小

**查看当前路径下总大小**
```cmd
du -sh
```

**查看当前路径下文件夹和文件大小**
```cmd
du -sh * 
```

**查看当前磁盘剩余大小**
```cmd
df -h
```

#### unzip/zip 压缩解压

```sh
zip -r file.zip foo/
```

将 foo 文件夹压缩为 `file.zip`

```sh
unzip file.zip -d tmp/
```

`-d`：指定解压目录

分卷解压命令

```sh
zip -s 0 split.zip --out single.zip
unzip single.zip
```

#### find 查找文件

用于在指定目录下查找文件和目录

```sh
find [路径] [匹配条件] [动作]
```

**路径**是要查找的目录路径，可以是一个目录或文件名，也可以是多个路径，多个路径之间用空格分隔，如果未指定路径，则默认为当前目录。

**匹配条件**是可选参数，用于指定查找的条件，可以是文件名、文件类型、文件大小等等。
- `-name pattern`：按文件名查找，支持使用通配符 `*` 和 `?`。
- `-type type`：按文件类型查找，可以是 `f`（普通文件）、`d`（目录）、`l`（符号链接）等。

**动作**用于对匹配到的文件执行操作，比如删除、复制等。

>注意与 cmd 中的 find 区分


#### ln 链接

```sh
 ln [参数][源文件或目录][目标文件或目录]
```

+ ln -s 建立软链接
+ 源文件要使用绝对路径，而不使用相对路径
+ 没有 -s 参数建立的是一个硬链接文件


#### tar 打包压缩

tar 是Linux中最常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件。

```sh
tar -cvf py.tar 01.py 02.py 03.py # 打包
tar -xvf py.tar    # 解包
tar -zcvf archive.tar.gz directory  # 将 directory 压缩至 archive.tar.gz
tar -xzvf archive.tar.gz         # 解压 archive.tar.gz 
```

| 选项  | 含义                                 |
| --- | ---------------------------------- |
| c   | 生成档案文件，创建打包文件                      |
| x   | 解压档案文件                             |
| v   | 列出归档解档的详细过程，显示进度                   |
| f   | 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项后面 |

#### apt-get 软件管理

apt-get install xxx ：下载软件
apt-get remove xxx：删除软件
apt-get upgrade：更新包
apt-get update：更新软件源


#### shutdown 关机

 shutdown 命令可以安全关闭或者重新启动系统

```sh
shutdown -r now     # 重启系统
shutdown now        # 立即关机
shutdown 20:25      # 系统在今天的 20:25 关机
shutdown +10        # 再过10分钟关机
shutdown -c         # 取消之前的计划
```



### 获取系统信息

#### 查看 Linux 版本

```sh
lsb_release -a
```


#### 查看内核版本

```sh
cat /proc/version
```


#### 时间与日期

```sh
date    # 查看系统时间
cal     # calender查看日历，-y选项可以查看一年的日历
```

#### 进程信息

```sh
ps aux      # process status 查看进程的详细状况
top         # 动态显示运行中的进程并且排序
kill[-9]进程代号  # 终止指定代号的进程，-9代表强行终止
```

关于 ps 的说明

| 选项  | 含义                   |
| --- | -------------------- |
| a   | 显示终端上的所有进程，包括其他用户的进程 |
| u   | 显示进程的详细状态            |
| x   | 显示没有控制终端的进程          |
+ 提示：使用 kill 命令时，最好只终止当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃
+ PID即为进程代号
+ 要退出 top 只需按 q 即可


#### 网络信息

```sh
ifconfig    # 查询网卡信息
ping ip     # 检测到目标ip的连接是否正常
```

> ping 一般用于检测当前计算机到目标计算机之间的网络是否通畅，数值越大，速度越慢


#### 查看用户信息

| 序号  | 命令      | 作用            |
| --- | ------- | ------------- |
| 01  | id[用户名] | 查看用户UID和GID信息 |
| 02  | who     | 查看当前所有登录的用户列表 |
| 03  | whoami  | 查看当前登录用户的账户名  |

### 远程登录和复制文件

#### ssh 远程登录

```sh
ssh [-p port] user@remote
```

- user 是在远程机器上的用户名
- remote 是远程机器的地址，可以是IP/域名，或者是别名
- port 是 SSH Server 监听的端口，如果不指定，就为默认值  22

**SSH 的基本知识**
- SSH 客户端是一种使用 Secure Shell(SSH) 协议连接到远程计算机的软件程序
- SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议
    - 利用 SSH 协议可以有效防止远程管理过程中的信息泄露
    - 通过 SSH 协议可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗        
- SSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度

**域名**
- 由一串用点分割的名字组成，例如：www.baidu.com
- 是IP地址的别名 
**端口号**
- IP地址：通过IP地址找到网络上的计算机
- 端口号：通过端口号可以找到计算机上运行的程序
    - SSH服务器的默认端口为22，如果是默认端口，在连接的时候可以省略
- 常见服务器端口列表

|序号|服务|端口号|
|---|---|---|
|01|SSH服务器|22|
|02|Web服务器|80|
|03|HTTPS|443|
|04|FTP服务器|21|

> ping www.baidu.com 后可以获得它的IP地址 180.101.49.12


#### scp 复制文件
    
- 地址格式与ssh基本相同，但在指定端口时用的是大写的 -P

```sh
cp -P port 01.py user@remote:Desktop/01.py
```

把本地目录下的01.py文件复制到远程家目录的Desktop/01.py

```sh
scp -P port user@remote:Desktop/01.py 01.py
```

把远程家目录的Desktop/01.py复制到本地目录下的01.py文件

```sh
scp -r demo user@remote:Desktop
```

把本地目录下的demo文件夹复制到远程家目录的Desktop文件夹

```sh
scp -r user@remote:Desktop demo
```

把远程家目录的Desktop文件夹复制到本地目录下的demo文件夹


|选项|含义|
|---|---|
|-r|若给出的源文件是目录文件，则scp将递归复制该目录下的所有子目录和文件|
|-p|若端口不是22，则需要大写字母P指定端口|

>使用FillZilla可以实现可视化文件移动（端口选用22）


### 控制和循环

#### 控制

```sh
if [ expression ] 
then 
	Statement(s) to be executed if expression is true 
fi
```

#### 循环

```sh
#!/bin/bash
j=$1
for ((i=1; i<=j; i++))
do
touch file$i && echo file $i is ok
done
```

```sh
#!/bin/bash
echo "准备倒数5秒："
for i in $(seq 5 -1 1)
do
    echo -en "$i";sleep 1
done
echo -e "开始"
```

### 运算符

#### 比较运算符

```txt
-eq     等于  
-ne     不等于  
-gt     大于 （greater）  
-lt     小于 （less）  
-ge     大于等于  
-le     小于等于
```

1. shell中如果是等于、不等于，既可以用 -eq、-ne （外面需要加中括号），也可以用 == 、!=（外面加中括号或双括号都行）
2. shell中如果是大于，大于等于，小于，小于等于，用 -gt, -ge,-lt,-le 的话，则需要加中括号。
3. shell中大于、大于等于，小于，小于等于想用 >,>=,<,<=，则需要加双括号，而不是中括号。

#### 逻辑运算符

逻辑与：`&&`  逻辑或：`||` 逻辑非:   `!`


### 常见错误


>`[: XXXX: unexpected operator`

这种情况大概率是由于在程序中判断变量是否与另一个值相等使用了下面的语法，且在运行时使用 `sh run.sh` 命令。

```sh
if [$a == 0] then
...
fi
```

而由于 Unix 默认运行 shell 脚本的工具为 dash，不支持这种语法，所以可以通过将 `sh` 换成 `bash` 解决

```sh
# 正确的执行命令
bash run.sh
```




## CMD（Windows命令行）




**显示帮助信息**
```cmd
help tree   :: 以tree命令为例
```
**管道**
可以使用 `>`，也可以使用`|`
```cmd
tree > tree.txt
tree | grep .py
```

**顺序执行**
使用`&`或者`&&`
```cmd
touch main.py & code main.py
```
touch创建文件为bash的语法，可以换成`cd.>a.txt`。

### 基本命令

#### tree 

`tree [path] [/f][/a]`，Windows中的`tree`命令功能弱于Unix中的`tree`命令
`/f`显示每个文件中文件的名称
`/a`使用ASCII字符，而不使用扩展字符

#### del 删除文件夹

`del filename` 删除文件

删除当前目录及其子文件夹中所有符合条件的文件

```bat
del /F /Q /A /S xxxx.xx
```

#### rmdir 删除文件夹
`rmdir [/s][/q] foldername`：删除文件夹
`/s`代表删除所有子目录跟其中的档案
`/q`代表不再询问
#### type 查看文件内容

`type filename`：查看文件内容
#### netstat 查看网络状态

`netstat -ano|findstr "8080"`：查看某一端口（8080）的使用情况
#### tasklist 

`tasklist|findstr "15008"`：根据PID号找到对应的程序
`tasklist | findstr "cmd"`：根据程序名找到对应的程序
#### ren(rename)

`ren oldfilename newfilename`：文件重命名

#### find 搜索内容

`find "abc" d:\test.txt`：在D盘下的test.txt文件中查找含有 **abc** 这一字符串的所有行。

`find /i "Abc" d:\test.txt`：不区分大小写



### 脚本相关

```cmd
@echo off
```

这条命令执行之后，后面的命令（包括本条命令）均不显示，只显示执行的结果

```cmd
echo off
```

这条命令执行之后，后面的命令均不显示，只显示执行的结果，但是`echo off`还是会显示。

**启用命令扩展** <div id="commandExtension"></div>

```cmd
setlocal enableExtensions
```

:warning:**请注意cmd中所有的赋值和比较语句都不要留有空格**

```cmd
set a = 10 ❌
set a=10 ✔
if %a% == 10 (echo %a%) ❌
if %a%==10 (echo %a%)  ✔
```


### 变量

```cmd
set path=D:\abc\def
echo %path%			:: 引用变量
```

注意当变量作为参数使用时，可能需要紧贴参数使用，如

```cmd
set php_conf=D:/php-8.3.0/php.ini
D:\php-8.3.0\php-cgi.exe -b 127.0.0.1:9000 -c%php_conf%
```

#### 特殊变量

```cmd
set path=%cd%  :: 当前路径
:: 一些操作
cd %path%		:: 返回之前的路径
```
#### 参数变量
```cmd
echo %0  :: bat文件所在路径
echo %1  :: bat执行时的第一个命令行参数
echo %2  :: bat执行时的第二个命令行参数
@rem ...
echo %~f0  :: bat文件所在的完整路径
echo %~f1  :: bat执行时的第一个命令行参数（文件）的完整路径
```
#### 设置变量

**设置变量**

```cmd
set a=0
```

**支持算术操作（/a）**

```cmd
set /a a=a+10
```

**输入变量的值（/p）**

```cmd
set /p a=文件的个数
```

### 条件控制

#### if else

[if | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/if)

**基本语法**：

```cmd
if [not] ERRORLEVEL <number> <command> [else <expression>]
if [not] <string1>==<string2> <command> [else <expression>]
if [not] exist <filename> <command> [else <expression>]
```

如果启用了[命令扩展](#commandExtension)，使用以下语法

```cmd
if [/i] <string1> <compareop> <string2> <command> [else <expression>]
if cmdextversion <number> <command> [else <expression>]
if defined <variable> <command> [else <expression>]
```

`not`表示条件为假时，才执行`command`

`compareop`为三字母比较运算符，具体为

- EQU - 等于
- NEQ - 不等于
- LSS - 小于
- LEQ - 小于或等于
- GTR - 大于
- GEQ - 大于或等于

`/i`表示强制字符串比较忽略大小写，如果 string1 和 string2 仅由数字组成，则字符串将转换为数值并执行数值比较。
注意当书写`if` `else if` `else`语句时如果多行编写，需要加上`^`连接符，同时左括号与`if`同行，右括号与`^`同行，`else if`或`else`不能与`^`同行

```cmd
set a=10
set b=20
if %a%==10 (
    echo %a%
)^
else if %b%==20 (
    echo %b%
)^
else (
    echo null
)
```


**文件位置**

```cmd
if not exist product.dat echo Cannot find data file
```

```cmd
IF EXIST Product.dat (
del Product.dat
) ELSE (
echo The Product.dat file is missing.
)
```

**字符串比较**

```cmd
if (%1)==() set path1=php.ini
@rem 多语句
if (%1)==() (set nginx_conf=D:/nginx-1.24.0/conf/php.conf) ^
else (set nginx_conf=%~f1)
```
`%1`表示bat的第一个参数，上面这条语句的意思是如果未输入参数，那么`path1`设置为`php.ini`。


### 任务相关

显示任务

```cmd
tasklist	:: 显示当前运行的任务
tasklist | grep xxx		:: 查找对应的任务
```

停止任务

```cmd
tasklist | grep Code
taskkill /F /IM Code.exe
```

判断某个任务是否存在，如果存在就停止该进程

```cmd
tasklist|findstr /i "nginx.exe">nul &&taskkill /F /IM nginx.exe||echo N
```

### Bat 常见问题

#### 命令重复执行

bat 脚本的名字与系统中自带的bat名字相同，需要修改bat脚本的名字

#### 脚本只执行一行

可能是因为在bat脚本中调用了其它脚本（如另一个bat脚本，make等），可以在脚本的每行命令前加上 call 来解决这一问题。


## Powershell（Windows命令行）

### Begin

|命令|作用|
|---|---|
|程序名[文件名]|使用指定命令打开文件|
|set-location(cd) 路径|前往指定路径|
|new-item(ni) 文件名|新建文件|
|get-alias (gal)|获得当前别名|

> 当输入的路径中包含空格时，请将其用''包含

> get-alias -Definition 完整命令 获得完整命令的缩写

> gal 命令 获得命令对应的完整命令

> 使用cat命令打开中文出现乱码时，可使用 `cat 文件 -Encoding UTF8`来解决


### Help System

> 使用 `update-help -Force`来进行帮助系统更新

- 使用get-help,help或者man 命令 来获得对应命令的帮助
- `get-help *service*` 可以获得所有有关service的命令 *为通配符
- `get-verb` 获得所有动词，帮助查找对应的信息
- `get-help 命令 -Detailed` 获得详细帮助信息
- `get-help 命令 -examples` 获得示例
- `get-help 命令 -ShowWindow` 在窗口中查看帮助信息
- 需要在一行输入多个指令时，中间用`;`隔开

### The pipline
`|`：表示管道，`|`左边的命令输出是`|`右边的命令输入

- `get-service | export-csv -Path 路径名` 将内容转成csv格式并保存在文件中
- `import-csv 文件名`将csv文件数据导入powerShell
- `get-service | Export-clixml 路径名`将内容转成xml保存
- `compare-object` 比较两个对象
- `convertto-html` 将内容转换成html（仍保存在管道内）可以再次通过管道以out-file的形式输出到文件中
- 当不确定某一操作是否会带来某些不好的影响时，可以使用 `-confirm` 或者 `-whatif` 来帮助决定

### extending the shell

- `get-module` 展示目前已安装的模块，`-listavailable`将会展示可用的模块
- `get-wmiobject win32_logicaldisk -Filter "DeviceID='C:'"` 查看C盘的信息   
- 在powershell中换行输入使用|作为换行标记（在ISE中输入会报错）
- `Get-Wmiobject win32_logicaldisk -Filter "DeviceID='D:'" | select @{n='freegb';e={$_.freespace/ 1gb -as [int]}}`       将内存进行数学运算


**示例：获取磁盘信息**

```shell
<#
.Synopsis
   简短描述
.DESCRIPTION
   详细描述
.EXAMPLE
   如何使用此 cmdlet 的示例
.EXAMPLE
   另一个如何使用此 cmdlet 的示例
.INPUTS
   到此 cmdlet 的输入(如果有)
.OUTPUTS
   来自此 cmdlet 的输出(如果有)
.NOTES
   一般注释
.COMPONENT
   此 cmdlet 所属的组件
.ROLE
   此 cmdlet 所属的角色
.FUNCTIONALITY
   最准确描述此 cmdlet 的功能
#>
function get-deskinfo{
    [CmdletBinding()]
    param(
        [parameter(mandatory=$true)]
        [string[]]$computername,
        $bogus
    )

    Get-Wmiobject win32_logicaldisk -Filter "DeviceID='C:'" | select @{n='freegb';e={$_.freespace/ 1gb -as [int]}} | Out-File C:\Users\xmj\Desktop\diskinfo.txt # 获得C盘的内存
    Get-Wmiobject win32_logicaldisk -Filter "DeviceID='D:'" | select @{n='freegb';e={$_.freespace/ 1gb -as [int]}} | Out-File C:\Users\xmj\Desktop\diskinfo.txt -Append  # 获得D盘的内存
    Get-Wmiobject win32_logicaldisk -Filter "DeviceID='C:'" | Out-File C:\Users\xmj03\Desktop\diskinfo.txt -Append
    Get-Wmiobject win32_logicaldisk -Filter "DeviceID='D:'" | Out-File C:\Users\xmj03\Desktop\diskinfo.txt -Append
    Get-Wmiobject -ComputerName $computername win32_logicaldisk -Filter "DeviceID='D:'" 
}
```


# Vscode

## C/C++

### MingW编译器

[Get Started with C++ and MinGW-w64 in Visual Studio Code](https://code.visualstudio.com/docs/cpp/config-mingw)

1. 新建文件夹（如果希望添加配置，那么就需要新建文件夹，否则如果引用一些额外的库，C++可能会报错）
2. 创建源文件（代码文件），写入下列代码

```c++
#include<iostream>
#include<vector>
using namespace std;

int main(){
    vector<int> a(10);
    a.push_back(10);
    cout<<a[10]<<endl;

    return -1;
}
```

3. 上述代码直接运行时会报错，需要创建`tasks.json`（该文件在运行后默认创建），内容如下，还可以通过`ctrl+shift+p`+**Tasks: Configure Default Build Task**来创建`tasks.json`。

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++.exe build active file",
            "command": "D:\\mingw64\\bin\\g++.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

4. 对于第二步中编写的程序，实际上只需要在编译时加上`-static`参数即可，所以直接修改`tasks.json`如下

```json
{
    "tasks": [
        {
            "type": "cppbuild",   
            "label": "C/C++: g++.exe build active file",  
            "command": "D:\\mingw64\\bin\\g++.exe",		// 调用的程序
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe",
                "-static"			// 新加入的编译选项
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

此时已经可以对程序进行运行和调试，不过想要个性化调试，还需要`launch.json`。

5. 通过侧边栏`RUN AND DEBUG`中的`create a launch.json file`创建`launch.json`（选择C++ GDB/LLDB）；通过菜单栏 **Run** 中的`Add Configuration`。初始化时没有添加配置，需要自己手动通过右下角的`Add Configuration `进行添加。直接添加需要修改很多东西，可以直接将下面的代码粘贴进去

```json
{
  "configurations": [
    {
      "name": "C/C++: g++.exe build and debug active file",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",   // 调试的程序
      "args": [],
      "stopAtEntry": false,
      "cwd": "${fileDirname}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "D:\\mingw64\\bin\\gdb.exe",  // 调试器的位置
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        },
        {
          "description": "Set Disassembly Flavor to Intel",
          "text": "-gdb-set disassembly-flavor intel",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "C/C++: g++.exe build active file"  // 调试前需要做的工作（在tasks.json中定义）
    }
  ],
  "version": "2.0.0"
}
```

6. 添加额外的C/C++设置，如果希望对C/C++扩展有更多的控制，可以创建`c_cpp_properties.json` ，这样就可以更改诸如编译器路径之类的设置，包括路径、C++标准(默认为C++17)等，可以手动添加文件，也可以通过`Ctrl+shift+P`调用命令面板中命令：**C/C++: Edit Configurations (JSON)**；如果希望能够在交互式界面中配置，可以使用`Ctrl+shift+P`调用命令面板中命令：**C/C++: Edit Configurations (UI)**

对于自己编写的头文件、动态链接库，可以通过`-I`（指定头文件搜索路径），`-L`（指定库的搜索路径），`-l`（指定库名，`-l`需要和库名连接在一起使用中间没有空格）

如果想在vscode中编译多个文件可以将`tasks.json`中的`args`修改如下：

```json
"args": [
	"-fdiagnostics-color=always",
	"-g",
	"${fileDirname}\\*.c",  // 将${file}改为目录下的所有c语言文件
	"-o",
	"${fileDirname}\\${fileBasenameNoExtension}.exe"
],
```


### 编辑头文件路径

`Ctrl+Shift+P` 打开 C/C++: Edit Configurations (JSON)，在 `c_cpp_propertites.json` 中的 includePath 中添加

```json
"includePath": [
	"${workspaceFolder}/**",
	"D:\\protoc-26.1-win64\\src\\**"
],
```

## 扩展
### Live Server

Live Server与nginx的功能类似，都是通过代理实现本地服务器。

Live Server的默认端口为5500，默认根文件夹为vscode当前打开的目录，默认主机名为`127.0.0.1`，如果需要修改配置，可以参考 [vscode-live-server/docs/settings.md](https://github.com/ritwickdey/vscode-live-server/blob/HEAD/docs/settings.md)

如果当前目录中有`index.html`或`index.htm`显示`index.html`，否则只会是一个文件浏览器


# GCC

## 命令行
### 编译单个文件

`main.cpp`

```shell
g++ main.cpp -o main.exe
```

### 多文件编译

> ├── function.cpp 
> ├── function.h 
> └── main.cpp

如果在`main.cpp`中引用了`function.h`

#### 分步编译

先执行

```shell
g++ -c function.cpp main.cpp
```

再执行

```shell
g++ function.o main.o -o main
```

#### 一起编译

```shell
g++ main.cpp function.cpp -o main
```

如果一个文件夹内有多个源文件可以

```shell
g++ *.cpp -o main
```

**注意，由于在程序预处理阶段，`GCC` 编译器会自行处理各个 `.c/.c++` 文件内部引入的 `.h` 头文件（将 `.h` 文件中的代码直接拷贝到当前 `.c` 源文件中），因此编译运行项目时，我们只需要提供所有的源文件即可，不需要处理头文件。**


## CMake和Make

> make、makefile、cmake、CmakeLists.txt这四者的区别
>
> cmake和make类似，都是用来对源代码进行编译，Cmake使用CmakeLists.txt，而make使用makefile
>
> make主要用于类Unix系统，而cmake则是通用的。

### Make

[Makefile教程（绝对经典，所有问题看这一篇足够了）-CSDN博客](https://blog.csdn.net/weixin_38391755/article/details/80380786)

[Top (GNU make)](https://www.gnu.org/software/make/manual/html_node/index.html#SEC_Contents)

#### makefile介绍

##### makefile中的规则

make中最重要的便是Makefile的编写，Makefile的规则如下：

```makefile
target … : prerequisites …
        recipe
        …
        …
```

target可以是一个目标文件，也可以是执行文件，同时也可能是一个要执行的操作名，如`clean`

prerequisite：生成target所需要的文件或是目标

command：make需要执行的命令（任意shell命令）

规则表示文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。

三个变量`$@`，`$^`和`$<`的含义分别是目标文件，所有的依赖文件和第一个依赖文件。

一个简单的Makefile文件如下所示（下面的cc是编译c语言文件）

```makefile
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
```

`\`是换行符，方便Makefile的阅读。执行`make`命令便可以生成执行文件edit，如果想要删除执行文件和所有的中间目标文件，执行`make clean`命令即可。

 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个`Tab`键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。

##### make的工作方式

当我们只输入make命令后

1. make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2.  如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到`edit`这个文件，并把这个文件作为最终的目标文件。
3.  如果`edit`文件不存在，或是`edit`所依赖的后面的.o文件的文件修改时间要比`edit`这个文件新，那么，他就会执行后面所定义的命令来生成`edit`这个文件。
4.  如果`edit`所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。
5.  make会生成.o文件，然后再用.o文件声明make的最终任务，也就是执行文件edit了。

如果一个工程已被编译过了，当我们修改了其中一个源文件，比如`file.c`，那么根据依赖性，目标`file.o`会被重编译（也就是在这个依赖性关系后面所定义的命令），于是`file.o`的文件也会更新，于是`file.o`的文件修改时间要比`edit`要新，所以`edit`也会被重新链接了。如果改变了`command.h`，那么`kdb.o`、`command.o`和`files.o`都会被重编译，并且`edit`会被重链接。

##### makefile中使用变量

在上面的例子中

```makefile
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
```

`.o`文件重复了两次，这不利于makefile的修改，在复杂的工程中，这样的情况会更加严重。为了方便维护，可以定义一个变量（类似c语言中的宏）来表示`.o`文件

```makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
```

##### make的自动推导

make可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个`.o`文件后都写上类似的命令，因为make会自动识别，并推导命令。只要make看到一个`.o`文件，它就会自动的把`.c`文件加在依赖关系中，如果make找到一个`whatever.o`，那么`whatever.c`就会是`whatever.o`的依赖文件。并且`cc -c whatever.c` 也会被推导出来，于是makefile可以不用写得这么复杂。

```makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
```

这种方法是make的“隐晦规则”，上面`.PHONY`表示clean是个伪目标文件。

##### 另类风格的makefile

```makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```

`defs.h`是所有目标的前提条件，`command.h`是`kbd.o`，`command.o`和`files.o`的前提条件。

##### 清除规则

clean通常放在文件的最后，更加推荐的写法是

```makefile
.PHONY : clean
clean :
        -rm edit $(objects)
```

`.PHONY`意思表示clean是一个“伪目标”，。而在rm命令前面加了一个减号的意思就是，也许某些文件出现问题，但不要管，继续执行后续命令。


#### Makefile总述

##### Makefile中有什么

Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。

1. 显式规则。显式规则说明了，如何生成一个或多个目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
2. 隐晦规则。由于make有自动推导的功能，所以隐晦的规则允许比较粗糙地简略地书写Makefile。
3. 变量的定义。在Makefile中要定义一系列的变量，变量一般都是字符串，有点像C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
4. 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，类似C语言中的include；另一个是指根据某些情况指定Makefile中的有效部分，类似C语言中的预编译#if；还有就是定义一个多行的命令，后续介绍
5.  注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用`#`字符，这个类似C/C++中的`//`。如果你要在你的Makefile中使用`#`字符，可以用`\`进行转义，如：`\#`。

**Makefile中的命令必须以`Tab`键开始。**

可以使用make的`-f`或`--file`参数来指定makefile文件的名称。

##### 引入Makefile

在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：

```makefile
include filenames…
```

文件名可以包含 shell 文件名模式。如果文件名为空，则不包含任何内容，也不打印错误。

在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。假设已有Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了bish和bash，那么，下面的语句：

```makefile
include foo.make *.mk $(bar)
```

等价于：

```makefile
include foo.make a.mk b.mk c.mk bish bash
```

make命令开始时，会把找寻include所指出的其它Makefile，并把其内容放在当前的位置。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：

1. /usr/local/include 
2. /usr/local/include
3. /usr/include

如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条错误信息。如果想让make不考虑那些无法读取的文件，而继续执行，可以在include前加一个减号`-`。如：

```makefile
-include filename
```

其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是`sinclude`，其作用和`-include`是一样的。

除了手动引入这些Makefile，还可以通过设置环境变量`MAKEFILES`来添加，这个变量中的值是其它的Makefile，用空格分隔。但是并不建议使用这个环境变量，因为这会影响所有的Makefile。

##### make的工作方式

1. 读入所有的Makefile。

2. 读入被include的其它Makefile。
3. 初始化文件中的变量。
4. 推导隐晦规则，并分析所有规则。
5. 为所有的目标文件创建依赖关系链。
6. 根据依赖关系，决定哪些目标要重新生成。
7. 执行生成命令。


#### Makefile书写规则

规则包括两个部分，一个是依赖关系，一个是生成目标的方法。

在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的。

##### 规则举例

```makefile
foo.o : foo.c defs.h	# foo模块
	cc -c -g foo.c
```

在这个例子中，`foo.c`依赖于`foo.c`和`defs.h`的文件，如果`foo.c`和`defs.h`的文件日期要比`foo.o`新，或是`foo.o`不存在，那么依赖关系发生；同时也可以看出`foo.c`中引用了`defs.h`。

##### 规则的语法

```makefile
targets : prerequisites
	command
```

或者

```makefile
targets : prerequisites; command
	command
```

如果command另起一行书写，需要加上`Tab`键，如果直接跟在prerequisites后书写，则需要加上`;`号。

##### 在规则中使用通配符

`~`在Unix系统下指家目录，即`/home`，如`~bin`表示`/home/bin`；在Windows中可以设置环境变量`HOME`来定义`~`指向的目录。

`*`为通配符，如

```makefile
clean:
	rm -f *.o
```

但是注意不能直接给变量赋值为*.o，因为这里变量只会是`*.o`这个文件，应该使用下面的做法

```makefile
objects := $(wildcard *.o)
```

##### 文件搜寻

在大工程中，大量源文件分布在各个文件夹中，为了方便书写，可以通过设置`VPATH`这个特殊变量将需要搜索的路径告知make。

```makefile
VPATH = src:../headers
```

注意VPATH中的路径使用`:`分隔，所以这个例子中有两个路径分别为`src`和`../headers`。

除了`VPATH`这个变量，还可以通过设置`vpath`这个关键字来为不同的文件指定不同的搜索目录。具体用法有三种

```makefile
vpath pattern directories  	# 为符合模式pattern的文件指定搜索目录directories
vpath pattern				# 清除模式pattern的文件的搜索目录
vpath						# 清除所有之前指定过的文件的搜索目录
```

注意，`vpath`模式中必须包括`%`关键字，表示匹配0或多个字符

```makefile
vpath %.h ../headers		# 表示在../headers中搜索所有以.h结尾的文件
```

可以连续地使用`vpath`语句，以指定不同搜索策略。如果连续的`vpath`语句中出现了相同的`pattern`，或是被重复了的`pattern`，那么，make会按照`vpath`语句的先后顺序来执行搜索。

```makefile
vpath %.c foo
vpath % blish
vpath %.c bar
# 表示".c"结尾的文件，先在"foo"目录里，然后是"blish"，最后是"bar"目录
```

对于链接库，可以通过`-lname`，其中`name`是`libname.a`中的`name`。如

```makefile
foo : foo.c -lcurses		# -lcurses 表示libcurses.a
        cc $^ -o $@			# $^表示所有的依赖文件 $@表示目标文件
        # 相当于cc foo.c /usr/lib/libcurses.a -o foo
```

注意，链接库的搜索路径为当前目录、vpath和VPATH设置的值、`/lib`、`/usr/lib`和`/usr/local/lib`。在搜索时先搜索`libname.so`，搜索不到，再搜索`libname.a`。



##### 伪目标

在之前的例子中遇到了`clean`这一伪目标

```makefile
clean :
	rm *.o tmp
```

伪目标不是文件，所以也不会生成依赖和主动执行，需要用户显式指明目标执行，如`make clean`。伪目标不能和文件重名，为了避免这种情况，最好使用一个特殊标记`.PHONY`来显式指明一个目标是伪目标，如

```makefile
.PHONY : clean
clean :
	rm *.o tmp
```

除了`.PHONY`这个内置目标名，更多特殊内置目标名参见[Special Targets (GNU make)](https://www.gnu.org/software/make/manual/html_node/Special-Targets.html)

PHONY目标可以有前提条件，当一个文件内包含多个程序，可以通过PHONY目标在一个Makefile中编译多个程序。

```makefile
all : prog1 prog2 prog3
.PHONY : all
prog1 : prog1.o utils.o
        cc -o prog1 prog1.o utils.o
prog2 : prog2.o
        cc -o prog2 prog2.o
prog3 : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
```

伪目标也可以成为依赖

```makefile
.PHONY: cleanall cleanobj cleandiff
cleanall : cleanobj cleandiff
        rm program
cleanobj :
        rm *.o
cleandiff :
        rm *.diff
```

##### 多目标

Makefile的规则中目标可以不止一个，支持多目标，如

```makefile
bigoutput littleoutput : text.g
	generate text.g -$(subst output,,$@) > $@
```

等同于

```makefile
bigoutput : text.g
        generate text.g -big > bigoutput
littleoutput : text.g
        generate text.g -little > littleoutput
```


##### 静态规则

静态规则的语法为

```makefile
targets …: target-pattern: prereq-patterns …
        recipe
        …
```

targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。

target-pattern是指明了targets的模式，也就是的目标集模式。

prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。

看一个例子

```makefile
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
```

`targets`为定义的一系列目标文件`foo.o bar.o`；target-pattern为targets的模式，即targets中所有以`.o`结尾的文件，即`foo.o`和`bar.o`；前提条件为targets中所有以`.o`结尾的文件对应的以`.c`结尾的文件，即`foo.c`和`bar.c`。再看一个例子

```makefile
files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@
$(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $<
```

这个例子调用`$(filter %.o,$(files))`来从files中过滤出以`.o`结尾的文件。

##### 自动生成前提文件

```shell
cc -M main.c
gcc -MM main.c
```

上面的两条命令都可以给出`main.c`的依赖关系，虽然Makefile中并不能自动依赖于源文件，不过可以考虑其它的做法。为每个`name.c`的文件都生成一个`name.d`的Makefile文件，`.d`文件存放了`.c`文件的依赖关系。

于是，可以写出`.c`文件和`.d`文件的依赖关系，并让make自动更新或生成`.d`文件，并把其包含在主Makefile中，这样，就可以自动化地生成每个文件的依赖关系了。

这里给出了一个模式规则来产生`.d`文件：

```makefile
%.d: %.c
        @set -e; rm -f $@; \
         $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
         sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
         rm -f $@.$$$$
```

将这些模式规则放在主Makefile中，我们可以使用Makefile的`include`命令，来引入别的Makefile文件，如

```makefile
sources = foo.c bar.c
include $(sources:.c=.d)
```

上述语句中的`$(sources:.c=.d)`中的`.c=.d`的意思是做一个替换，把变量`$(sources)`所有`.c`的字串都替换成`.d`。


#### Makefile中的命令

##### 显示命令

```makefile
@echo About to make distribution files  # 加上@可以避免连echo一起输出
```

如果make执行时，带入make参数`-n`或`--just-print`，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。

而make参数`-s`或`--slient`则是全面禁止命令的显示。



##### 命令执行

当依赖目标比目标新时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果要让上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令。比如第一条命令是cd命令，而第二条命令应该在cd之后的基础上运行，那么就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。

```makefile
exec :
	cd /home/hchen
	pwd
exec :
	cd /home/hchen; pwd
```


##### 命令出错

忽略命令的出错，加上`-`号

```makefile
clean:
	-rm -f *.o
```

还有一个全局的方法是，给make加上`-i`或者`--ignore-errors`参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。make的参数`-k`或是`--keep-going`，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。

##### 嵌套执行make

一些大的工程会把不同模块或是不同功能的源文件放在不同的目录中，可以在每个目录中都书写一个该目录的Makefile，这有利于让Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护Makefile，这个技术对于模块编译和分段编译有着非常大的好处。

例如，有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则，总控的Makefile可以这样写：

```makefile
subsystem:
	cd subdir && $(MAKE)
```

总控的Makefile的变量如果显式声明可以传递到下级的Makefile中，但是不会覆盖下层的Makefile中所定义的变量，除非指定了`-e`参数。

如果要传递变量到下级Makefile中，可以使用这样的声明：

```makefile
export variable...
```

如果不想要传递变量到下级Makefile中，可以这样声明：

```makefile
unexport variable...
```

```makefile
export variable = value
# 等价于
variable = value
export variable
```

##### 定义命令包

如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以`define`开始，以`endef`结束，如：

```makefile
define run-yacc =
yacc $(firstword $^)
mv y.tab.c $@
endef
foo.c : foo.y
	$(run-yacc)
```

`run-yacc`是命令包的名字，不要和Makefile中的变量重名。在调用命令包时，在这个命令包的使用中，命令包`run-yacc`中的`$^`就是`foo.y`，`$@`就是`foo.c`。



#### 使用变量

Makefile中的定义的变量类似C/C++语言中的宏，代表了一个文本字串，在Makefile中执行的时候其会自动不变地展开在所使用的地方。与C/C++所不同的是，可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字、下划线（可以是数字开头），但不应该含有`:`、`#`、`=`或是空字符（空格、回车等），同时变量是大小写敏感的。传统的Makefile的变量名是全大写的命名方式，但使用大小写搭配的变量名（如MakeFlags）可以避免和系统的变量冲突，而发生意外的事情。有一些变量如`$<`、`$@`等是自动化变量。

##### 变量的规则

变量在声明时需要给予初值，而在使用时，需要给在变量名前加上`$`符号，但最好用小括号`()`或是大括号`{}`把变量给包括起来。如果要使用真实的`$`字符，那么需要用`$$`来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。

##### 变量中的变量

可以将变量赋给变量，如

```makefile
foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:;echo $(foo)  # 此处$(foo)为Huh?
```

使用`=`可以将还未定义的变量赋给另一个变量，但是这样可能出现循环嵌套的问题，所以可以考虑使用`:=`

```makefile
x := foo
y := $(x) bar
x := later
# 等价于
y := foo bar
x := later
```

使用`:=`时，前面的变量不能使用后面的变量，下面看一个更加复杂的例子

```makefile
ifeq (0,${MAKELEVEL})
whoami    := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif
```

描述一个空格（在`$(nullstring)`和`#`之间隔着一个空格）

```makefile
nullstring :=
space := $(nullstring) # end of the line 
```

路径表示

```makefile
dir := /foo/bar#注释要紧贴着字符写
# 路径后面不要接空格，否则会出现错误
```


##### 变量高级用法

**变量值的替换**

```makefile
foo := a.o b.o l.a c.o
bar := $(foo:.o=.c)	# bar设置为a.c b.c l.a c.c
```

另外一种变量替换的技术是以“静态模式”定义的

```makefile
foo := a.o b.o l.a c.o
bar := $(foo:%.o=%.c)
```

**把变量的值再当成变量**

```makefile
x = y
y = z
z = Hello
a := $($(x))	# a为z即Hello
```

##### 设置变量

`=`定义的变量是递归展开的变量，`:=`和`::=`定义的变量是直接扩展变量，`?=`定义的变量如果还未设置值，就赋值，如果已经设置值，就不赋值。

```makefile
FOO ?= bar
```

```makefile
ifeq ($(origin FOO), undefined)
FOO = bar
endif
```

这两段的功能类似。

##### 追加变量值

可以使用`+=`操作符给变量追加值

```makefile
objects = main.o foo.o bar.o utils.o
objects += another.o		# objects变为main.o foo.o bar.o utils.o another.o
```



##### override指示符

如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用`override`指示符。其语法是：

```makefile
override variable = value
override variable := value
```

##### 多行变量

还有一种设置变量值的方法是使用`define`关键字。使用`define`关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面的命令包技术就是利用这个关键字）。`define`指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以`endef`关键字结束。其工作方式和`=`操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以`Tab`键开头，所以如果用`define`定义的命令变量中没有以`Tab`键开头，那么make就不会把其认为是命令。

##### 环境变量

make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）



#### 条件语句

下面的例子，判断`$(CC)`变量是否为`gcc`，如果是的话，则使用GNU函数编译目标。

```makefile
libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
	$(CC) -o foo $(objects) $(libs_for_gcc)
else
    $(CC) -o foo $(objects) $(normal_libs)
endif
```

##### 语法

完整的例子

```makefile
conditional-directive-one
text-if-one-is-true
else conditional-directive-two
text-if-two-is-true
else
text-if-one-and-two-are-false
endif
```

其中`conditional-directive-one`表示条件关键字，这个关键字有四个，如`ifeq`。

`ifeq`：比较两个变量是否相等

```makefile
ifeq ($(strip $(foo)),)		# 如果strip函数返回值为空，那么为真
text-if-empty
endif
```

`ifneq`：比较两个变量是否不同，不同则为真

`ifdef`：判断一个变量是否有值

`ifndef`：判断一个变量是否无值（与`ifdef`相反）



#### 使用函数

##### 函数的调用

```makefile
$(function arguments)
${function arguments}
```

```makefile
comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))  # 把foo中的空格替换成, 即bar的值设置为a,b,c
```

subst是一个替换函数，这个函数有三个参数，第一个参数是被替换字符串，第二个参数是替换字符串，第三个参数是替换操作作用的字符串。



##### 字符串处理函数

1. `$(subst from,to,text)`：字符串替换

```makefile
$(subst ee,EE,feet on the street)	# fEEt on the strEEt
```

2. `$(patsubst pattern,replacement,text)`：模式字符串替换，text中的单词以空格、换行、`Tab`分隔

```makefile
$(patsubst %.c,%.o,x.c.c bar.c)		# x.c.o bar.o
```

3. `$(strip string)`：去除string中开头和结尾的空格

```makefile
$(strip a b c )			#a b c#
```

还有查找、过滤、排序、索引单词列表、索引列表中多个单词并返回列表、返回单词数、开始和末尾单词函数参见[Text Functions (GNU make)](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html)

##### 文件名操作函数

1. `$(dir names…)`：取目录函数，返回文件名序列

```makefile
$(dir src/foo.c hacks)  # src/ ./
```

2. `$(notdir names…)`：取文件函数，返回文件名序列的非目录部分

```makefile
$(notdir src/foo.c hacks)	# foo.c hacks
```

还有取后缀`suffix`，前缀`basename`，加后缀`addsuffix`，加前缀`addprefix`，连接`join`等函数参见[File Name Functions (GNU make)](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html)

##### 条件函数

`if`、`and`、`or`、`intcmp`（整数比较）具体参见[Conditional Functions (GNU make)](https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html)



##### foreach

语法为：`$(foreach var,list,text)`

```makefile
dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
```

等同于

```makefile
files := $(wildcard a/* b/* c/* d/*)
```



##### file

用来读取和写入文件，`$(file op filename[,text])`

`op`：`>`表示文件将被覆写，`>>`表示内容会被添加到文件中，`<`表示读取。

```makefile
program: $(OBJECTS)
        $(file >$@.in,$^)
        $(CMD) $(CMDFLAGS) @$@.in
        @rm $@.in
```



##### call

call函数是唯一一个可以用来创建新的参数化的函数。可以写一个非常复杂的表达式，这个表达式中，可以定义许多参数，然后可以用call函数来向这个表达式传递参数。其语法是`$(call variable,param,param,…)`

```makefile
reverse = $(2) $(1)
foo = $(call reverse,a,b)		# foo为 b a
```

variable对应的表达式的返回值就是call的返回值，传参后，表达式中通过`$(1)`这种形式来使用参数。

##### origin

origin函数的功能是返回变量的来源，其语法是`$(origin variable)`，详细参见[Origin Function (GNU make)](https://www.gnu.org/software/make/manual/html_node/Origin-Function.html)

##### shell

执行shell命令

```makefile
contents := $(shell cat foo)	# contents被赋值为foo文件的内容
```

##### 控制函数

`$(error text...)`

```cmake
ifdef ERROR1
$(error error is $(ERROR1))		# 输出错误信息
endif
```

`$(warning text...)`

`$(info text...)`

#### make的运行

##### 指定目标

在具体编写Makefile可以考虑编写以下target

> all       这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
>
> clean   这个伪目标功能是删除所有被make创建的文件。
>
> install   这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
>
> print     这个伪目标的功能是例出改变过的源文件。
>
> tar       这个伪目标功能是把源程序打包备份。也就是一个tar文件。
>
> dist      这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。
>
> TAGS     这个伪目标功能是更新所有的目标，以备完整地重编译使用。
>
> check和test   这两个伪目标一般用来测试makefile的流程。

##### make的参数

[Options Summary (GNU make)](https://www.gnu.org/software/make/manual/html_node/Options-Summary.html)



#### 隐含规则

详细参见[Makefile教程（绝对经典，所有问题看这一篇足够了）-CSDN博客](https://blog.csdn.net/weixin_38391755/article/details/80380786)或[Implicit Rules (GNU make)](https://www.gnu.org/software/make/manual/html_node/Implicit-Rules.html)



### CMake

**CMake跨平台**

使用"Unix Makefiles" Generator可以生成Makefile

使用"Ninja"Generator可以生成build.ninja（ninja是一个比make更快速的小型构建系统，在Google的系统中使用较多）

使用"Visual Studio 16 2019"Generator可以生成project.sln

[CMake Tutorial — CMake 3.28.0-rc6 Documentation](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)

**在配置文件中指定编译器**

```cmake
set (CMAKE_C_COMPILER "D:/mingw64/bin/gcc")
set (CMAKE_CXX_COMPILER "D:/mingw64/bin/g++")
```

同时在执行时指明参数`-G "MinGW Makefiles"`

```cmd
cmake -Bbuild -G "MinGW Makefiles"
```

#### 在vscode中使用

[Get started with CMake Tools on Linux (visualstudio.com)](https://code.visualstudio.com/docs/cpp/CMake-linux#_create-a-cmake-project)

安装CMake Tools和CMake扩展

使用vscode打开一个文件夹，`ctrl+shift+p`打开命令面板，输入`CMake: Quick Start `

1. 选定kit，即gcc、visual studio等
2. 之后选择`CMakeLists.txt`，如果没有选择，可以先打开选择窗口再取消选择。这时会跳到创建一个新工程，需要输入工程名
3. 之后选择c++还是c语言
4. 最后选择创建一个库或者可执行文件

选择完之后，会创建一个`main.cpp`、`CMakeLists.txt`和用于存放编译文件的build文件夹。

此时在vscode的侧边栏中看到CMake栏（在Explorer、Search下面），里面有Configure、Build、Test（测试）、Debug（调试）、Launch（运行）。

如果希望能够在执行时带参数，参见[vscode-cmake-tools/docs/debug-launch.md at main · microsoft/vscode-cmake-tools (github.com)](https://github.com/microsoft/vscode-cmake-tools/blob/main/docs/debug-launch.md#debug-using-a-launchjson-file)

创建`launch.json`，并写入下面内容

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) Launch",
            "type": "cppdbg",
            "request": "launch",
            // Resolved by CMake Tools:
            "program": "${command:cmake.launchTargetPath}",
            "args": [],   // 在这里加入参数即可，注意应该是字符串，即使是数字也要用""括起来
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [
                {
                    // add the directory where our target was built to the PATHs
                    // it gets resolved by CMake Tools:
                    "name": "PATH",
                    "value": "${env:PATH}:${command:cmake.getLaunchTargetDirectory}"
                },
                {
                    "name": "OTHER_VALUE",
                    "value": "Something something"
                }
            ],
            "console": "externalTerminal",
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ]
        }
    ]
}
```

后面不能使用默认的执行或CMake的执行，要使用Run and Debug中的执行。

#### 一个较为完整的C++项目

[Xiang-M-J/CmakeTest: 尝试使用CMake+Vscode进行C++项目的编写 (github.com)](https://github.com/Xiang-M-J/CmakeTest/tree/main)

[CmakeTest: 尝试使用CMake+Vscode进行C++项目的编写 (gitee.com)](https://gitee.com/xiang-m-j/CmakeTest)

#### 一些函数
##### 输出变量
```cmake
set(values a 1 b 2 c 3 d 4 e 5)
message(${values})
```
##### 列表操作
```cmake
set(values a 1 b 2 c 3 d 4 e 5)
list(REMOVE_AT values 0 2 4 6 8)
message("values: ${values}") # values: 1;2;3;4;5
```

#### 官方教程
##### 开始

###### 构建一个基本项目

声明所需CMake的最低版本

```cmake
cmake_minimum_required(VERSION 3.10)
```

设置项目名

```cmake
project(Tutorial)
```

在项目中添加执行文件

```cmake
add_executable(Tutorial tutorial.cxx)
```

###### 指定C++标准

设置C++标准为11

```cmake
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
```

###### 添加版本号和配置头文件

添加版本号

```cmake
project(Tutorial VERSION 1.0)
```

配置头文件

```cmake
configure_file(TutorialConfig.h.in TutorialConfig.h)
```

使用`target_include_directories`包括`${PROJECT_BINARY_DIR}`，对于`PROJECT_BINARY_DIR`，如果是in source编译，指的就是工程顶层目录；如果是out-of-source编译，指的是工程编译发生的目录。

```cmake
target_include_directories(Tutorial PUBLIC
"${PROJECT_BINARY_DIR}"
)
```

在`TutorialConfig.h.in`中定义版本号

```c
// the configured options and settings for Tutorial
#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@
```

在c++文件中包含头文件并输出版本号

```c++
#include "TutorialConfig.h"

if (argc < 2) {
    // report version
    std::cout << argv[0] << " Version " << Tutorial_VERSION_MAJOR << "."
              << Tutorial_VERSION_MINOR << std::endl;
    std::cout << "Usage: " << argv[0] << " number" << std::endl;
    return 1;
}
```

现在可以开始编译程序了

```shell
cmake .   # 配置项目并生成本机构建系统（Windows下生成.sln文件）
cmake --build .		# 编译、连接项目
cd Debug			# 进入Debug
Tutorial			# 执行文件
```

完整的`CMakeLists.txt`如下所示

```cmake
# TODO 1: Set the minimum required version of CMake to be 3.10
cmake_minimum_required(VERSION 3.10)

# TODO 2: Create a project named Tutorial
project(Tutorial)

# TODO 7: Set the project version number as 1.0 in the above project command
project(Tutorial VERSION 1.0)

# TODO 6: Set the variable CMAKE_CXX_STANDARD to 11
#         and the variable CMAKE_CXX_STANDARD_REQUIRED to True
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# TODO 8: Use configure_file to configure and copy TutorialConfig.h.in to
#         TutorialConfig.h
configure_file(TutorialConfig.h.in TutorialConfig.h)

# TODO 3: Add an executable called Tutorial to the project
# Hint: Be sure to specify the source file as tutorial.cxx
add_executable(Tutorial tutorial.cxx)

# TODO 9: Use target_include_directories to include ${PROJECT_BINARY_DIR}
target_include_directories(Tutorial PUBLIC
	"${PROJECT_BINARY_DIR}"
)
```

##### 添加一个库

文件结构

```shell
D:.
│  CMakeLists.txt
│  tutorial.cxx
│  TutorialConfig.h.in
│
└─MathFunctions
        CMakeLists.txt
        MathFunctions.cxx
        MathFunctions.h
        mysqrt.cxx
        mysqrt.h
```

###### 创建一个库

首先需要在MathFunctions中创建一个库，在`MathFunctions/CMakeLists.txt`中添加库目标

```cmake
add_library(MathFunctions MathFunctions.cxx mysqrt.cxx)
```

之后在主`CMakeLists.txt`中添加子文件夹，编译子文件夹

```cmake
add_subdirectory(MathFunctions)
```

接下来，使用`target_link_library()`将新的库目标链接到可执行目标

```cmake
target_link_libraries(Tutorial PUBLIC MathFunctions)
```

最后，我们需要指定库的头文件位置。修改`target_include_directory()` ，将`MathFunctions.h`子目录添加为`include`目录，以便可以找到`MathFunctions.h`头文件。注意，`${PROJECT_SOURCE_DIR}` 是源文件的存放路径。

```cmake
target_include_directories(Tutorial PUBLIC
"${PROJECT_BINARY_DIR}"			                       "${PROJECT_SOURCE_DIR}/MathFunctions"
)
```


###### 添加一个可选参数

在MathFunctions中添加一个可选参数来让开发人员选择使用自定义的的平方根实现还是内置的标准实现

首先在库文件夹中的`CMakeLists.txt`即`MathFunctions/CMakeLists.txt`中添加一个可选项（使用option）

```cmake
option(USE_MYMATH "Use tutorial provided math implementation" ON)
```

如果`USE_MYMATH`是`ON`，使用`target_compile_definitions`传递`USE_MYMATH`作为预编译定义到源文件中

```cmake
if(USE_MYMATH)
    target_compile_definitions(MathFunctions PRIVATE "USE_MYMATH")
endif(USE_MYMATH)
```

接着要利用上面定义的`USE_MYMATH`来决定`MathFunctions.cxx`中是否使用mysqrt和引入头文件

```c++
#ifdef USE_MYMATH
#include "mysqrt.h"
#endif

#ifdef USE_MYMATH
return detail::mysqrt(x);
#else
return std::sqrt(x);
#endif
```

现在如果`USE_MYMATH`是OFF，那么在编译时就不会定义`USE_MYMATH`，这样就会使用内置的sqrt函数，但此时虽然不用`mysqrt.cxx`，但由于使用了`add_library()`添加了`mysqrt.cxx`，所以仍然会被编译。为了解决这一问题，第一种方法是在`USE_MYMATH`时，使用`target_sources()`添加`mysqrt.cxx`；另一种方法是在`USE_MYMATH`中添加一个额外的库来编译`mysqrt.cxx`。来看一下第二种方法

创建一个额外的库`SqrtLibrary`包含源文件`mysqrt.cxx`

```cmake
add_library(SqrtLibrary STATIC mysqrt.cxx)
```

当USE_MYMATH被允许时，将`SqrtLibrary`链接到`MathFunctions`上

```cmake
target_link_libraries(MathFunctions PRIVATE SqrtLibrary)
```

注意将原本`add_library(MathFunctions MathFunctions.cxx mysqrt.cxx)`中的`mysqrt.cxx`删除

完成上述操作后，执行下列命令构建工程

```shell
cmake -DUSE_MYMATH=OFF -Bbuild
```

`-D`：定义CMake变量；`-B`：指定构建目录

链接工程

```shell
cmake --build ./build
```



##### 添加库的使用要求

目标参数的使用要求允许对库或可执行文件的链接和包含行进行更好的控制，同时也允许对 CMake 内部目标的传递属性进行更多的控制。

###### 为一个库添加使用要求

我们希望声明，任何链接到`Mathfunction`都需要包含当前的源目录，而`Mathfunction`本身不需要。这可以用一个`INTERFACE`使用要求来表示，INTERFACE指的是消费者（链接这个库）需要但生产者（库本身）不需要的东西。

在`MathFunctions/CMakeLists.txt`中，使用`INTERFACE`关键词`target_include_directories()`

```cmake
target_include_directories(MathFunctions
INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})
```

在上一节中，我们在主`CMakeLists.txt`是这样导入库的

```cmake
target_include_directories(Tutorial PUBLIC
                          "${PROJECT_BINARY_DIR}"
                          "${PROJECT_SOURCE_DIR}/MathFunctions"
                          )
```

`list(APPEND EXTRA_INCLUDES "${PROJECT_SOURCE_DIR}/MathFunctions")`：添加一个变量`EXTRA_INCLUDES`为`"${PROJECT_SOURCE_DIR}/MathFunctions"`。

由于在`MathFunctions/CMakeLists.txt`已经使用了`INTERFACE`要求任何链接到`Mathfunction`都需要包含源目录，所以这里可以删除变成

```cmake
target_include_directories(Tutorial PUBLIC
                          "${PROJECT_BINARY_DIR}"
                          )
```

###### 使用接口库设置C++标准

将原本的设置C++标准的程序删除

```cmake
set(CMAKE_CXX_STANDARD 11)		# 删除
set(CMAKE_CXX_STANDARD_REQUIRED True)	# 删除
```

使用下面的设置方式

```cmake
add_library(tutorial_compiler_flags INTERFACE)
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)
```

接口库设置完成后，需要将可执行文件`Tutorial`、`SqrtLibrary`库和`MathFunctions`库链接到新的`tutorial_compiler_flags`库。

主`CMakeLists.txt`

```cmake
target_link_libraries(Tutorial PUBLIC MathFunctions tutorial_compiler_flags)
```

`MathFunctions/CMakeLists.txt`

```cmake
target_link_libraries(SqrtLibrary PUBLIC tutorial_compiler_flags)
target_link_libraries(MathFunctions PUBLIC tutorial_compiler_flags)
```



##### 添加生成器表达式

在生成系统生成期间计算生成器表达式，以生成特定于每个生成配置的信息。

###### 使用生成器表达式添加编译器警告标志

将Cmake的版本要求设置为3.15

```cmake
cmake_minimum_required(VERSION 3.15)
```

接下来，我们确定系统当前使用哪个编译器进行生成，因为警告标志因所使用的编译器而异。这是使用`COMPILE_LANG_AND_ID`生成器表达式完成的，我们在变量`gcc_like_cxx`和`msvc_cxx`中设置结果如下：

```cmake
set(gcc_like_cxx "$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC>")
set(msvc_cxx "$<COMPILE_LANG_AND_ID:CXX,MSVC>")
```

使用`target_compile_options`将这些标记应用到接口库中

```cmake
target_compile_options(tutorial_compiler_flags INTERFACE
  "$<${gcc_like_cxx}:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused>"
  "$<${msvc_cxx}:-W3>"
)
```

最后，我们只希望在构建期间使用这些警告标志。已安装项目的使用者不应继承警告标志，为了指定这一点，我们使用`BUILD_INTERFACE`条件将标志包装到一个生成器表达式中。

```cmake
target_compile_options(tutorial_compiler_flags INTERFACE
  "$<${gcc_like_cxx}:$<BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused>>"
  "$<${msvc_cxx}:$<BUILD_INTERFACE:-W3>>"
)
```



##### 安装和测试

###### 安装规则

有时候单纯的生成可执行文件是不够的，还需要可安装，安装规则如下

对于`MathFunctions`，我们希望分别安装库和头文件到`lib`和`include`文件夹中

对于`Tutorial`这个可执行文件，我们希望分别安装可执行文件和配置头文件到`bin`和`include`文件夹

对于`MathFunctions/CMakeLists.txt`，添加

```cmake
set(installable_libs MathFunctions tutorial_compiler_flags)
if(TARGET SqrtLibrary)
  list(APPEND installable_libs SqrtLibrary)
endif()
install(TARGETS ${installable_libs} DESTINATION lib)
install(FILES MathFunctions.h DESTINATION include)
```

对于主`CMakeLists.txt`，添加

```cmake
install(TARGETS Tutorial DESTINATION bin)
install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h"
  DESTINATION include
  )
```

执行安装

```cmd
cmake --install .
```

```cmd
cmake --install . --config Release
cmake --install . --prefix "/home/myuser/installdir"
```

`--config`：指定配置；`--prefix`：指定前缀


###### 测试

首先要允许测试

```cmake
enable_testing()
```

然后就是添加测试（Tutorial 25）

```cm
add_test(NAME Runs COMMAND Tutorial 25)   # 添加一个名为Runs的测试
```

接下来，使用`PASS_REGULAR_EXRESION`测试属性来验证测试的输出是否包含某些字符串。在这种情况下，验证在提供了不正确数量的参数时是否打印了使用信息。

```cmake
add_test(NAME Usage COMMAND Tutorial)
set_tests_properties(Usage
  PROPERTIES PASS_REGULAR_EXPRESSION "Usage:.*number"
  )
```

接下来测试是否输出正确结果

```cmake
add_test(NAME StandardUse COMMAND Tutorial 4)
set_tests_properties(StandardUse
  PROPERTIES PASS_REGULAR_EXPRESSION "4 is 2"
  )
```

多添加几个测试，为了方便编写，定义一个函数`do_test`

```cmake
function(do_test target arg result)
  add_test(NAME Comp${arg} COMMAND ${target} ${arg})
  set_tests_properties(Comp${arg}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result}
    )
endfunction()

# do a bunch of result based tests
do_test(Tutorial 4 "4 is 2")
do_test(Tutorial 9 "9 is 3")
do_test(Tutorial 5 "5 is 2.236")
do_test(Tutorial 7 "7 is 2.645")
do_test(Tutorial 25 "25 is 5")
do_test(Tutorial -25 "-25 is (-nan|nan|0)")
do_test(Tutorial 0.0001 "0.0001 is 0.01")
```

测试时，使用

```cmd
ctest
```

`-C`：指定配置（debug或是Release）；`-V`允许详细输出；`-VV`：允许更加详细的输出

详见[ctest(1) — CMake 3.28.0-rc6 Documentation](https://cmake.org/cmake/help/latest/manual/ctest.1.html)



##### 添加测试仪表盘的支持

使用CDash展示测试结果

在顶层文件夹创建`CTestConfig.cmake`

```cmake
set(CTEST_PROJECT_NAME "CMakeTutorial")
set(CTEST_NIGHTLY_START_TIME "00:00:00 EST")

set(CTEST_DROP_METHOD "http")
set(CTEST_DROP_SITE "my.cdash.org")
set(CTEST_DROP_LOCATION "/submit.php?project=CMakeTutorial")
set(CTEST_DROP_SITE_CDASH TRUE)
```

还需要在`CMakeLists.txt`中添加

```cmake
include(CTest)
```

执行时输入

```cmd
ctest [-VV] -D Experimental
```

注意这个似乎会将测试文件发送至公共Dashboard，任何人都可以看到，可能需要改一下配置。



###### 添加系统自检

当我们考虑向项目添加一些代码时，这些代码可能依赖于目标平台不具备的特性。此时可以使用系统自检来帮助判断。

首先添加`CheckCXXSourceCompiles`，因为考虑向MathFunctions中添加一些代码，所以在`MathFunctions/CMakeLists.txt`中添加

```cmake
include(CheckCXXSourceCompiles)
```

判断目标平台是否支持log和exp

```cmake
check_cxx_source_compiles("
    #include <cmath>
    int main() {
      std::log(1.0);
      return 0;
    }
  " HAVE_LOG)
check_cxx_source_compiles("
#include <cmath>
int main() {
  std::exp(1.0);
  return 0;
}
" HAVE_EXP)
```

如果支持log和exp，那么使用`target_compile_definitions`来定义

```cmake
if(HAVE_LOG AND HAVE_EXP)
    target_compile_definitions(SqrtLibrary
                               PRIVATE "HAVE_LOG" "HAVE_EXP"
                               )
  endif()
  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)
endif()
```

接着在源文件加入代码

```c++
#include<cmath>
#if defined(HAVE_LOG) && defined(HAVE_EXP)
  double result = std::exp(std::log(x) * 0.5);
  std::cout << "Computing sqrt of " << x << " to be " << result
            << " using log and exp" << std::endl;
#else
  double result = x;

  // do ten iterations
  for (int i = 0; i < 10; ++i) {
    if (result <= 0) {
      result = 0.1;
    }
    double delta = x - (result * result);
    result = result + 0.5 * delta / result;
    std::cout << "Computing sqrt of " << x << " to be " << result << std::endl;
  }
#endif
```



##### 添加自定义命令和生成文件

假设出于本教程的目的，我们决定不使用平台 log 和 exp 函数，而是生成一个包含预计算值的表，以便在 mysqrt 函数中使用。在本节中，我们将创建表作为构建过程一部分，然后将该表编译到应用程序中。

首先创建`MathFunctions/MakeTable.cmake`，并在其中加入以下代码

```cmake
add_executable(MakeTable MakeTable.cxx)
target_link_libraries(MakeTable PRIVATE tutorial_compiler_flags)
add_custom_command(				# 自定义命令
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h     # 生成Table.h
  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  DEPENDS MakeTable
  )
  
```

现在需要让CMake知道`mysqrt.cxx`依赖于生成的文件`Table.h`，在`MathFunctions/CMakeLists.txt`中加入

```cmake
include(MakeTable.cmake)	# 放在开始
add_library(SqrtLibrary STATIC
              mysqrt.cxx
              ${CMAKE_CURRENT_BINARY_DIR}/Table.h
              )
target_include_directories(SqrtLibrary PRIVATE
                             ${CMAKE_CURRENT_BINARY_DIR}
                             )
```

最后是对源文件的修改

```c++
double mysqrt(double x)
{
	if (x <= 0) {
		return 0;
	}
	
	// use the table to help find an initial value
	double result = x;
	if (x >= 1 && x < 10) {
		std::cout << "Use the table to help find an initial value " << std::endl;
		result = sqrtTable[static_cast<int>(x)];
	}
	
	// do ten iterations
	for (int i = 0; i < 10; ++i) {
		if (result <= 0) {
			result = 0.1;
		}
		double delta = x - (result * result);
		result = result + 0.5 * delta / result;
		std::cout << "Computing sqrt of " << x << " to be " << result << std::endl;
	}
		
	return result;
}
```

#### CMake使用
##### 编译lua（多文件编译多个可执行文件）
###### 下载[Lua](https://www.lua.org/download.html)的源码

解压至文件内，进入`src`文件夹内

###### 编译Lua

编写`CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.0.0)
project(lua VERSION 0.1.0 LANGUAGES C)

include(CTest)
enable_testing()
aux_source_directory(. C_LIST)
list(REMOVE_ITEM C_LIST "./luac.c")
add_executable(lua ${C_LIST})

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
```

使用`aux_source_directory(. C_LIST)`来获取目录下的所有源文件（c或cpp），`list(REMOVE_ITEM C_LIST "./luac.c")`过滤掉`.luac.c`

```cmd
cmake -Bbuild
cmake --build ./build
```

###### 编译Luac

```cmake
cmake_minimum_required(VERSION 3.0.0)
project(luac VERSION 0.1.0 LANGUAGES C)

include(CTest)
enable_testing()
aux_source_directory(. C_LIST)
list(REMOVE_ITEM C_LIST "./lua.c")
add_executable(luac ${C_LIST})

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
```

过滤掉`./lua.c`

```cmd
cmake -Bbuildc
cmake --build ./buildc
```

###### 同时编译

```cmake
cmake_minimum_required(VERSION 3.0.0)
project(lua VERSION 0.1.0 LANGUAGES C)

include_directories("${PROJECT_BINARY_DIR}")
 
# Find all lua*.c files and store in list luamain
file(GLOB_RECURSE luamain RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/lua*.c")
aux_source_directory(. C_LIST)
list(REMOVE_ITEM C_LIST "./lua.c" "./luac.c")

foreach(mainfile IN LISTS luamain)
    # Get file name without directory
    get_filename_component(mainname ${mainfile} NAME_WE)
    add_executable(${mainname} ${mainfile} ${C_LIST})
endforeach()

include(CTest)
enable_testing()

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
```

`get_filename_component(mainname ${mainfile} NAME_WE)`，`NAME_WE`表示既不包含目录也不包含最长扩展名的文件名

```cmd
cmake -Bbuild && cmake --build ./build
```
